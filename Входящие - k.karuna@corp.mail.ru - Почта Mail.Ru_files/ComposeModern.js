/* 2013-07-16 19:50:43 */


// data/ru/images/js/ru/build/ComposeModern.js start

if( 'jQuery' in window ) (function (jQuery, $) {

// @build
// @build-exclude: build/core.js
// @build-exclude: build/MsgList.js
// @build-jquery
// @build-minify
// @deploy-wait-for: http://js.imgsmail.ru/u/js/ru/build/ComposeModern.js

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.Modern.js start


// data/ru/images/js/ru/tiny_mce_modern/tiny_mce.js start

/**
 * tinymce.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(win) {
	var whiteSpaceRe = /^\s*|\s*$/g,
		undefined, isRegExpBroken = 'B'.replace(/A(.)|B/, '$1') === '$1';

	/**
	 * Core namespace with core functionality for the TinyMCE API all sub classes will be added to this namespace/object.
	 *
	 * @static
	 * @class tinymce
	 * @example
	 * // Using each method
	 * tinymce.each([1, 2, 3], function(v, i) {
	 *   console.log(i + '=' + v);
	 * });
	 *
	 * // Checking for a specific browser
	 * if (tinymce.isIE)
	 *   console.log("IE");
	 */
	var tinymce = {
		/**
		 * Major version of TinyMCE build.
		 *
		 * @property majorVersion
		 * @type String
		 */
		majorVersion : '@@tinymce_major_version@@',

		/**
		 * Major version of TinyMCE build.
		 *
		 * @property minorVersion
		 * @type String
		 */
		minorVersion : '@@tinymce_minor_version@@',

		/**
		 * Release date of TinyMCE build.
		 *
		 * @property releaseDate
		 * @type String
		 */
		releaseDate : '@@tinymce_release_date@@',

		/**
		 * Initializes the TinyMCE global namespace this will setup browser detection and figure out where TinyMCE is running from.
		 */
		_init : function() {
			var t = this, d = document, na = navigator, ua = na.userAgent, i, nl, n, base, p, v;

			/**
			 * Constant that is true if the browser is Opera.
			 *
			 * @property isOpera
			 * @type Boolean
			 * @final
			 */
			t.isOpera = win.opera && opera.buildNumber;

			/**
			 * Constant that is true if the browser is WebKit (Safari/Chrome).
			 *
			 * @property isWebKit
			 * @type Boolean
			 * @final
			 */
			t.isWebKit = /WebKit/.test(ua);

			/**
			 * Constant that is true if the browser is IE.
			 *
			 * @property isIE
			 * @type Boolean
			 * @final
			 */
			t.isIE = !t.isWebKit && !t.isOpera && (/MSIE/gi).test(ua) && (/Explorer/gi).test(na.appName);

			/**
			 * Constant that is true if the browser is IE 6 or older.
			 *
			 * @property isIE6
			 * @type Boolean
			 * @final
			 */
			t.isIE6 = t.isIE && /MSIE [56]/.test(ua);

			/**
			 * Constant that is true if the browser is IE 7.
			 *
			 * @property isIE7
			 * @type Boolean
			 * @final
			 */
			t.isIE7 = t.isIE && /MSIE [7]/.test(ua);

			/**
			 * Constant that is true if the browser is IE 8.
			 *
			 * @property isIE8
			 * @type Boolean
			 * @final
			 */
			t.isIE8 = t.isIE && /MSIE [8]/.test(ua);

			/**
			 * Constant that is true if the browser is IE 9.
			 *
			 * @property isIE9
			 * @type Boolean
			 * @final
			 */
			t.isIE9 = t.isIE && /MSIE [9]/.test(ua);

			/**
			 * Constant that is true if the browser is Gecko.
			 *
			 * @property isGecko
			 * @type Boolean
			 * @final
			 */
			t.isGecko = !t.isWebKit && /Gecko/.test(ua);

			/**
			 * Constant that is true if the os is Mac OS.
			 *
			 * @property isMac
			 * @type Boolean
			 * @final
			 */
			t.isMac = ua.indexOf('Mac') != -1;

			/**
			 * Constant that is true if the runtime is Adobe Air.
			 *
			 * @property isAir
			 * @type Boolean
			 * @final
			 */
			t.isAir = /adobeair/i.test(ua);

			/**
			 * Constant that tells if the current browser is an iPhone or iPad.
			 *
			 * @property isIDevice
			 * @type Boolean
			 * @final
			 */
			t.isIDevice = /(iPad|iPhone)/.test(ua);

			/**
			 * Constant that is true if the current browser is running on iOS 5 or greater.
			 *
			 * @property isIOS5
			 * @type Boolean
			 * @final
			 */
			t.isIOS5 = t.isIDevice && ua.match(/AppleWebKit\/(\d*)/)[1]>=534;

			// TinyMCE .NET webcontrol might be setting the values for TinyMCE
			if (win.tinyMCEPreInit) {
				t.suffix = tinyMCEPreInit.suffix;
				t.baseURL = tinyMCEPreInit.base;
				t.query = tinyMCEPreInit.query;
				return;
			}

			// Get suffix and base
			t.suffix = '';

			// If base element found, add that infront of baseURL
			nl = d.getElementsByTagName('base');
			for (i=0; i<nl.length; i++) {
				if (v = nl[i].href) {
					// Host only value like http://site.com or http://site.com:8008
					if (/^https?:\/\/[^\/]+$/.test(v))
						v += '/';

					base = v ? v.match(/.*\//)[0] : ''; // Get only directory
				}
			}

			function getBase(n) {
				if (n.src && /tiny_mce(|_gzip|_jquery|_prototype|_full)(_dev|_src)?.js/.test(n.src)) {
					if (/_(src|dev)\.js/g.test(n.src))
						t.suffix = '_src';

					if ((p = n.src.indexOf('?')) != -1)
						t.query = n.src.substring(p + 1);

					t.baseURL = n.src.substring(0, n.src.lastIndexOf('/'));

					// If path to script is relative and a base href was found add that one infront
					// the src property will always be an absolute one on non IE browsers and IE 8
					// so this logic will basically only be executed on older IE versions
					if (base && t.baseURL.indexOf('://') == -1 && t.baseURL.indexOf('/') !== 0)
						t.baseURL = base + t.baseURL;

					return t.baseURL;
				}

				return null;
			};

			// Check document
			nl = d.getElementsByTagName('script');
			for (i=0; i<nl.length; i++) {
				if (getBase(nl[i]))
					return;
			}

			// Check head
			n = d.getElementsByTagName('head')[0];
			if (n) {
				nl = n.getElementsByTagName('script');
				for (i=0; i<nl.length; i++) {
					if (getBase(nl[i]))
						return;
				}
			}

			return;
		},

		/**
		 * Checks if a object is of a specific type for example an array.
		 *
		 * @method is
		 * @param {Object} o Object to check type of.
		 * @param {string} t Optional type to check for.
		 * @return {Boolean} true/false if the object is of the specified type.
		 */
		is : function(o, t) {
			if (!t)
				return o !== undefined;

			if (t == 'array' && (o.hasOwnProperty && o instanceof Array))
				return true;

			return typeof(o) == t;
		},

		/**
		 * Makes a name/object map out of an array with names.
		 *
		 * @method makeMap
		 * @param {Array/String} items Items to make map out of.
		 * @param {String} delim Optional delimiter to split string by.
		 * @param {Object} map Optional map to add items to.
		 * @return {Object} Name/value map of items.
		 */
		makeMap : function(items, delim, map) {
			var i;

			items = items || [];
			delim = delim || ',';

			if (typeof(items) == "string")
				items = items.split(delim);

			map = map || {};

			i = items.length;
			while (i--)
				map[items[i]] = {};

			return map;
		},

		/**
		 * Performs an iteration of all items in a collection such as an object or array. This method will execure the
		 * callback function for each item in the collection, if the callback returns false the iteration will terminate.
		 * The callback has the following format: cb(value, key_or_index).
		 *
		 * @method each
		 * @param {Object} o Collection to iterate.
		 * @param {function} cb Callback function to execute for each item.
		 * @param {Object} s Optional scope to execute the callback in.
		 * @example
		 * // Iterate an array
		 * tinymce.each([1,2,3], function(v, i) {
		 *     console.debug("Value: " + v + ", Index: " + i);
		 * });
		 *
		 * // Iterate an object
		 * tinymce.each({a : 1, b : 2, c: 3], function(v, k) {
		 *     console.debug("Value: " + v + ", Key: " + k);
		 * });
		 */
		each : function(o, cb, s) {
			var n, l;

			if (!o)
				return 0;

			s = s || o;

			if (o.length !== undefined) {
				// Indexed arrays, needed for Safari
				for (n=0, l = o.length; n < l; n++) {
					if (cb.call(s, o[n], n, o) === false)
						return 0;
				}
			} else {
				// Hashtables
				for (n in o) {
					if (o.hasOwnProperty(n)) {
						if (cb.call(s, o[n], n, o) === false)
							return 0;
					}
				}
			}

			return 1;
		},

		// #ifndef jquery

		/**
		 * Creates a new array by the return value of each iteration function call. This enables you to convert
		 * one array list into another.
		 *
		 * @method map
		 * @param {Array} a Array of items to iterate.
		 * @param {function} f Function to call for each item. It's return value will be the new value.
		 * @return {Array} Array with new values based on function return values.
		 */
		map : function(a, f) {
			var o = [];

			tinymce.each(a, function(v) {
				o.push(f(v));
			});

			return o;
		},

		/**
		 * Filters out items from the input array by calling the specified function for each item.
		 * If the function returns false the item will be excluded if it returns true it will be included.
		 *
		 * @method grep
		 * @param {Array} a Array of items to loop though.
		 * @param {function} f Function to call for each item. Include/exclude depends on it's return value.
		 * @return {Array} New array with values imported and filtered based in input.
		 * @example
		 * // Filter out some items, this will return an array with 4 and 5
		 * var items = tinymce.grep([1,2,3,4,5], function(v) {return v > 3;});
		 */
		grep : function(a, f) {
			var o = [];

			tinymce.each(a, function(v) {
				if (!f || f(v))
					o.push(v);
			});

			return o;
		},

		/**
		 * Returns the index of a value in an array, this method will return -1 if the item wasn't found.
		 *
		 * @method inArray
		 * @param {Array} a Array/Object to search for value in.
		 * @param {Object} v Value to check for inside the array.
		 * @return {Number/String} Index of item inside the array inside an object. Or -1 if it wasn't found.
		 * @example
		 * // Get index of value in array this will alert 1 since 2 is at that index
		 * alert(tinymce.inArray([1,2,3], 2));
		 */
		inArray : function(a, v) {
			var i, l;

			if (a) {
				for (i = 0, l = a.length; i < l; i++) {
					if (a[i] === v)
						return i;
				}
			}

			return -1;
		},

		/**
		 * Extends an object with the specified other object(s).
		 *
		 * @method extend
		 * @param {Object} o Object to extend with new items.
		 * @param {Object} e..n Object(s) to extend the specified object with.
		 * @return {Object} o New extended object, same reference as the input object.
		 * @example
		 * // Extends obj1 with two new fields
		 * var obj = tinymce.extend(obj1, {
		 *     somefield1 : 'a',
		 *     somefield2 : 'a'
		 * });
		 *
		 * // Extends obj with obj2 and obj3
		 * tinymce.extend(obj, obj2, obj3);
		 */
		extend : function(o, e) {
			var i, l, a = arguments;

			for (i = 1, l = a.length; i < l; i++) {
				e = a[i];

				tinymce.each(e, function(v, n) {
					if (v !== undefined)
						o[n] = v;
				});
			}

			return o;
		},

		// #endif

		/**
		 * Removes whitespace from the beginning and end of a string.
		 *
		 * @method trim
		 * @param {String} s String to remove whitespace from.
		 * @return {String} New string with removed whitespace.
		 */
		trim : function(s) {
			return (s ? '' + s : '').replace(whiteSpaceRe, '');
		},

		/**
		 * Creates a class, subclass or static singleton.
		 * More details on this method can be found in the Wiki.
		 *
		 * @method create
		 * @param {String} s Class name, inheritage and prefix.
		 * @param {Object} p Collection of methods to add to the class.
		 * @param {Object} root Optional root object defaults to the global window object.
		 * @example
		 * // Creates a basic class
		 * tinymce.create('tinymce.somepackage.SomeClass', {
		 *     SomeClass : function() {
		 *         // Class constructor
		 *     },
		 *
		 *     method : function() {
		 *         // Some method
		 *     }
		 * });
		 *
		 * // Creates a basic subclass class
		 * tinymce.create('tinymce.somepackage.SomeSubClass:tinymce.somepackage.SomeClass', {
		 *     SomeSubClass: function() {
		 *         // Class constructor
		 *         this.parent(); // Call parent constructor
		 *     },
		 *
		 *     method : function() {
		 *         // Some method
		 *         this.parent(); // Call parent method
		 *     },
		 *
		 *     'static' : {
		 *         staticMethod : function() {
		 *             // Static method
		 *         }
		 *     }
		 * });
		 *
		 * // Creates a singleton/static class
		 * tinymce.create('static tinymce.somepackage.SomeSingletonClass', {
		 *     method : function() {
		 *         // Some method
		 *     }
		 * });
		 */
		create : function(s, p, root) {
			var t = this, sp, ns, cn, scn, c, de = 0;

			// Parse : <prefix> <class>:<super class>
			s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
			cn = s[3].match(/(^|\.)(\w+)$/i)[2]; // Class name

			// Create namespace for new class
			ns = t.createNS(s[3].replace(/\.\w+$/, ''), root);

			// Class already exists
			if (ns[cn])
				return;

			// Make pure static class
			if (s[2] == 'static') {
				ns[cn] = p;

				if (this.onCreate)
					this.onCreate(s[2], s[3], ns[cn]);

				return;
			}

			// Create default constructor
			if (!p[cn]) {
				p[cn] = function() {};
				de = 1;
			}

			// Add constructor and methods
			ns[cn] = p[cn];
			t.extend(ns[cn].prototype, p);

			// Extend
			if (s[5]) {
				sp = t.resolve(s[5]).prototype;
				scn = s[5].match(/\.(\w+)$/i)[1]; // Class name

				// Extend constructor
				c = ns[cn];
				if (de) {
					// Add passthrough constructor
					ns[cn] = function() {
						return sp[scn].apply(this, arguments);
					};
				} else {
					// Add inherit constructor
					ns[cn] = function() {
						this.parent = sp[scn];
						return c.apply(this, arguments);
					};
				}
				ns[cn].prototype[cn] = ns[cn];

				// Add super methods
				t.each(sp, function(f, n) {
					ns[cn].prototype[n] = sp[n];
				});

				// Add overridden methods
				t.each(p, function(f, n) {
					// Extend methods if needed
					if (sp[n]) {
						ns[cn].prototype[n] = function() {
							this.parent = sp[n];
							return f.apply(this, arguments);
						};
					} else {
						if (n != cn)
							ns[cn].prototype[n] = f;
					}
				});
			}

			// Add static methods
			t.each(p['static'], function(f, n) {
				ns[cn][n] = f;
			});

			if (this.onCreate)
				this.onCreate(s[2], s[3], ns[cn].prototype);
		},

		/**
		 * Executed the specified function for each item in a object tree.
		 *
		 * @method walk
		 * @param {Object} o Object tree to walk though.
		 * @param {function} f Function to call for each item.
		 * @param {String} n Optional name of collection inside the objects to walk for example childNodes.
		 * @param {String} s Optional scope to execute the function in.
		 */
		walk : function(o, f, n, s) {
			s = s || this;

			if (o) {
				if (n)
					o = o[n];

				tinymce.each(o, function(o, i) {
					if (f.call(s, o, i, n) === false)
						return false;

					tinymce.walk(o, f, n, s);
				});
			}
		},

		/**
		 * Creates a namespace on a specific object.
		 *
		 * @method createNS
		 * @param {String} n Namespace to create for example a.b.c.d.
		 * @param {Object} o Optional object to add namespace to, defaults to window.
		 * @return {Object} New namespace object the last item in path.
		 * @example
		 * // Create some namespace
		 * tinymce.createNS('tinymce.somepackage.subpackage');
		 *
		 * // Add a singleton
		 * var tinymce.somepackage.subpackage.SomeSingleton = {
		 *     method : function() {
		 *         // Some method
		 *     }
		 * };
		 */
		createNS : function(n, o) {
			var i, v;

			o = o || win;

			n = n.split('.');
			for (i=0; i<n.length; i++) {
				v = n[i];

				if (!o[v])
					o[v] = {};

				o = o[v];
			}

			return o;
		},

		/**
		 * Resolves a string and returns the object from a specific structure.
		 *
		 * @method resolve
		 * @param {String} n Path to resolve for example a.b.c.d.
		 * @param {Object} o Optional object to search though, defaults to window.
		 * @return {Object} Last object in path or null if it couldn't be resolved.
		 * @example
		 * // Resolve a path into an object reference
		 * var obj = tinymce.resolve('a.b.c.d');
		 */
		resolve : function(n, o) {
			var i, l;

			o = o || win;

			n = n.split('.');
			for (i = 0, l = n.length; i < l; i++) {
				o = o[n[i]];

				if (!o)
					break;
			}

			return o;
		},

		/**
		 * Adds an unload handler to the document. This handler will be executed when the document gets unloaded.
		 * This method is useful for dealing with browser memory leaks where it might be vital to remove DOM references etc.
		 *
		 * @method addUnload
		 * @param {function} f Function to execute before the document gets unloaded.
		 * @param {Object} s Optional scope to execute the function in.
		 * @return {function} Returns the specified unload handler function.
		 * @example
		 * // Fixes a leak with a DOM element that was palces in the someObject
		 * tinymce.addUnload(function() {
		 *     // Null DOM element to reduce IE memory leak
		 *     someObject.someElement = null;
		 * });
		 */
		addUnload : function(f, s) {
			var t = this;

			f = {func : f, scope : s || this};

			if (!t.unloads) {
				function unload() {
					var li = t.unloads, o, n;

					if (li) {
						// Call unload handlers
						for (n in li) {
							o = li[n];

							if (o && o.func)
								o.func.call(o.scope, 1); // Send in one arg to distinct unload and user destroy
						}

						// Detach unload function
						if (win.detachEvent) {
							win.detachEvent('onbeforeunload', fakeUnload);
							win.detachEvent('onunload', unload);
						} else if (win.removeEventListener)
							win.removeEventListener('unload', unload, false);

						// Destroy references
						t.unloads = o = li = w = unload = 0;

						// Run garbarge collector on IE
						if (win.CollectGarbage)
							CollectGarbage();
					}
				};

				function fakeUnload() {
					var d = document;

					// Is there things still loading, then do some magic
					if (d.readyState == 'interactive') {
						function stop() {
							// Prevent memory leak
							d.detachEvent('onstop', stop);

							// Call unload handler
							if (unload)
								unload();

							d = 0;
						};

						// Fire unload when the currently loading page is stopped
						if (d)
							d.attachEvent('onstop', stop);

						// Remove onstop listener after a while to prevent the unload function
						// to execute if the user presses cancel in an onbeforeunload
						// confirm dialog and then presses the browser stop button
						win.setTimeout(function() {
							if (d)
								d.detachEvent('onstop', stop);
						}, 0);
					}
				};

				// Attach unload handler
				if (win.attachEvent) {
					win.attachEvent('onunload', unload);
					win.attachEvent('onbeforeunload', fakeUnload);
				} else if (win.addEventListener)
					win.addEventListener('unload', unload, false);

				// Setup initial unload handler array
				t.unloads = [f];
			} else
				t.unloads.push(f);

			return f;
		},

		/**
		 * Removes the specified function form the unload handler list.
		 *
		 * @method removeUnload
		 * @param {function} f Function to remove from unload handler list.
		 * @return {function} Removed function name or null if it wasn't found.
		 */
		removeUnload : function(f) {
			var u = this.unloads, r = null;

			tinymce.each(u, function(o, i) {
				if (o && o.func == f) {
					u.splice(i, 1);
					r = f;
					return false;
				}
			});

			return r;
		},

		/**
		 * Splits a string but removes the whitespace before and after each value.
		 *
		 * @method explode
		 * @param {string} s String to split.
		 * @param {string} d Delimiter to split by.
		 * @example
		 * // Split a string into an array with a,b,c
		 * var arr = tinymce.explode('a, b,   c');
		 */
		explode : function(s, d) {
			return s ? tinymce.map(s.split(d || ','), tinymce.trim) : s;
		},

		_addVer : function(u) {
			var v;

			if (!this.query)
				return u;

			v = (u.indexOf('?') == -1 ? '?' : '&') + this.query;

			if (u.indexOf('#') == -1)
				return u + v;

			return u.replace('#', v + '#');
		},

		// Fix function for IE 9 where regexps isn't working correctly
		// Todo: remove me once MS fixes the bug
		_replace : function(find, replace, str) {
			// On IE9 we have to fake $x replacement
			if (isRegExpBroken) {
				return str.replace(find, function() {
					var val = replace, args = arguments, i;

					for (i = 0; i < args.length - 2; i++) {
						if (args[i] === undefined) {
							val = val.replace(new RegExp('\\$' + i, 'g'), '');
						} else {
							val = val.replace(new RegExp('\\$' + i, 'g'), args[i]);
						}
					}

					return val;
				});
			}

			return str.replace(find, replace);
		}

		/**#@-*/
	};

	// Initialize the API
	tinymce._init();

	// Expose tinymce namespace to the global namespace (window)
	win.tinymce = win.tinyMCE = tinymce;

	// Describe the different namespaces

	/**
	 * Root level namespace this contains classes directly releated to the TinyMCE editor.
	 *
	 * @namespace tinymce
	 */

	/**
	 * Contains classes for handling the browsers DOM.
	 *
	 * @namespace tinymce.dom
	 */

	/**
	 * Contains html parser and serializer logic.
	 *
	 * @namespace tinymce.html
	 */

	/**
	 * Contains the different UI types such as buttons, listboxes etc.
	 *
	 * @namespace tinymce.ui
	 */

	/**
	 * Contains various utility classes such as json parser, cookies etc.
	 *
	 * @namespace tinymce.util
	 */

	/**
	 * Contains plugin classes.
	 *
	 * @namespace tinymce.plugins
	 */
})(window);
/**
 * adapter.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

// #ifdef jquery_adapter

(function($, tinymce) {
	var is = tinymce.is, attrRegExp = /^(href|src|style)$/i, undefined;

	// jQuery is undefined
	if (!$ && window.console) {
		return console.log("Load jQuery first!");
	}

	// Stick jQuery into the tinymce namespace
	tinymce.$ = $;

	// Setup adapter
	tinymce.adapter = {
		patchEditor : function(editor) {
			var fn = $.fn;

			// Adapt the css function to make sure that the data-mce-style
			// attribute gets updated with the new style information
			function css(name, value) {
				var self = this;

				// Remove data-mce-style when set operation occurs
				if (value)
					self.removeAttr('data-mce-style');

				return fn.css.apply(self, arguments);
			};

			// Apapt the attr function to make sure that it uses the data-mce- prefixed variants
			function attr(name, value) {
				var self = this;

				// Update/retrive data-mce- attribute variants
				if (attrRegExp.test(name)) {
					if (value !== undefined) {
						// Use TinyMCE behavior when setting the specifc attributes
						self.each(function(i, node) {
							editor.dom.setAttrib(node, name, value);
						});

						return self;
					} else
						return self.attr('data-mce-' + name);
				}

				// Default behavior
				return fn.attr.apply(self, arguments);
			};

			function htmlPatchFunc(func) {
				// Returns a modified function that processes
				// the HTML before executing the action this makes sure
				// that href/src etc gets moved into the data-mce- variants
				return function(content) {
					if (content)
						content = editor.dom.processHTML(content);

					return func.call(this, content);
				};
			};

			// Patch various jQuery functions to handle tinymce specific attribute and content behavior
			// we don't patch the jQuery.fn directly since it will most likely break compatibility
			// with other jQuery logic on the page. Only instances created by TinyMCE should be patched.
			function patch(jq) {
				// Patch some functions, only patch the object once
				if (jq.css !== css) {
					// Patch css/attr to use the data-mce- prefixed attribute variants
					jq.css = css;
					jq.attr = attr;

					// Patch HTML functions to use the DOMUtils.processHTML filter logic
					jq.html = htmlPatchFunc(fn.html);
					jq.append = htmlPatchFunc(fn.append);
					jq.prepend = htmlPatchFunc(fn.prepend);
					jq.after = htmlPatchFunc(fn.after);
					jq.before = htmlPatchFunc(fn.before);
					jq.replaceWith = htmlPatchFunc(fn.replaceWith);
					jq.tinymce = editor;

					// Each pushed jQuery instance needs to be patched
					// as well for example when traversing the DOM
					jq.pushStack = function() {
						return patch(fn.pushStack.apply(this, arguments));
					};
				}

				return jq;
			};

			// Add a $ function on each editor instance this one is scoped for the editor document object
			// this way you can do chaining like this tinymce.get(0).$('p').append('text').css('color', 'red');
			editor.$ = function(selector, scope) {
				var doc = editor.getDoc();

				return patch($(selector || doc, doc || scope));
			};
		}
	};

	// Patch in core NS functions
	tinymce.extend = $.extend;
	tinymce.extend(tinymce, {
		map : $.map,
		grep : function(a, f) {return $.grep(a, f || function(){return 1;});},
		inArray : function(a, v) {return $.inArray(v, a || []);}

		/* Didn't iterate stylesheets
		each : function(o, cb, s) {
			if (!o)
				return 0;

			var r = 1;

			$.each(o, function(nr, el){
				if (cb.call(s, el, nr, o) === false) {
					r = 0;
					return false;
				}
			});

			return r;
		}*/
	});

	// Patch in functions in various clases
	// Add a "#ifndefjquery" statement around each core API function you add below
	var patches = {
		'tinymce.dom.DOMUtils' : {
			/*
			addClass : function(e, c) {
				if (is(e, 'array') && is(e[0], 'string'))
					e = e.join(',#');
				return (e && $(is(e, 'string') ? '#' + e : e)
					.addClass(c)
					.attr('class')) || false;
			},

			hasClass : function(n, c) {
				return $(is(n, 'string') ? '#' + n : n).hasClass(c);
			},

			removeClass : function(e, c) {
				if (!e)
					return false;

				var r = [];

				$(is(e, 'string') ? '#' + e : e)
					.removeClass(c)
					.each(function(){
						r.push(this.className);
					});

				return r.length == 1 ? r[0] : r;
			},
			*/

			select : function(pattern, scope) {
				var t = this;

				return $.find(pattern, t.get(scope) || t.get(t.settings.root_element) || t.doc, []);
			},

			is : function(n, patt) {
				return $(this.get(n)).is(patt);
			}

			/*
			show : function(e) {
				if (is(e, 'array') && is(e[0], 'string'))
					e = e.join(',#');

				$(is(e, 'string') ? '#' + e : e).css('display', 'block');
			},

			hide : function(e) {
				if (is(e, 'array') && is(e[0], 'string'))
					e = e.join(',#');

				$(is(e, 'string') ? '#' + e : e).css('display', 'none');
			},

			isHidden : function(e) {
				return $(is(e, 'string') ? '#' + e : e).is(':hidden');
			},

			insertAfter : function(n, e) {
				return $(is(e, 'string') ? '#' + e : e).after(n);
			},

			replace : function(o, n, k) {
				n = $(is(n, 'string') ? '#' + n : n);

				if (k)
					n.children().appendTo(o);

				n.replaceWith(o);
			},

			setStyle : function(n, na, v) {
				if (is(n, 'array') && is(n[0], 'string'))
					n = n.join(',#');

				$(is(n, 'string') ? '#' + n : n).css(na, v);
			},

			getStyle : function(n, na, c) {
				return $(is(n, 'string') ? '#' + n : n).css(na);
			},

			setStyles : function(e, o) {
				if (is(e, 'array') && is(e[0], 'string'))
					e = e.join(',#');
				$(is(e, 'string') ? '#' + e : e).css(o);
			},

			setAttrib : function(e, n, v) {
				var t = this, s = t.settings;

				if (is(e, 'array') && is(e[0], 'string'))
					e = e.join(',#');

				e = $(is(e, 'string') ? '#' + e : e);

				switch (n) {
					case "style":
						e.each(function(i, v){
							if (s.keep_values)
								$(v).attr('data-mce-style', v);

							v.style.cssText = v;
						});
						break;

					case "class":
						e.each(function(){
							this.className = v;
						});
						break;

					case "src":
					case "href":
						e.each(function(i, v){
							if (s.keep_values) {
								if (s.url_converter)
									v = s.url_converter.call(s.url_converter_scope || t, v, n, v);

								t.setAttrib(v, 'data-mce-' + n, v);
							}
						});

						break;
				}

				if (v !== null && v.length !== 0)
					e.attr(n, '' + v);
				else
					e.removeAttr(n);
			},

			setAttribs : function(e, o) {
				var t = this;

				$.each(o, function(n, v){
					t.setAttrib(e,n,v);
				});
			}
			*/
		}

/*
		'tinymce.dom.Event' : {
			add : function (o, n, f, s) {
				var lo, cb;

				cb = function(e) {
					e.target = e.target || this;
					f.call(s || this, e);
				};

				if (is(o, 'array') && is(o[0], 'string'))
					o = o.join(',#');
				o = $(is(o, 'string') ? '#' + o : o);
				if (n == 'init') {
					o.ready(cb, s);
				} else {
					if (s) {
						o.bind(n, s, cb);
					} else {
						o.bind(n, cb);
					}
				}

				lo = this._jqLookup || (this._jqLookup = []);
				lo.push({func : f, cfunc : cb});

				return cb;
			},

			remove : function(o, n, f) {
				// Find cfunc
				$(this._jqLookup).each(function() {
					if (this.func === f)
						f = this.cfunc;
				});

				if (is(o, 'array') && is(o[0], 'string'))
					o = o.join(',#');

				$(is(o, 'string') ? '#' + o : o).unbind(n,f);

				return true;
			}
		}
*/
	};

	// Patch functions after a class is created
	tinymce.onCreate = function(ty, c, p) {
		tinymce.extend(p, patches[c]);
	};
})(window.jQuery, tinymce);

// #endif
/**
 * Dispatcher.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

/**
 * This class is used to dispatch event to observers/listeners.
 * All internal events inside TinyMCE uses this class.
 *
 * @class tinymce.util.Dispatcher
 * @example
 * // Creates a custom event
 * this.onSomething = new tinymce.util.Dispatcher(this);
 *
 * // Dispatch/fire the event
 * this.onSomething.dispatch('some string');
 */
tinymce.create('tinymce.util.Dispatcher', {
	scope : null,
	listeners : null,

	/**
	 * Constructs a new event dispatcher object.
	 *
	 * @constructor
	 * @method Dispatcher
	 * @param {Object} s Optional default execution scope for all observer functions.
	 */
	Dispatcher : function(s) {
		this.scope = s || this;
		this.listeners = [];
	},

	/**
	 * Add an observer function to be executed when a dispatch call is done.
	 *
	 * @method add
	 * @param {function} cb Callback function to execute when a dispatch event occurs.
	 * @param {Object} s Optional execution scope, defaults to the one specified in the class constructor.
	 * @return {function} Returns the same function as the one passed on.
	 */
	add : function(cb, s) {
		this.listeners.push({cb : cb, scope : s || this.scope});

		return cb;
	},

	/**
	 * Add an observer function to be executed to the top of the list of observers.
	 *
	 * @method addToTop
	 * @param {function} cb Callback function to execute when a dispatch event occurs.
	 * @param {Object} s Optional execution scope, defaults to the one specified in the class constructor.
	 * @return {function} Returns the same function as the one passed on.
	 */
	addToTop : function(cb, s) {
		this.listeners.unshift({cb : cb, scope : s || this.scope});

		return cb;
	},

	/**
	 * Removes an observer function.
	 *
	 * @method remove
	 * @param {function} cb Observer function to remove.
	 * @return {function} The same function that got passed in or null if it wasn't found.
	 */
	remove : function(cb) {
		var l = this.listeners, o = null;

		tinymce.each(l, function(c, i) {
			if (cb == c.cb) {
				o = cb;
				l.splice(i, 1);
				return false;
			}
		});

		return o;
	},

	/**
	 * Dispatches an event to all observers/listeners.
	 *
	 * @method dispatch
	 * @param {Object} .. Any number of arguments to dispatch.
	 * @return {Object} Last observer functions return value.
	 */
	dispatch : function() {
		var s, a = arguments, i, li = this.listeners, c;

		// Needs to be a real loop since the listener count might change while looping
		// And this is also more efficient
		for (i = 0; i<li.length; i++) {
			c = li[i];
			s = c.cb.apply(c.scope, a);

			if (s === false)
				break;
		}

		return s;
	}

	/**#@-*/
});
/**
 * URI.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function() {
	var each = tinymce.each;

	/**
	 * This class handles parsing, modification and serialization of URI/URL strings.
	 * @class tinymce.util.URI
	 */
	tinymce.create('tinymce.util.URI', {
		/**
		 * Constucts a new URI instance.
		 *
		 * @constructor
		 * @method URI
		 * @param {String} u URI string to parse.
		 * @param {Object} s Optional settings object.
		 */
		URI : function(u, s) {
			var t = this, o, a, b, base_url;

			// Trim whitespace
			u = tinymce.trim(u);

			// Default settings
			s = t.settings = s || {};

			// Strange app protocol that isn't http/https or local anchor
			// For example: mailto,skype,tel etc.
			if (/^([\w\-]+):([^\/]{2})/i.test(u) || /^\s*#/.test(u)) {
				t.source = u;
				return;
			}

			// Absolute path with no host, fake host and protocol
			if (u.indexOf('/') === 0 && u.indexOf('//') !== 0)
				u = (s.base_uri ? s.base_uri.protocol || 'http' : 'http') + '://mce_host' + u;

			// Relative path http:// or protocol relative //path
			if (!/^[\w-]*:?\/\//.test(u)) {
				base_url = s.base_uri ? s.base_uri.path : new tinymce.util.URI(location.href).directory;
				u = ((s.base_uri && s.base_uri.protocol) || 'http') + '://mce_host' + t.toAbsPath(base_url, u);
			}

			// Parse URL (Credits goes to Steave, http://blog.stevenlevithan.com/archives/parseuri)
			u = u.replace(/@@/g, '(mce_at)'); // Zope 3 workaround, they use @@something
			u = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(u);
			each(["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"], function(v, i) {
				var s = u[i];

				// Zope 3 workaround, they use @@something
				if (s)
					s = s.replace(/\(mce_at\)/g, '@@');

				t[v] = s;
			});

			if (b = s.base_uri) {
				if (!t.protocol)
					t.protocol = b.protocol;

				if (!t.userInfo)
					t.userInfo = b.userInfo;

				if (!t.port && t.host == 'mce_host')
					t.port = b.port;

				if (!t.host || t.host == 'mce_host')
					t.host = b.host;

				t.source = '';
			}

			//t.path = t.path || '/';
		},

		/**
		 * Sets the internal path part of the URI.
		 *
		 * @method setPath
		 * @param {string} p Path string to set.
		 */
		setPath : function(p) {
			var t = this;

			p = /^(.*?)\/?(\w+)?$/.exec(p);

			// Update path parts
			t.path = p[0];
			t.directory = p[1];
			t.file = p[2];

			// Rebuild source
			t.source = '';
			t.getURI();
		},

		/**
		 * Converts the specified URI into a relative URI based on the current URI instance location.
		 *
		 * @method toRelative
		 * @param {String} u URI to convert into a relative path/URI.
		 * @return {String} Relative URI from the point specified in the current URI instance.
		 * @example
		 * // Converts an absolute URL to an relative URL url will be somedir/somefile.htm
		 * var url = new tinymce.util.URI('http://www.site.com/dir/').toRelative('http://www.site.com/dir/somedir/somefile.htm');
		 */
		toRelative : function(u) {
			var t = this, o;

			if (u === "./")
				return u;

			u = new tinymce.util.URI(u, {base_uri : t});

			// Not on same domain/port or protocol
			if ((u.host != 'mce_host' && t.host != u.host && u.host) || t.port != u.port || t.protocol != u.protocol)
				return u.getURI();

			o = t.toRelPath(t.path, u.path);

			// Add query
			if (u.query)
				o += '?' + u.query;

			// Add anchor
			if (u.anchor)
				o += '#' + u.anchor;

			return o;
		},

		/**
		 * Converts the specified URI into a absolute URI based on the current URI instance location.
		 *
		 * @method toAbsolute
		 * @param {String} u URI to convert into a relative path/URI.
		 * @param {Boolean} nh No host and protocol prefix.
		 * @return {String} Absolute URI from the point specified in the current URI instance.
		 * @example
		 * // Converts an relative URL to an absolute URL url will be http://www.site.com/dir/somedir/somefile.htm
		 * var url = new tinymce.util.URI('http://www.site.com/dir/').toAbsolute('somedir/somefile.htm');
		 */
		toAbsolute : function(u, nh) {
			var u = new tinymce.util.URI(u, {base_uri : this});

			return u.getURI(this.host == u.host && this.protocol == u.protocol ? nh : 0);
		},

		/**
		 * Converts a absolute path into a relative path.
		 *
		 * @method toRelPath
		 * @param {String} base Base point to convert the path from.
		 * @param {String} path Absolute path to convert into a relative path.
		 */
		toRelPath : function(base, path) {
			var items, bp = 0, out = '', i, l;

			// Split the paths
			base = base.substring(0, base.lastIndexOf('/'));
			base = base.split('/');
			items = path.split('/');

			if (base.length >= items.length) {
				for (i = 0, l = base.length; i < l; i++) {
					if (i >= items.length || base[i] != items[i]) {
						bp = i + 1;
						break;
					}
				}
			}

			if (base.length < items.length) {
				for (i = 0, l = items.length; i < l; i++) {
					if (i >= base.length || base[i] != items[i]) {
						bp = i + 1;
						break;
					}
				}
			}

			if (bp == 1)
				return path;

			for (i = 0, l = base.length - (bp - 1); i < l; i++)
				out += "../";

			for (i = bp - 1, l = items.length; i < l; i++) {
				if (i != bp - 1)
					out += "/" + items[i];
				else
					out += items[i];
			}

			return out;
		},

		/**
		 * Converts a relative path into a absolute path.
		 *
		 * @method toAbsPath
		 * @param {String} base Base point to convert the path from.
		 * @param {String} path Relative path to convert into an absolute path.
		 */
		toAbsPath : function(base, path) {
			var i, nb = 0, o = [], tr, outPath;

			// Split paths
			tr = /\/$/.test(path) ? '/' : '';
			base = base.split('/');
			path = path.split('/');

			// Remove empty chunks
			each(base, function(k) {
				if (k)
					o.push(k);
			});

			base = o;

			// Merge relURLParts chunks
			for (i = path.length - 1, o = []; i >= 0; i--) {
				// Ignore empty or .
				if (path[i].length == 0 || path[i] == ".")
					continue;

				// Is parent
				if (path[i] == '..') {
					nb++;
					continue;
				}

				// Move up
				if (nb > 0) {
					nb--;
					continue;
				}

				o.push(path[i]);
			}

			i = base.length - nb;

			// If /a/b/c or /
			if (i <= 0)
				outPath = o.reverse().join('/');
			else
				outPath = base.slice(0, i).join('/') + '/' + o.reverse().join('/');

			// Add front / if it's needed
			if (outPath.indexOf('/') !== 0)
				outPath = '/' + outPath;

			// Add traling / if it's needed
			if (tr && outPath.lastIndexOf('/') !== outPath.length - 1)
				outPath += tr;

			return outPath;
		},

		/**
		 * Returns the full URI of the internal structure.
		 *
		 * @method getURI
		 * @param {Boolean} nh Optional no host and protocol part. Defaults to false.
		 */
		getURI : function(nh) {
			var s, t = this;

			// Rebuild source
			if (!t.source || nh) {
				s = '';

				if (!nh) {
					if (t.protocol)
						s += t.protocol + '://';

					if (t.userInfo)
						s += t.userInfo + '@';

					if (t.host)
						s += t.host;

					if (t.port)
						s += ':' + t.port;
				}

				if (t.path)
					s += t.path;

				if (t.query)
					s += '?' + t.query;

				if (t.anchor)
					s += '#' + t.anchor;

				t.source = s;
			}

			return t.source;
		}
	});
})();
/**
 * Cookie.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function() {
	var each = tinymce.each;

	/**
	 * This class contains simple cookie manangement functions.
	 *
	 * @class tinymce.util.Cookie
	 * @static
	 * @example
	 * // Gets a cookie from the browser
	 * console.debug(tinymce.util.Cookie.get('mycookie'));
	 *
	 * // Gets a hash table cookie from the browser and takes out the x parameter from it
	 * console.debug(tinymce.util.Cookie.getHash('mycookie').x);
	 *
	 * // Sets a hash table cookie to the browser
	 * tinymce.util.Cookie.setHash({x : '1', y : '2'});
	 */
	tinymce.create('static tinymce.util.Cookie', {
		/**
		 * Parses the specified query string into an name/value object.
		 *
		 * @method getHash
		 * @param {String} n String to parse into a n Hashtable object.
		 * @return {Object} Name/Value object with items parsed from querystring.
		 */
		getHash : function(n) {
			var v = this.get(n), h;

			if (v) {
				each(v.split('&'), function(v) {
					v = v.split('=');
					h = h || {};
					h[unescape(v[0])] = unescape(v[1]);
				});
			}

			return h;
		},

		/**
		 * Sets a hashtable name/value object to a cookie.
		 *
		 * @method setHash
		 * @param {String} n Name of the cookie.
		 * @param {Object} v Hashtable object to set as cookie.
		 * @param {Date} e Optional date object for the expiration of the cookie.
		 * @param {String} p Optional path to restrict the cookie to.
		 * @param {String} d Optional domain to restrict the cookie to.
		 * @param {String} s Is the cookie secure or not.
		 */
		setHash : function(n, v, e, p, d, s) {
			var o = '';

			each(v, function(v, k) {
				o += (!o ? '' : '&') + escape(k) + '=' + escape(v);
			});

			this.set(n, o, e, p, d, s);
		},

		/**
		 * Gets the raw data of a cookie by name.
		 *
		 * @method get
		 * @param {String} n Name of cookie to retrive.
		 * @return {String} Cookie data string.
		 */
		get : function(n) {
			var c = document.cookie, e, p = n + "=", b;

			// Strict mode
			if (!c)
				return;

			b = c.indexOf("; " + p);

			if (b == -1) {
				b = c.indexOf(p);

				if (b != 0)
					return null;
			} else
				b += 2;

			e = c.indexOf(";", b);

			if (e == -1)
				e = c.length;

			return unescape(c.substring(b + p.length, e));
		},

		/**
		 * Sets a raw cookie string.
		 *
		 * @method set
		 * @param {String} n Name of the cookie.
		 * @param {String} v Raw cookie data.
		 * @param {Date} e Optional date object for the expiration of the cookie.
		 * @param {String} p Optional path to restrict the cookie to.
		 * @param {String} d Optional domain to restrict the cookie to.
		 * @param {String} s Is the cookie secure or not.
		 */
		set : function(n, v, e, p, d, s) {
			document.cookie = n + "=" + escape(v) +
				((e) ? "; expires=" + e.toGMTString() : "") +
				((p) ? "; path=" + escape(p) : "") +
				((d) ? "; domain=" + d : "") +
				((s) ? "; secure" : "");
		},

		/**
		 * Removes/deletes a cookie by name.
		 *
		 * @method remove
		 * @param {String} n Cookie name to remove/delete.
		 * @param {Strong} p Optional path to remove the cookie from.
		 */
		remove : function(n, p) {
			var d = new Date();

			d.setTime(d.getTime() - 1000);

			this.set(n, '', d, p, d);
		}
	});
})();
/**
 * JSON.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function() {
	function serialize(o, quote) {
		var i, v, t;

		quote = quote || '"';

		if (o == null)
			return 'null';

		t = typeof o;

		if (t == 'string') {
			v = '\bb\tt\nn\ff\rr\""\'\'\\\\';

			return quote + o.replace(/([\u0080-\uFFFF\x00-\x1f\"\'\\])/g, function(a, b) {
				// Make sure single quotes never get encoded inside double quotes for JSON compatibility
				if (quote === '"' && a === "'")
					return a;

				i = v.indexOf(b);

				if (i + 1)
					return '\\' + v.charAt(i + 1);

				a = b.charCodeAt().toString(16);

				return '\\u' + '0000'.substring(a.length) + a;
			}) + quote;
		}

		if (t == 'object') {
			if (o.hasOwnProperty && o instanceof Array) {
					for (i=0, v = '['; i<o.length; i++)
						v += (i > 0 ? ',' : '') + serialize(o[i], quote);

					return v + ']';
				}

				v = '{';

				for (i in o)
					v += typeof o[i] != 'function' ? (v.length > 1 ? ',' + quote : quote) + i + quote +':' + serialize(o[i], quote) : '';

				return v + '}';
		}

		return '' + o;
	};

	/**
	 * JSON parser and serializer class.
	 *
	 * @class tinymce.util.JSON
	 * @static
	 * @example
	 * // JSON parse a string into an object
	 * var obj = tinymce.util.JSON.parse(somestring);
	 *
	 * // JSON serialize a object into an string
	 * var str = tinymce.util.JSON.serialize(obj);
	 */
	tinymce.util.JSON = {
		/**
		 * Serializes the specified object as a JSON string.
		 *
		 * @method serialize
		 * @param {Object} obj Object to serialize as a JSON string.
		 * @param {String} quote Optional quote string defaults to ".
		 * @return {string} JSON string serialized from input.
		 */
		serialize: serialize,

		/**
		 * Unserializes/parses the specified JSON string into a object.
		 *
		 * @method parse
		 * @param {string} s JSON String to parse into a JavaScript object.
		 * @return {Object} Object from input JSON string or undefined if it failed.
		 */
		parse: function(s) {
			try {
				return eval('(' + s + ')');
			} catch (ex) {
				// Ignore
			}
		}

		/**#@-*/
	};
})();/**
 * XHR.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

/**
 * This class enables you to send XMLHTTPRequests cross browser.
 * @class tinymce.util.XHR
 * @static
 * @example
 * // Sends a low level Ajax request
 * tinymce.util.XHR.send({
 *    url : 'someurl',
 *    success : function(text) {
 *       console.debug(text);
 *    }
 * });
 */
tinymce.create('static tinymce.util.XHR', {
	/**
	 * Sends a XMLHTTPRequest.
	 * Consult the Wiki for details on what settings this method takes.
	 *
	 * @method send
	 * @param {Object} o Object will target URL, callbacks and other info needed to make the request.
	 */
	send : function(o) {
		var x, t, w = window, c = 0;

		// Default settings
		o.scope = o.scope || this;
		o.success_scope = o.success_scope || o.scope;
		o.error_scope = o.error_scope || o.scope;
		o.async = o.async === false ? false : true;
		o.data = o.data || '';

		function get(s) {
			x = 0;

			try {
				x = new ActiveXObject(s);
			} catch (ex) {
			}

			return x;
		};

		x = w.XMLHttpRequest ? new XMLHttpRequest() : get('Microsoft.XMLHTTP') || get('Msxml2.XMLHTTP');

		if (x) {
			if (x.overrideMimeType)
				x.overrideMimeType(o.content_type);

			x.open(o.type || (o.data ? 'POST' : 'GET'), o.url, o.async);

			if (o.content_type)
				x.setRequestHeader('Content-Type', o.content_type);

			x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');

			x.send(o.data);

			function ready() {
				if (!o.async || x.readyState == 4 || c++ > 10000) {
					if (o.success && c < 10000 && x.status == 200)
						o.success.call(o.success_scope, '' + x.responseText, x, o);
					else if (o.error)
						o.error.call(o.error_scope, c > 10000 ? 'TIMED_OUT' : 'GENERAL', x, o);

					x = null;
				} else
					w.setTimeout(ready, 10);
			};

			// Syncronous request
			if (!o.async)
				return ready();

			// Wait for response, onReadyStateChange can not be used since it leaks memory in IE
			t = w.setTimeout(ready, 10);
		}
	}
});
/**
 * JSONRequest.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function() {
	var extend = tinymce.extend, JSON = tinymce.util.JSON, XHR = tinymce.util.XHR;

	/**
	 * This class enables you to use JSON-RPC to call backend methods.
	 *
	 * @class tinymce.util.JSONRequest
	 * @example
	 * var json = new tinymce.util.JSONRequest({
	 *     url : 'somebackend.php'
	 * });
	 *
	 * // Send RPC call 1
	 * json.send({
	 *     method : 'someMethod1',
	 *     params : ['a', 'b'],
	 *     success : function(result) {
	 *         console.dir(result);
	 *     }
	 * });
	 *
	 * // Send RPC call 2
	 * json.send({
	 *     method : 'someMethod2',
	 *     params : ['a', 'b'],
	 *     success : function(result) {
	 *         console.dir(result);
	 *     }
	 * });
	 */
	tinymce.create('tinymce.util.JSONRequest', {
		/**
		 * Constructs a new JSONRequest instance.
		 *
		 * @constructor
		 * @method JSONRequest
		 * @param {Object} s Optional settings object.
		 */
		JSONRequest : function(s) {
			this.settings = extend({
			}, s);
			this.count = 0;
		},

		/**
		 * Sends a JSON-RPC call. Consult the Wiki API documentation for more details on what you can pass to this function.
		 *
		 * @method send
		 * @param {Object} o Call object where there are three field id, method and params this object should also contain callbacks etc.
		 */
		send : function(o) {
			var ecb = o.error, scb = o.success;

			o = extend(this.settings, o);

			o.success = function(c, x) {
				c = JSON.parse(c);

				if (typeof(c) == 'undefined') {
					c = {
						error : 'JSON Parse error.'
					};
				}

				if (c.error)
					ecb.call(o.error_scope || o.scope, c.error, x);
				else
					scb.call(o.success_scope || o.scope, c.result);
			};

			o.error = function(ty, x) {
				if (ecb)
					ecb.call(o.error_scope || o.scope, ty, x);
			};

			o.data = JSON.serialize({
				id : o.id || 'c' + (this.count++),
				method : o.method,
				params : o.params
			});

			// JSON content type for Ruby on rails. Bug: #1883287
			o.content_type = 'application/json';

			XHR.send(o);
		},

		'static' : {
			/**
			 * Simple helper function to send a JSON-RPC request without the need to initialize an object.
			 * Consult the Wiki API documentation for more details on what you can pass to this function.
			 *
			 * @method sendRPC
			 * @static
			 * @param {Object} o Call object where there are three field id, method and params this object should also contain callbacks etc.
			 */
			sendRPC : function(o) {
				return new tinymce.util.JSONRequest().send(o);
			}
		}
	});
}());/**
 * This file exposes a set of the common KeyCodes for use.  Please grow it as needed.
 */

(function(tinymce){
	tinymce.VK = {
		DELETE:46,
		BACKSPACE:8

	}

})(tinymce);
(function(tinymce) {
	var VK = tinymce.VK, BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE;

	/**
	 * Fixes a WebKit bug when deleting contents using backspace or delete key.
	 * WebKit will produce a span element if you delete across two block elements.
	 *
	 * Example:
	 * <h1>a</h1><p>|b</p>
	 *
	 * Will produce this on backspace:
	 * <h1>a<span class="Apple-style-span" style="<all runtime styles>">b</span></p>
	 *
	 * This fixes the backspace to produce:
	 * <h1>a|b</p>
	 *
	 * See bug: https://bugs.webkit.org/show_bug.cgi?id=45784
	 *
	 * This code is a bit of a hack and hopefully it will be fixed soon in WebKit.
	 */
	function cleanupStylesWhenDeleting(ed) {
		var dom = ed.dom, selection = ed.selection;

		ed.onKeyDown.add(function(ed, e) {
			var rng, blockElm, node, clonedSpan, isDelete;

			isDelete = e.keyCode == DELETE;
			if (isDelete || e.keyCode == BACKSPACE) {
				e.preventDefault();
				rng = selection.getRng();

				// Find root block
				blockElm = dom.getParent(rng.startContainer, dom.isBlock);

				// On delete clone the root span of the next block element
				if (isDelete)
					blockElm = dom.getNext(blockElm, dom.isBlock);

				// Locate root span element and clone it since it would otherwise get merged by the "apple-style-span" on delete/backspace
				if (blockElm) {
					node = blockElm.firstChild;

					// Ignore empty text nodes
					while (node.nodeType == 3 && node.nodeValue.length == 0)
						node = node.nextSibling;

					if (node && node.nodeName === 'SPAN') {
						clonedSpan = node.cloneNode(false);
					}
				}

				// Do the backspace/delete actiopn
				ed.getDoc().execCommand(isDelete ? 'ForwardDelete' : 'Delete', false, null);

				// Find all odd apple-style-spans
				blockElm = dom.getParent(rng.startContainer, dom.isBlock);
				tinymce.each(dom.select('span.Apple-style-span,font.Apple-style-span', blockElm), function(span) {
					var bm = selection.getBookmark();

					if (clonedSpan) {
						dom.replace(clonedSpan.cloneNode(false), span, true);
					} else {
						dom.remove(span, true);
					}

					// Restore the selection
					selection.moveToBookmark(bm);
				});
			}
		});
	};

	/**
	 * WebKit and IE doesn't empty the editor if you select all contents and hit backspace or delete. This fix will check if the body is empty
	 * like a <h1></h1> or <p></p> and then forcefully remove all contents.
	 */
	function emptyEditorWhenDeleting(ed) {
		ed.onKeyUp.add(function(ed, e) {
			var keyCode = e.keyCode;

			if (keyCode == DELETE || keyCode == BACKSPACE) {
				if (ed.dom.isEmpty(ed.getBody())) {
					ed.setContent('', {format : 'raw'});
					ed.nodeChanged();
					return;
				}
			}
		});
	};

	/**
	 * WebKit on MacOS X has a weird issue where it some times fails to properly convert keypresses to input method keystrokes.
	 * So a fix where we just get the range and set the range back seems to do the trick.
	 */
	function inputMethodFocus(ed) {
		ed.dom.bind(ed.getDoc(), 'focusin', function() {
			ed.selection.setRng(ed.selection.getRng());
		});
	};

	/**
	 * Firefox 3.x has an issue where the body element won't get proper focus if you click out
	 * side it's rectangle.
	 */
	function focusBody(ed) {
		// Fix for a focus bug in FF 3.x where the body element
		// wouldn't get proper focus if the user clicked on the HTML element
		if (!Range.prototype.getClientRects) { // Detect getClientRects got introduced in FF 4
			ed.onMouseDown.add(function(ed, e) {
				if (e.target.nodeName === "HTML") {
					var body = ed.getBody();

					// Blur the body it's focused but not correctly focused
					body.blur();

					// Refocus the body after a little while
					setTimeout(function() {
						body.focus();
					}, 0);
				}
			});
		}
	};

	/**
	 * WebKit has a bug where it isn't possible to select image, hr or anchor elements
	 * by clicking on them so we need to fake that.
	 */
	function selectControlElements(ed) {
		ed.onClick.add(function(ed, e) {
			e = e.target;

			// Workaround for bug, http://bugs.webkit.org/show_bug.cgi?id=12250
			// WebKit can't even do simple things like selecting an image
			// Needs tobe the setBaseAndExtend or it will fail to select floated images
			if (/^(IMG|HR)$/.test(e.nodeName))
				ed.selection.getSel().setBaseAndExtent(e, 0, e, 1);

			if (e.nodeName == 'A' && ed.dom.hasClass(e, 'mceItemAnchor'))
				ed.selection.select(e);

			ed.nodeChanged();
		});
	};

	tinymce.create('tinymce.util.Quirks', {
		Quirks: function(ed) {
			// WebKit
			if (tinymce.isWebKit) {
				// https://bugs.webkit.org/show_bug.cgi?id=45784
				// fixed in 528+
				if (window.jQuery && parseInt(jQuery.browser.version) < 528) {
					cleanupStylesWhenDeleting(ed);
				}
				emptyEditorWhenDeleting(ed);
				inputMethodFocus(ed);
				selectControlElements(ed);
			}

			// IE
			if (tinymce.isIE) {
				emptyEditorWhenDeleting(ed);
			}

			// Gecko
			if (tinymce.isGecko) {
				focusBody(ed);
			}
		}
	});
})(tinymce);/**
 * Entities.js
 *
 * Copyright 2010, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var namedEntities, baseEntities, reverseEntities,
		attrsCharsRegExp = /[&<>\"\u007E-\uD7FF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
		textCharsRegExp = /[<>&\u007E-\uD7FF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
		rawCharsRegExp = /[<>&\"\']/g,
		entityRegExp = /&(#x|#)?([\w]+);/g,
		asciiMap = {
				128 : "\u20AC", 130 : "\u201A", 131 : "\u0192", 132 : "\u201E", 133 : "\u2026", 134 : "\u2020",
				135 : "\u2021", 136 : "\u02C6", 137 : "\u2030", 138 : "\u0160", 139 : "\u2039", 140 : "\u0152",
				142 : "\u017D", 145 : "\u2018", 146 : "\u2019", 147 : "\u201C", 148 : "\u201D", 149 : "\u2022",
				150 : "\u2013", 151 : "\u2014", 152 : "\u02DC", 153 : "\u2122", 154 : "\u0161", 155 : "\u203A",
				156 : "\u0153", 158 : "\u017E", 159 : "\u0178"
		};

	// Raw entities
	baseEntities = {
		'\"' : '&quot;', // Needs to be escaped since the YUI compressor would otherwise break the code
		"'" : '&#39;',
		'<' : '&lt;',
		'>' : '&gt;',
		'&' : '&amp;'
	};

	// Reverse lookup table for raw entities
	reverseEntities = {
		'&lt;' : '<',
		'&gt;' : '>',
		'&amp;' : '&',
		'&quot;' : '"',
		'&apos;' : "'"
	};

	// Decodes text by using the browser
	function nativeDecode(text) {
		var elm;

		elm = document.createElement("div");
		elm.innerHTML = text;

		return elm.textContent || elm.innerText || text;
	};

	// Build a two way lookup table for the entities
	function buildEntitiesLookup(items, radix) {
		var i, chr, entity, lookup = {};

		if (items) {
			items = items.split(',');
			radix = radix || 10;

			// Build entities lookup table
			for (i = 0; i < items.length; i += 2) {
				chr = String.fromCharCode(parseInt(items[i], radix));

				// Only add non base entities
				if (!baseEntities[chr]) {
					entity = '&' + items[i + 1] + ';';
					lookup[chr] = entity;
					lookup[entity] = chr;
				}
			}

			return lookup;
		}
	};

	// Unpack entities lookup where the numbers are in radix 32 to reduce the size
	namedEntities = buildEntitiesLookup(
		'50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +
		'5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +
		'5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +
		'5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +
		'68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +
		'6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +
		'6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +
		'75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +
		'7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +
		'7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +
		'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +
		'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +
		't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +
		'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +
		'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +
		'81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +
		'8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +
		'8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +
		'8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +
		'8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +
		'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +
		'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +
		'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +
		'80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +
		'811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro'
	, 32);

	tinymce.html = tinymce.html || {};

	/**
	 * Entity encoder class.
	 *
	 * @class tinymce.html.SaxParser
	 * @static
	 * @version 3.4
	 */
	tinymce.html.Entities = {
		/**
		 * Encodes the specified string using raw entities. This means only the required XML base entities will be endoded.
		 *
		 * @method encodeRaw
		 * @param {String} text Text to encode.
		 * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
		 * @return {String} Entity encoded text.
		 */
		encodeRaw : function(text, attr) {
			return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
				return baseEntities[chr] || chr;
			});
		},

		/**
		 * Encoded the specified text with both the attributes and text entities. This function will produce larger text contents
		 * since it doesn't know if the context is within a attribute or text node. This was added for compatibility
		 * and is exposed as the DOMUtils.encode function.
		 *
		 * @method encodeAllRaw
		 * @param {String} text Text to encode.
		 * @return {String} Entity encoded text.
		 */
		encodeAllRaw : function(text) {
			return ('' + text).replace(rawCharsRegExp, function(chr) {
				return baseEntities[chr] || chr;
			});
		},

		/**
		 * Encodes the specified string using numeric entities. The core entities will be encoded as named ones but all non lower ascii characters
		 * will be encoded into numeric entities.
		 *
		 * @method encodeNumeric
		 * @param {String} text Text to encode.
		 * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
		 * @return {String} Entity encoded text.
		 */
		encodeNumeric : function(text, attr) {
			return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
				// Multi byte sequence convert it to a single entity
				if (chr.length > 1)
					return '&#' + (((chr.charCodeAt(0) - 0xD800) * 0x400) + (chr.charCodeAt(1) - 0xDC00) + 0x10000) + ';';

				return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
			});
		},

		/**
		 * Encodes the specified string using named entities. The core entities will be encoded as named ones but all non lower ascii characters
		 * will be encoded into named entities.
		 *
		 * @method encodeNamed
		 * @param {String} text Text to encode.
		 * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
		 * @param {Object} entities Optional parameter with entities to use.
		 * @return {String} Entity encoded text.
		 */
		encodeNamed : function(text, attr, entities) {
			entities = entities || namedEntities;

			return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
				return baseEntities[chr] || entities[chr] || chr;
			});
		},

		/**
		 * Returns an encode function based on the name(s) and it's optional entities.
		 *
		 * @method getEncodeFunc
		 * @param {String} name Comma separated list of encoders for example named,numeric.
		 * @param {String} entities Optional parameter with entities to use instead of the built in set.
		 * @return {function} Encode function to be used.
		 */
		getEncodeFunc : function(name, entities) {
			var Entities = tinymce.html.Entities;

			entities = buildEntitiesLookup(entities) || namedEntities;

			function encodeNamedAndNumeric(text, attr) {
				return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
					return baseEntities[chr] || entities[chr] || '&#' + chr.charCodeAt(0) + ';' || chr;
				});
			};

			function encodeCustomNamed(text, attr) {
				return Entities.encodeNamed(text, attr, entities);
			};

			// Replace + with , to be compatible with previous TinyMCE versions
			name = tinymce.makeMap(name.replace(/\+/g, ','));

			// Named and numeric encoder
			if (name.named && name.numeric)
				return encodeNamedAndNumeric;

			// Named encoder
			if (name.named) {
				// Custom names
				if (entities)
					return encodeCustomNamed;

				return Entities.encodeNamed;
			}

			// Numeric
			if (name.numeric)
				return Entities.encodeNumeric;

			// Raw encoder
			return Entities.encodeRaw;
		},

		/**
		 * Decodes the specified string, this will replace entities with raw UTF characters.
		 *
		 * @param {String} text Text to entity decode.
		 * @return {String} Entity decoded string.
		 */
		decode : function(text) {
			return text.replace(entityRegExp, function(all, numeric, value) {
				if (numeric) {
					value = parseInt(value, numeric.length === 2 ? 16 : 10);

					// Support upper UTF
					if (value > 0xFFFF) {
						value -= 0x10000;

						return String.fromCharCode(0xD800 + (value >> 10), 0xDC00 + (value & 0x3FF));
					} else
						return asciiMap[value] || String.fromCharCode(value);
				}

				return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
			});
		}
	};
})(tinymce);
/**
 * Styles.js
 *
 * Copyright 2010, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

/**
 * This class is used to parse CSS styles it also compresses styles to reduce the output size.
 *
 * @example
 * var Styles = new tinymce.html.Styles({
 *    url_converter: function(url) {
 *       return url;
 *    }
 * });
 *
 * styles = Styles.parse('border: 1px solid red');
 * styles.color = 'red';
 *
 * console.log(new tinymce.html.StyleSerializer().serialize(styles));
 *
 * @class tinymce.html.Styles
 * @version 3.4
 */
tinymce.html.Styles = function(settings, schema) {
	var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi,
		urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi,
		styleRegExp = /\s*([^:]+):\s*([^;]+);?/g,
		trimRightRegExp = /\s+$/,
		urlColorRegExp = /rgb/,
		undef, i, encodingLookup = {}, encodingItems;

	settings = settings || {};

	encodingItems = '\\" \\\' \\; \\: ; : \uFEFF'.split(' ');
	for (i = 0; i < encodingItems.length; i++) {
		encodingLookup[encodingItems[i]] = '\uFEFF' + i;
		encodingLookup['\uFEFF' + i] = encodingItems[i];
	}

	function toHex(match, r, g, b) {
		function hex(val) {
			val = parseInt(val).toString(16);

			return val.length > 1 ? val : '0' + val; // 0 -> 00
		};

		return '#' + hex(r) + hex(g) + hex(b);
	};

	return {
		/**
		 * Parses the specified RGB color value and returns a hex version of that color.
		 *
		 * @method toHex
		 * @param {String} color RGB string value like rgb(1,2,3)
		 * @return {String} Hex version of that RGB value like #FF00FF.
		 */
		toHex : function(color) {
			return color.replace(rgbRegExp, toHex);
		},

		/**
		 * Parses the specified style value into an object collection. This parser will also
		 * merge and remove any redundant items that browsers might have added. It will also convert non hex
		 * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
		 *
		 * @method parse
		 * @param {String} css Style value to parse for example: border:1px solid red;.
		 * @return {Object} Object representation of that style like {border : '1px solid red'}
		 */
		parse : function(css) {
			var styles = {}, matches, name, value, isEncoded, urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope || this;

			function compress(prefix, suffix) {
				var top, right, bottom, left;

				// Get values and check it it needs compressing
				top = styles[prefix + '-top' + suffix];
				if (!top)
					return;

				right = styles[prefix + '-right' + suffix];
				if (top != right)
					return;

				bottom = styles[prefix + '-bottom' + suffix];
				if (right != bottom)
					return;

				left = styles[prefix + '-left' + suffix];
				if (bottom != left)
					return;

				// Compress
				styles[prefix + suffix] = left;
				delete styles[prefix + '-top' + suffix];
				delete styles[prefix + '-right' + suffix];
				delete styles[prefix + '-bottom' + suffix];
				delete styles[prefix + '-left' + suffix];
			};

			/**
			 * Checks if the specific style can be compressed in other words if all border-width are equal.
			 */
			function canCompress(key) {
				var value = styles[key], i;

				if (!value || value.indexOf(' ') < 0)
					return;

				value = value.split(' ');
				i = value.length;
				while (i--) {
					if (value[i] !== value[0])
						return false;
				}

				styles[key] = value[0];

				return true;
			};

			/**
			 * Compresses multiple styles into one style.
			 */
			function compress2(target, a, b, c) {
				if (!canCompress(a))
					return;

				if (!canCompress(b))
					return;

				if (!canCompress(c))
					return;

				// Compress
				styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];
				delete styles[a];
				delete styles[b];
				delete styles[c];
			};

			// Encodes the specified string by replacing all \" \' ; : with _<num>
			function encode(str) {
				isEncoded = true;

				return encodingLookup[str];
			};

			// Decodes the specified string by replacing all _<num> with it's original value \" \' etc
			// It will also decode the \" \' if keep_slashes is set to fale or omitted
			function decode(str, keep_slashes) {
				if (isEncoded) {
					str = str.replace(/\uFEFF[0-9]/g, function(str) {
						return encodingLookup[str];
					});
				}

				if (!keep_slashes)
					str = str.replace(/\\([\'\";:])/g, "$1");

				return str;
			}

			if (css) {
				// Encode \" \' % and ; and : inside strings so they don't interfere with the style parsing
				css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, function(str) {
					return str.replace(/[;:]/g, encode);
				});

				// Parse styles
				while (matches = styleRegExp.exec(css)) {
					name = matches[1].replace(trimRightRegExp, '').toLowerCase();
					value = matches[2].replace(trimRightRegExp, '');

					if (name && value.length > 0) {
						// Opera will produce 700 instead of bold in their style values
						if (name === 'font-weight' && value === '700')
							value = 'bold';
						else if (name === 'color' || name === 'background-color') // Lowercase colors like RED
							value = value.toLowerCase();

						// Convert RGB colors to HEX
						value = value.replace(rgbRegExp, toHex);

						// Convert URLs and force them into url('value') format
						value = value.replace(urlOrStrRegExp, function(match, url, url2, url3, str, str2) {
							str = str || str2;

							if (str) {
								str = decode(str);

								// Force strings into single quote format
								return "'" + str.replace(/\'/g, "\\'") + "'";
							}

							url = decode(url || url2 || url3);

							// Convert the URL to relative/absolute depending on config
							if (urlConverter)
								url = urlConverter.call(urlConverterScope, url, 'style');

							// Output new URL format
							return "url('" + url.replace(/\'/g, "\\'") + "')";
						});

						styles[name] = isEncoded ? decode(value, true) : value;
					}

					styleRegExp.lastIndex = matches.index + matches[0].length;
				}

				// Compress the styles to reduce it's size for example IE will expand styles
				compress("border", "");
				compress("border", "-width");
				compress("border", "-color");
				compress("border", "-style");
				compress("padding", "");
				compress("margin", "");
				compress2('border', 'border-width', 'border-style', 'border-color');

				// Remove pointless border, IE produces these
				if (styles.border === 'medium none')
					delete styles.border;
			}

			return styles;
		},

		/**
		 * Serializes the specified style object into a string.
		 *
		 * @method serialize
		 * @param {Object} styles Object to serialize as string for example: {border : '1px solid red'}
		 * @param {String} element_name Optional element name, if specified only the styles that matches the schema will be serialized.
		 * @return {String} String representation of the style object for example: border: 1px solid red.
		 */
		serialize : function(styles, element_name) {
			var css = '', name, value;

			function serializeStyles(name) {
				var styleList, i, l, value;

				styleList = schema.styles[name];
				if (styleList) {
					for (i = 0, l = styleList.length; i < l; i++) {
						name = styleList[i];
						value = styles[name];

						if (value !== undef && value.length > 0)
							css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
					}
				}
			};

			// Serialize styles according to schema
			if (element_name && schema && schema.styles) {
				// Serialize global styles and element specific styles
				serializeStyles('*');
				serializeStyles(element_name);
			} else {
				// Output the styles in the order they are inside the object
				for (name in styles) {
					value = styles[name];

					if (value !== undef && value.length > 0)
						css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
				}
			}

			return css;
		}
	};
};
/**
 * Schema.js
 *
 * Copyright 2010, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var transitional = {}, boolAttrMap, blockElementsMap, shortEndedElementsMap, nonEmptyElementsMap, customElementsMap = {},
		defaultWhiteSpaceElementsMap, selfClosingElementsMap, makeMap = tinymce.makeMap, each = tinymce.each;

	function split(str, delim) {
		return str.split(delim || ',');
	};

	/**
	 * Unpacks the specified lookup and string data it will also parse it into an object
	 * map with sub object for it's children. This will later also include the attributes.
	 */
	function unpack(lookup, data) {
		var key, elements = {};

		function replace(value) {
			return value.replace(/[A-Z]+/g, function(key) {
				return replace(lookup[key]);
			});
		};

		// Unpack lookup
		for (key in lookup) {
			if (lookup.hasOwnProperty(key))
				lookup[key] = replace(lookup[key]);
		}

		// Unpack and parse data into object map
		replace(data).replace(/#/g, '#text').replace(/(\w+)\[([^\]]+)\]\[([^\]]*)\]/g, function(str, name, attributes, children) {
			attributes = split(attributes, '|');

			elements[name] = {
				attributes : makeMap(attributes),
				attributesOrder : attributes,
				children : makeMap(children, '|', {'#comment' : {}})
			}
		});

		return elements;
	};

	// Build a lookup table for block elements both lowercase and uppercase
	blockElementsMap = 'h1,h2,h3,h4,h5,h6,hr,p,div,address,pre,form,table,tbody,thead,tfoot,' +
						'th,tr,td,li,ol,ul,caption,blockquote,center,dl,dt,dd,dir,fieldset,' +
						'noscript,menu,isindex,samp,header,footer,article,section,hgroup';
	blockElementsMap = makeMap(blockElementsMap, ',', makeMap(blockElementsMap.toUpperCase()));

	// This is the XHTML 1.0 transitional elements with it's attributes and children packed to reduce it's size
	transitional = unpack({
		Z : 'H|K|N|O|P',
		Y : 'X|form|R|Q',
		ZG : 'E|span|width|align|char|charoff|valign',
		X : 'p|T|div|U|W|isindex|fieldset|table',
		ZF : 'E|align|char|charoff|valign',
		W : 'pre|hr|blockquote|address|center|noframes',
		ZE : 'abbr|axis|headers|scope|rowspan|colspan|align|char|charoff|valign|nowrap|bgcolor|width|height',
		ZD : '[E][S]',
		U : 'ul|ol|dl|menu|dir',
		ZC : 'p|Y|div|U|W|table|br|span|bdo|object|applet|img|map|K|N|Q',
		T : 'h1|h2|h3|h4|h5|h6',
		ZB : 'X|S|Q',
		S : 'R|P',
		ZA : 'a|G|J|M|O|P',
		R : 'a|H|K|N|O',
		Q : 'noscript|P',
		P : 'ins|del|script',
		O : 'input|select|textarea|label|button',
		N : 'M|L',
		M : 'em|strong|dfn|code|q|samp|kbd|var|cite|abbr|acronym',
		L : 'sub|sup',
		K : 'J|I',
		J : 'tt|i|b|u|s|strike',
		I : 'big|small|font|basefont',
		H : 'G|F',
		G : 'br|span|bdo',
		F : 'object|applet|img|map|iframe',
		E : 'A|B|C',
		D : 'accesskey|tabindex|onfocus|onblur',
		C : 'onclick|ondblclick|onmousedown|onmouseup|onmouseover|onmousemove|onmouseout|onkeypress|onkeydown|onkeyup',
		B : 'lang|xml:lang|dir',
		A : 'id|class|style|title'
	}, 'script[id|charset|type|language|src|defer|xml:space][]' +
		'style[B|id|type|media|title|xml:space][]' +
		'object[E|declare|classid|codebase|data|type|codetype|archive|standby|width|height|usemap|name|tabindex|align|border|hspace|vspace][#|param|Y]' +
		'param[id|name|value|valuetype|type][]' +
		'p[E|align][#|S]' +
		'a[E|D|charset|type|name|href|hreflang|rel|rev|shape|coords|target][#|Z]' +
		'br[A|clear][]' +
		'span[E][#|S]' +
		'bdo[A|C|B][#|S]' +
		'applet[A|codebase|archive|code|object|alt|name|width|height|align|hspace|vspace][#|param|Y]' +
		'h1[E|align][#|S]' +
		'img[E|src|alt|name|longdesc|width|height|usemap|ismap|align|border|hspace|vspace][]' +
		'map[B|C|A|name][X|form|Q|area]' +
		'h2[E|align][#|S]' +
		'iframe[A|longdesc|name|src|frameborder|marginwidth|marginheight|scrolling|align|width|height][#|Y]' +
		'h3[E|align][#|S]' +
		'tt[E][#|S]' +
		'i[E][#|S]' +
		'b[E][#|S]' +
		'u[E][#|S]' +
		's[E][#|S]' +
		'strike[E][#|S]' +
		'big[E][#|S]' +
		'small[E][#|S]' +
		'font[A|B|size|color|face][#|S]' +
		'basefont[id|size|color|face][]' +
		'em[E][#|S]' +
		'strong[E][#|S]' +
		'dfn[E][#|S]' +
		'code[E][#|S]' +
		'q[E|cite][#|S]' +
		'samp[E][#|S]' +
		'kbd[E][#|S]' +
		'var[E][#|S]' +
		'cite[E][#|S]' +
		'abbr[E][#|S]' +
		'acronym[E][#|S]' +
		'sub[E][#|S]' +
		'sup[E][#|S]' +
		'input[E|D|type|name|value|checked|disabled|readonly|size|maxlength|src|alt|usemap|onselect|onchange|accept|align][]' +
		'select[E|name|size|multiple|disabled|tabindex|onfocus|onblur|onchange][optgroup|option]' +
		'optgroup[E|disabled|label][option]' +
		'option[E|selected|disabled|label|value][]' +
		'textarea[E|D|name|rows|cols|disabled|readonly|onselect|onchange][]' +
		'label[E|for|accesskey|onfocus|onblur][#|S]' +
		'button[E|D|name|value|type|disabled][#|p|T|div|U|W|table|G|object|applet|img|map|K|N|Q]' +
		'h4[E|align][#|S]' +
		'ins[E|cite|datetime][#|Y]' +
		'h5[E|align][#|S]' +
		'del[E|cite|datetime][#|Y]' +
		'h6[E|align][#|S]' +
		'div[E|align][#|Y]' +
		'ul[E|type|compact][li]' +
		'li[E|type|value][#|Y]' +
		'ol[E|type|compact|start][li]' +
		'dl[E|compact][dt|dd]' +
		'dt[E][#|S]' +
		'dd[E][#|Y]' +
		'menu[E|compact][li]' +
		'dir[E|compact][li]' +
		'pre[E|width|xml:space][#|ZA]' +
		'hr[E|align|noshade|size|width][]' +
		'blockquote[E|cite][#|Y]' +
		'address[E][#|S|p]' +
		'center[E][#|Y]' +
		'noframes[E][#|Y]' +
		'isindex[A|B|prompt][]' +
		'fieldset[E][#|legend|Y]' +
		'legend[E|accesskey|align][#|S]' +
		'table[E|summary|width|border|frame|rules|cellspacing|cellpadding|align|bgcolor][caption|col|colgroup|thead|tfoot|tbody|tr]' +
		'caption[E|align][#|S]' +
		'col[ZG][]' +
		'colgroup[ZG][col]' +
		'thead[ZF][tr]' +
		'tr[ZF|bgcolor][th|td]' +
		'th[E|ZE][#|Y]' +
		'form[E|action|method|name|enctype|onsubmit|onreset|accept|accept-charset|target][#|X|R|Q]' +
		'noscript[E][#|Y]' +
		'td[E|ZE][#|Y]' +
		'tfoot[ZF][tr]' +
		'tbody[ZF][tr]' +
		'area[E|D|shape|coords|href|nohref|alt|target][]' +
		'base[id|href|target][]' +
		'body[E|onload|onunload|background|bgcolor|text|link|vlink|alink][#|Y]'
	);

	boolAttrMap = makeMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected,autoplay,loop,controls');
	shortEndedElementsMap = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,source');
	nonEmptyElementsMap = tinymce.extend(makeMap('td,th,iframe,video,audio,object'), shortEndedElementsMap);
	defaultWhiteSpaceElementsMap = makeMap('pre,script,style,textarea');
	selfClosingElementsMap = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');

	/**
	 * Schema validator class.
	 *
	 * @class tinymce.html.Schema
	 * @example
	 *  if (tinymce.activeEditor.schema.isValidChild('p', 'span'))
	 *    alert('span is valid child of p.');
	 *
	 *  if (tinymce.activeEditor.schema.getElementRule('p'))
	 *    alert('P is a valid element.');
	 *
	 * @class tinymce.html.Schema
	 * @version 3.4
	 */

	/**
	 * Constructs a new Schema instance.
	 *
	 * @constructor
	 * @method Schema
	 * @param {Object} settings Name/value settings object.
	 */
	tinymce.html.Schema = function(settings) {
		var self = this, elements = {}, children = {}, patternElements = [], validStyles, whiteSpaceElementsMap;

		settings = settings || {};

		// Allow all elements and attributes if verify_html is set to false
		if (settings.verify_html === false)
			settings.valid_elements = '*[*]';

		// Build styles list
		if (settings.valid_styles) {
			validStyles = {};

			// Convert styles into a rule list
			each(settings.valid_styles, function(value, key) {
				validStyles[key] = tinymce.explode(value);
			});
		}

		whiteSpaceElementsMap = settings.whitespace_elements ? makeMap(settings.whitespace_elements) : defaultWhiteSpaceElementsMap;

		// Converts a wildcard expression string to a regexp for example *a will become /.*a/.
		function patternToRegExp(str) {
			return new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');
		};

		// Parses the specified valid_elements string and adds to the current rules
		// This function is a bit hard to read since it's heavily optimized for speed
		function addValidElements(valid_elements) {
			var ei, el, ai, al, yl, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder,
				prefix, outputName, globalAttributes, globalAttributesOrder, transElement, key, childKey, value,
				elementRuleRegExp = /^([#+-])?([^\[\/]+)(?:\/([^\[]+))?(?:\[([^\]]+)\])?$/,
				attrRuleRegExp = /^([!\-])?(\w+::\w+|[^=:<]+)?(?:([=:<])(.*))?$/,
				hasPatternsRegExp = /[*?+]/;

			if (valid_elements) {
				// Split valid elements into an array with rules
				valid_elements = split(valid_elements);

				if (elements['@']) {
					globalAttributes = elements['@'].attributes;
					globalAttributesOrder = elements['@'].attributesOrder;
				}

				// Loop all rules
				for (ei = 0, el = valid_elements.length; ei < el; ei++) {
					// Parse element rule
					matches = elementRuleRegExp.exec(valid_elements[ei]);
					if (matches) {
						// Setup local names for matches
						prefix = matches[1];
						elementName = matches[2];
						outputName = matches[3];
						attrData = matches[4];

						// Create new attributes and attributesOrder
						attributes = {};
						attributesOrder = [];

						// Create the new element
						element = {
							attributes : attributes,
							attributesOrder : attributesOrder
						};

						// Padd empty elements prefix
						if (prefix === '#')
							element.paddEmpty = true;

						// Remove empty elements prefix
						if (prefix === '-')
							element.removeEmpty = true;

						// Copy attributes from global rule into current rule
						if (globalAttributes) {
							for (key in globalAttributes)
								attributes[key] = globalAttributes[key];

							attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
						}

						// Attributes defined
						if (attrData) {
							attrData = split(attrData, '|');
							for (ai = 0, al = attrData.length; ai < al; ai++) {
								matches = attrRuleRegExp.exec(attrData[ai]);
								if (matches) {
									attr = {};
									attrType = matches[1];
									attrName = matches[2].replace(/::/g, ':');
									prefix = matches[3];
									value = matches[4];

									// Required
									if (attrType === '!') {
										element.attributesRequired = element.attributesRequired || [];
										element.attributesRequired.push(attrName);
										attr.required = true;
									}

									// Denied from global
									if (attrType === '-') {
										delete attributes[attrName];
										attributesOrder.splice(tinymce.inArray(attributesOrder, attrName), 1);
										continue;
									}

									// Default value
									if (prefix) {
										// Default value
										if (prefix === '=') {
											element.attributesDefault = element.attributesDefault || [];
											element.attributesDefault.push({name: attrName, value: value});
											attr.defaultValue = value;
										}

										// Forced value
										if (prefix === ':') {
											element.attributesForced = element.attributesForced || [];
											element.attributesForced.push({name: attrName, value: value});
											attr.forcedValue = value;
										}

										// Required values
										if (prefix === '<')
											attr.validValues = makeMap(value, '?');
									}

									// Check for attribute patterns
									if (hasPatternsRegExp.test(attrName)) {
										element.attributePatterns = element.attributePatterns || [];
										attr.pattern = patternToRegExp(attrName);
										element.attributePatterns.push(attr);
									} else {
										// Add attribute to order list if it doesn't already exist
										if (!attributes[attrName])
											attributesOrder.push(attrName);

										attributes[attrName] = attr;
									}
								}
							}
						}

						// Global rule, store away these for later usage
						if (!globalAttributes && elementName == '@') {
							globalAttributes = attributes;
							globalAttributesOrder = attributesOrder;
						}

						// Handle substitute elements such as b/strong
						if (outputName) {
							element.outputName = elementName;
							elements[outputName] = element;
						}

						// Add pattern or exact element
						if (hasPatternsRegExp.test(elementName)) {
							element.pattern = patternToRegExp(elementName);
							patternElements.push(element);
						} else
							elements[elementName] = element;
					}
				}
			}
		};

		function setValidElements(valid_elements) {
			elements = {};
			patternElements = [];

			addValidElements(valid_elements);

			each(transitional, function(element, name) {
				children[name] = element.children;
			});
		};

		// Adds custom non HTML elements to the schema
		function addCustomElements(custom_elements) {
			var customElementRegExp = /^(~)?(.+)$/;

			if (custom_elements) {
				each(split(custom_elements), function(rule) {
					var matches = customElementRegExp.exec(rule),
						inline = matches[1] === '~',
						cloneName = inline ? 'span' : 'div',
						name = matches[2];

					children[name] = children[cloneName];
					customElementsMap[name] = cloneName;

					// If it's not marked as inline then add it to valid block elements
					if (!inline)
						blockElementsMap[name] = {};

					// Add custom elements at span/div positions
					each(children, function(element, child) {
						if (element[cloneName])
							element[name] = element[cloneName];
					});
				});
			}
		};

		// Adds valid children to the schema object
		function addValidChildren(valid_children) {
			var childRuleRegExp = /^([+\-]?)(\w+)\[([^\]]+)\]$/;

			if (valid_children) {
				each(split(valid_children), function(rule) {
					var matches = childRuleRegExp.exec(rule), parent, prefix;

					if (matches) {
						prefix = matches[1];

						// Add/remove items from default
						if (prefix)
							parent = children[matches[2]];
						else
							parent = children[matches[2]] = {'#comment' : {}};

						parent = children[matches[2]];

						each(split(matches[3], '|'), function(child) {
							if (prefix === '-')
								delete parent[child];
							else
								parent[child] = {};
						});
					}
				});
			}
		};

		function getElementRule(name) {
			var element = elements[name], i;

			// Exact match found
			if (element)
				return element;

			// No exact match then try the patterns
			i = patternElements.length;
			while (i--) {
				element = patternElements[i];

				if (element.pattern.test(name))
					return element;
			}
		};

		if (!settings.valid_elements) {
			// No valid elements defined then clone the elements from the transitional spec
			each(transitional, function(element, name) {
				elements[name] = {
					attributes : element.attributes,
					attributesOrder : element.attributesOrder
				};

				children[name] = element.children;
			});

			// Switch these
			each(split('strong/b,em/i'), function(item) {
				item = split(item, '/');
				elements[item[1]].outputName = item[0];
			});

			// Add default alt attribute for images
			elements.img.attributesDefault = [{name: 'alt', value: ''}];

			// Remove these if they are empty by default
			each(split('ol,ul,sub,sup,blockquote,span,font,a,table,tbody,tr'), function(name) {
				elements[name].removeEmpty = true;
			});

			// Padd these by default
			each(split('p,h1,h2,h3,h4,h5,h6,th,td,pre,div,address,caption'), function(name) {
				elements[name].paddEmpty = true;
			});
		} else
			setValidElements(settings.valid_elements);

		addCustomElements(settings.custom_elements);
		addValidChildren(settings.valid_children);
		addValidElements(settings.extended_valid_elements);

		// Todo: Remove this when we fix list handling to be valid
		addValidChildren('+ol[ul|ol],+ul[ul|ol]');

		// If the user didn't allow span only allow internal spans
		if (!getElementRule('span'))
			addValidElements('span[!data-mce-type|*]');

		// Delete invalid elements
		if (settings.invalid_elements) {
			tinymce.each(tinymce.explode(settings.invalid_elements), function(item) {
				if (elements[item])
					delete elements[item];
			});
		}

		/**
		 * Name/value map object with valid parents and children to those parents.
		 *
		 * @example
		 * children = {
		 *    div:{p:{}, h1:{}}
		 * };
		 * @field children
		 * @type {Object}
		 */
		self.children = children;

		/**
		 * Name/value map object with valid styles for each element.
		 *
		 * @field styles
		 * @type {Object}
		 */
		self.styles = validStyles;

		/**
		 * Returns a map with boolean attributes.
		 *
		 * @method getBoolAttrs
		 * @return {Object} Name/value lookup map for boolean attributes.
		 */
		self.getBoolAttrs = function() {
			return boolAttrMap;
		};

		/**
		 * Returns a map with block elements.
		 *
		 * @method getBoolAttrs
		 * @return {Object} Name/value lookup map for block elements.
		 */
		self.getBlockElements = function() {
			return blockElementsMap;
		};

		/**
		 * Returns a map with short ended elements such as BR or IMG.
		 *
		 * @method getShortEndedElements
		 * @return {Object} Name/value lookup map for short ended elements.
		 */
		self.getShortEndedElements = function() {
			return shortEndedElementsMap;
		};

		/**
		 * Returns a map with self closing tags such as <li>.
		 *
		 * @method getSelfClosingElements
		 * @return {Object} Name/value lookup map for self closing tags elements.
		 */
		self.getSelfClosingElements = function() {
			return selfClosingElementsMap;
		};

		/**
		 * Returns a map with elements that should be treated as contents regardless if it has text
		 * content in them or not such as TD, VIDEO or IMG.
		 *
		 * @method getNonEmptyElements
		 * @return {Object} Name/value lookup map for non empty elements.
		 */
		self.getNonEmptyElements = function() {
			return nonEmptyElementsMap;
		};

		/**
		 * Returns a map with elements where white space is to be preserved like PRE or SCRIPT.
		 *
		 * @method getWhiteSpaceElements
		 * @return {Object} Name/value lookup map for white space elements.
		 */
		self.getWhiteSpaceElements = function() {
			return whiteSpaceElementsMap;
		};

		/**
		 * Returns true/false if the specified element and it's child is valid or not
		 * according to the schema.
		 *
		 * @method isValidChild
		 * @param {String} name Element name to check for.
		 * @param {String} child Element child to verify.
		 * @return {Boolean} True/false if the element is a valid child of the specified parent.
		 */
		self.isValidChild = function(name, child) {
			var parent = children[name];

			return !!(parent && parent[child]);
		};

		/**
		 * Returns true/false if the specified element is valid or not
		 * according to the schema.
		 *
		 * @method getElementRule
		 * @param {String} name Element name to check for.
		 * @return {Object} Element object or undefined if the element isn't valid.
		 */
		self.getElementRule = getElementRule;

		/**
		 * Returns an map object of all custom elements.
		 *
		 * @method getCustomElements
		 * @return {Object} Name/value map object of all custom elements.
		 */
		self.getCustomElements = function() {
			return customElementsMap;
		};

		/**
		 * Parses a valid elements string and adds it to the schema. The valid elements format is for example "element[attr=default|otherattr]".
		 * Existing rules will be replaced with the ones specified, so this extends the schema.
		 *
		 * @method addValidElements
		 * @param {String} valid_elements String in the valid elements format to be parsed.
		 */
		self.addValidElements = addValidElements;

		/**
		 * Parses a valid elements string and sets it to the schema. The valid elements format is for example "element[attr=default|otherattr]".
		 * Existing rules will be replaced with the ones specified, so this extends the schema.
		 *
		 * @method setValidElements
		 * @param {String} valid_elements String in the valid elements format to be parsed.
		 */
		self.setValidElements = setValidElements;

		/**
		 * Adds custom non HTML elements to the schema.
		 *
		 * @method addCustomElements
		 * @param {String} custom_elements Comma separated list of custom elements to add.
		 */
		self.addCustomElements = addCustomElements;

		/**
		 * Parses a valid children string and adds them to the schema structure. The valid children format is for example: "element[child1|child2]".
		 *
		 * @method addValidChildren
		 * @param {String} valid_children Valid children elements string to parse
		 */
		self.addValidChildren = addValidChildren;
	};

	// Expose boolMap and blockElementMap as static properties for usage in DOMUtils
	tinymce.html.Schema.boolAttrMap = boolAttrMap;
	tinymce.html.Schema.blockElementsMap = blockElementsMap;
})(tinymce);
/**
 * SaxParser.js
 *
 * Copyright 2010, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	/**
	 * This class parses HTML code using pure JavaScript and executes various events for each item it finds. It will
	 * always execute the events in the right order for tag soup code like <b><p></b></p>. It will also remove elements
	 * and attributes that doesn't fit the schema if the validate setting is enabled.
	 *
	 * @example
	 * var parser = new tinymce.html.SaxParser({
	 *     validate: true,
	 *
	 *     comment: function(text) {
	 *         console.log('Comment:', text);
	 *     },
	 *
	 *     cdata: function(text) {
	 *         console.log('CDATA:', text);
	 *     },
	 *
	 *     text: function(text, raw) {
	 *         console.log('Text:', text, 'Raw:', raw);
	 *     },
	 *
	 *     start: function(name, attrs, empty) {
	 *         console.log('Start:', name, attrs, empty);
	 *     },
	 *
	 *     end: function(name) {
	 *         console.log('End:', name);
	 *     },
	 *
	 *     pi: function(name, text) {
	 *         console.log('PI:', name, text);
	 *     },
	 *
	 *     doctype: function(text) {
	 *         console.log('DocType:', text);
	 *     }
	 * }, schema);
	 * @class tinymce.html.SaxParser
	 * @version 3.4
	 */

	/**
	 * Constructs a new SaxParser instance.
	 *
	 * @constructor
	 * @method SaxParser
	 * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.
	 * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.
	 */
	tinymce.html.SaxParser = function(settings, schema) {
		var self = this, noop = function() {};

		settings = settings || {};
		self.schema = schema = schema || new tinymce.html.Schema();

		if (settings.fix_self_closing !== false)
			settings.fix_self_closing = true;

		// Add handler functions from settings and setup default handlers
		tinymce.each('comment cdata text start end pi doctype'.split(' '), function(name) {
			if (name)
				self[name] = settings[name] || noop;
		});

		/**
		 * Parses the specified HTML string and executes the callbacks for each item it finds.
		 *
		 * @example
		 * new SaxParser({...}).parse('<b>text</b>');
		 * @method parse
		 * @param {String} html Html string to sax parse.
		 */
		self.parse = function(html) {
			var self = this, matches, index = 0, value, endRegExp, stack = [], attrList, i, text, name, isInternalElement, removeInternalElements,
				shortEndedElements, fillAttrsMap, isShortEnded, validate, elementRule, isValidElement, attr, attribsValue, invalidPrefixRegExp,
				validAttributesMap, validAttributePatterns, attributesRequired, attributesDefault, attributesForced, selfClosing,
				tokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0, decode = tinymce.html.Entities.decode, fixSelfClosing, isIE;

			function processEndTag(name) {
				var pos, i;

				// Find position of parent of the same type
				pos = stack.length;
				while (pos--) {
					if (stack[pos].name === name)
						break;
				}

				// Found parent
				if (pos >= 0) {
					// Close all the open elements
					for (i = stack.length - 1; i >= pos; i--) {
						name = stack[i];

						if (name.valid)
							self.end(name.name);
					}

					// Remove the open elements from the stack
					stack.length = pos;
				}
			};

			// Precompile RegExps and map objects
			tokenRegExp = new RegExp('<(?:' +
				'(?:!--([\\w\\W]*?)-->)|' + // Comment
				'(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|' + // CDATA
				'(?:!DOCTYPE([\\w\\W]*?)>)|' + // DOCTYPE
				'(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|' + // PI
				'(?:\\/([^>]+)>)|' + // End element
				'(?:([^\\s\\/<>]+)\\s*((?:[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*)>)' + // Start element
			')', 'g');

			attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:\\.|[^\"])*)\")|(?:\'((?:\\.|[^\'])*)\')|([^>\s]+)))?/g;
			specialElements = {
				'script' : /<\/script[^>]*>/gi,
				'style' : /<\/style[^>]*>/gi,
				'noscript' : /<\/noscript[^>]*>/gi
			};

			// Setup lookup tables for empty elements and boolean attributes
			shortEndedElements = schema.getShortEndedElements();
			selfClosing = schema.getSelfClosingElements();
			fillAttrsMap = schema.getBoolAttrs();
			validate = settings.validate;
			removeInternalElements = settings.remove_internals;
			fixSelfClosing = settings.fix_self_closing;
			isIE = tinymce.isIE;
			invalidPrefixRegExp = /^:/;

			while (matches = tokenRegExp.exec(html)) {
				// Text
				if (index < matches.index)
					self.text(decode(html.substr(index, matches.index - index)));

				if (value = matches[6]) { // End element
					value = value.toLowerCase();

					// IE will add a ":" in front of elements it doesn't understand like custom elements or HTML5 elements
					if (isIE && invalidPrefixRegExp.test(value))
						value = value.substr(1);

					processEndTag(value);
				} else if (value = matches[7]) { // Start element
					value = value.toLowerCase();

					// IE will add a ":" in front of elements it doesn't understand like custom elements or HTML5 elements
					if (isIE && invalidPrefixRegExp.test(value))
						value = value.substr(1);

					isShortEnded = value in shortEndedElements;

					// Is self closing tag for example an <li> after an open <li>
					if (fixSelfClosing && selfClosing[value] && stack.length > 0 && stack[stack.length - 1].name === value)
						processEndTag(value);

					// Validate element
					if (!validate || (elementRule = schema.getElementRule(value))) {
						isValidElement = true;

						// Grab attributes map and patters when validation is enabled
						if (validate) {
							validAttributesMap = elementRule.attributes;
							validAttributePatterns = elementRule.attributePatterns;
						}

						// Parse attributes
						if (attribsValue = matches[8]) {
							isInternalElement = attribsValue.indexOf('data-mce-type') !== -1; // Check if the element is an internal element

							// If the element has internal attributes then remove it if we are told to do so
							if (isInternalElement && removeInternalElements)
								isValidElement = false;

							attrList = [];
							attrList.map = {};

							attribsValue.replace(attrRegExp, function(match, name, value, val2, val3) {
								var attrRule, i;

								name = name.toLowerCase();
								value = name in fillAttrsMap ? name : decode(value || val2 || val3 || ''); // Handle boolean attribute than value attribute

								// Validate name and value
								if (validate && !isInternalElement && name.indexOf('data-') !== 0) {
									attrRule = validAttributesMap[name];

									// Find rule by pattern matching
									if (!attrRule && validAttributePatterns) {
										i = validAttributePatterns.length;
										while (i--) {
											attrRule = validAttributePatterns[i];
											if (attrRule.pattern.test(name))
												break;
										}

										// No rule matched
										if (i === -1)
											attrRule = null;
									}

									// No attribute rule found
									if (!attrRule)
										return;

									// Validate value
									if (attrRule.validValues && !(value in attrRule.validValues))
										return;
								}

								// Add attribute to list and map
								attrList.map[name] = value;
								attrList.push({
									name: name,
									value: value
								});
							});
						} else {
							attrList = [];
							attrList.map = {};
						}

						// Process attributes if validation is enabled
						if (validate && !isInternalElement) {
							attributesRequired = elementRule.attributesRequired;
							attributesDefault = elementRule.attributesDefault;
							attributesForced = elementRule.attributesForced;

							// Handle forced attributes
							if (attributesForced) {
								i = attributesForced.length;
								while (i--) {
									attr = attributesForced[i];
									name = attr.name;
									attrValue = attr.value;

									if (attrValue === '{$uid}')
										attrValue = 'mce_' + idCount++;

									attrList.map[name] = attrValue;
									attrList.push({name: name, value: attrValue});
								}
							}

							// Handle default attributes
							if (attributesDefault) {
								i = attributesDefault.length;
								while (i--) {
									attr = attributesDefault[i];
									name = attr.name;

									if (!(name in attrList.map)) {
										attrValue = attr.value;

										if (attrValue === '{$uid}')
											attrValue = 'mce_' + idCount++;

										attrList.map[name] = attrValue;
										attrList.push({name: name, value: attrValue});
									}
								}
							}

							// Handle required attributes
							if (attributesRequired) {
								i = attributesRequired.length;
								while (i--) {
									if (attributesRequired[i] in attrList.map)
										break;
								}

								// None of the required attributes where found
								if (i === -1)
									isValidElement = false;
							}

							// Invalidate element if it's marked as bogus
							if (attrList.map['data-mce-bogus'])
								isValidElement = false;
						}

						if (isValidElement)
							self.start(value, attrList, isShortEnded);
					} else
						isValidElement = false;

					// Treat script, noscript and style a bit different since they may include code that looks like elements
					if (endRegExp = specialElements[value]) {
						endRegExp.lastIndex = index = matches.index + matches[0].length;

						if (matches = endRegExp.exec(html)) {
							if (isValidElement)
								text = html.substr(index, matches.index - index);

							index = matches.index + matches[0].length;
						} else {
							text = html.substr(index);
							index = html.length;
						}

						if (isValidElement && text.length > 0)
							self.text(text, true);

						if (isValidElement)
							self.end(value);

						tokenRegExp.lastIndex = index;
						continue;
					}

					// Push value on to stack
					if (!isShortEnded) {
						if (!attribsValue || attribsValue.indexOf('/') != attribsValue.length - 1)
							stack.push({name: value, valid: isValidElement});
						else if (isValidElement)
							self.end(value);
					}
				} else if (value = matches[1]) { // Comment
					self.comment(value);
				} else if (value = matches[2]) { // CDATA
					self.cdata(value);
				} else if (value = matches[3]) { // DOCTYPE
					self.doctype(value);
				} else if (value = matches[4]) { // PI
					self.pi(value, matches[5]);
				}

				index = matches.index + matches[0].length;
			}

			// Text
			if (index < html.length)
				self.text(decode(html.substr(index)));

			// Close any open elements
			for (i = stack.length - 1; i >= 0; i--) {
				value = stack[i];

				if (value.valid)
					self.end(value.name);
			}
		};
	}
})(tinymce);
/**
 * Node.js
 *
 * Copyright 2010, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var whiteSpaceRegExp = /^[ \t\r\n]*$/, typeLookup = {
		'#text' : 3,
		'#comment' : 8,
		'#cdata' : 4,
		'#pi' : 7,
		'#doctype' : 10,
		'#document-fragment' : 11
	};

	// Walks the tree left/right
	function walk(node, root_node, prev) {
		var sibling, parent, startName = prev ? 'lastChild' : 'firstChild', siblingName = prev ? 'prev' : 'next';

		// Walk into nodes if it has a start
		if (node[startName])
			return node[startName];

		// Return the sibling if it has one
		if (node !== root_node) {
			sibling = node[siblingName];

			if (sibling)
				return sibling;

			// Walk up the parents to look for siblings
			for (parent = node.parent; parent && parent !== root_node; parent = parent.parent) {
				sibling = parent[siblingName];

				if (sibling)
					return sibling;
			}
		}
	};

	/**
	 * This class is a minimalistic implementation of a DOM like node used by the DomParser class.
	 *
	 * @example
	 * var node = new tinymce.html.Node('strong', 1);
	 * someRoot.append(node);
	 *
	 * @class tinymce.html.Node
	 * @version 3.4
	 */

	/**
	 * Constructs a new Node instance.
	 *
	 * @constructor
	 * @method Node
	 * @param {String} name Name of the node type.
	 * @param {Number} type Numeric type representing the node.
	 */
	function Node(name, type) {
		this.name = name;
		this.type = type;

		if (type === 1) {
			this.attributes = [];
			this.attributes.map = {};
		}
	}

	tinymce.extend(Node.prototype, {
		/**
		 * Replaces the current node with the specified one.
		 *
		 * @example
		 * someNode.replace(someNewNode);
		 *
		 * @method replace
		 * @param {tinymce.html.Node} node Node to replace the current node with.
		 * @return {tinymce.html.Node} The old node that got replaced.
		 */
		replace : function(node) {
			var self = this;

			if (node.parent)
				node.remove();

			self.insert(node, self);
			self.remove();

			return self;
		},

		/**
		 * Gets/sets or removes an attribute by name.
		 *
		 * @example
		 * someNode.attr("name", "value"); // Sets an attribute
		 * console.log(someNode.attr("name")); // Gets an attribute
		 * someNode.attr("name", null); // Removes an attribute
		 *
		 * @method attr
		 * @param {String} name Attribute name to set or get.
		 * @param {String} value Optional value to set.
		 * @return {String/tinymce.html.Node} String or undefined on a get operation or the current node on a set operation.
		 */
		attr : function(name, value) {
			var self = this, attrs, i, undef;

			if (typeof name !== "string") {
				for (i in name)
					self.attr(i, name[i]);

				return self;
			}

			if (attrs = self.attributes) {
				if (value !== undef) {
					// Remove attribute
					if (value === null) {
						if (name in attrs.map) {
							delete attrs.map[name];

							i = attrs.length;
							while (i--) {
								if (attrs[i].name === name) {
									attrs = attrs.splice(i, 1);
									return self;
								}
							}
						}

						return self;
					}

					// Set attribute
					if (name in attrs.map) {
						// Set attribute
						i = attrs.length;
						while (i--) {
							if (attrs[i].name === name) {
								attrs[i].value = value;
								break;
							}
						}
					} else
						attrs.push({name: name, value: value});

					attrs.map[name] = value;

					return self;
				} else {
					return attrs.map[name];
				}
			}
		},

		/**
		 * Does a shallow clones the node into a new node. It will also exclude id attributes since
		 * there should only be one id per document.
		 *
		 * @example
		 * var clonedNode = node.clone();
		 *
		 * @method clone
		 * @return {tinymce.html.Node} New copy of the original node.
		 */
		clone : function() {
			var self = this, clone = new Node(self.name, self.type), i, l, selfAttrs, selfAttr, cloneAttrs;

			// Clone element attributes
			if (selfAttrs = self.attributes) {
				cloneAttrs = [];
				cloneAttrs.map = {};

				for (i = 0, l = selfAttrs.length; i < l; i++) {
					selfAttr = selfAttrs[i];

					// Clone everything except id
					if (selfAttr.name !== 'id') {
						cloneAttrs[cloneAttrs.length] = {name: selfAttr.name, value: selfAttr.value};
						cloneAttrs.map[selfAttr.name] = selfAttr.value;
					}
				}

				clone.attributes = cloneAttrs;
			}

			clone.value = self.value;
			clone.shortEnded = self.shortEnded;

			return clone;
		},

		/**
		 * Wraps the node in in another node.
		 *
		 * @example
		 * node.wrap(wrapperNode);
		 *
		 * @method wrap
		 */
		wrap : function(wrapper) {
			var self = this;

			self.parent.insert(wrapper, self);
			wrapper.append(self);

			return self;
		},

		/**
		 * Unwraps the node in other words it removes the node but keeps the children.
		 *
		 * @example
		 * node.unwrap();
		 *
		 * @method unwrap
		 */
		unwrap : function() {
			var self = this, node, next;

			for (node = self.firstChild; node; ) {
				next = node.next;
				self.insert(node, self, true);
				node = next;
			}

			self.remove();
		},

		/**
		 * Removes the node from it's parent.
		 *
		 * @example
		 * node.remove();
		 *
		 * @method remove
		 * @return {tinymce.html.Node} Current node that got removed.
		 */
		remove : function() {
			var self = this, parent = self.parent, next = self.next, prev = self.prev;

			if (parent) {
				if (parent.firstChild === self) {
					parent.firstChild = next;

					if (next)
						next.prev = null;
				} else {
					prev.next = next;
				}

				if (parent.lastChild === self) {
					parent.lastChild = prev;

					if (prev)
						prev.next = null;
				} else {
					next.prev = prev;
				}

				self.parent = self.next = self.prev = null;
			}

			return self;
		},

		/**
		 * Appends a new node as a child of the current node.
		 *
		 * @example
		 * node.append(someNode);
		 *
		 * @method append
		 * @param {tinymce.html.Node} node Node to append as a child of the current one.
		 * @return {tinymce.html.Node} The node that got appended.
		 */
		append : function(node) {
			var self = this, last;

			if (node.parent)
				node.remove();

			last = self.lastChild;
			if (last) {
				last.next = node;
				node.prev = last;
				self.lastChild = node;
			} else
				self.lastChild = self.firstChild = node;

			node.parent = self;

			return node;
		},

		/**
		 * Inserts a node at a specific position as a child of the current node.
		 *
		 * @example
		 * parentNode.insert(newChildNode, oldChildNode);
		 *
		 * @method insert
		 * @param {tinymce.html.Node} node Node to insert as a child of the current node.
		 * @param {tinymce.html.Node} ref_node Reference node to set node before/after.
		 * @param {Boolean} before Optional state to insert the node before the reference node.
		 * @return {tinymce.html.Node} The node that got inserted.
		 */
		insert : function(node, ref_node, before) {
			var parent;

			if (node.parent)
				node.remove();

			parent = ref_node.parent || this;

			if (before) {
				if (ref_node === parent.firstChild)
					parent.firstChild = node;
				else
					ref_node.prev.next = node;

				node.prev = ref_node.prev;
				node.next = ref_node;
				ref_node.prev = node;
			} else {
				if (ref_node === parent.lastChild)
					parent.lastChild = node;
				else
					ref_node.next.prev = node;

				node.next = ref_node.next;
				node.prev = ref_node;
				ref_node.next = node;
			}

			node.parent = parent;

			return node;
		},

		/**
		 * Get all children by name.
		 *
		 * @method getAll
		 * @param {String} name Name of the child nodes to collect.
		 * @return {Array} Array with child nodes matchin the specified name.
		 */
		getAll : function(name) {
			var self = this, node, collection = [];

			for (node = self.firstChild; node; node = walk(node, self)) {
				if (node.name === name)
					collection.push(node);
			}

			return collection;
		},

		/**
		 * Removes all children of the current node.
		 *
		 * @method empty
		 * @return {tinymce.html.Node} The current node that got cleared.
		 */
		empty : function() {
			var self = this, nodes, i, node;

			// Remove all children
			if (self.firstChild) {
				nodes = [];

				// Collect the children
				for (node = self.firstChild; node; node = walk(node, self))
					nodes.push(node);

				// Remove the children
				i = nodes.length;
				while (i--) {
					node = nodes[i];
					node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
				}
			}

			self.firstChild = self.lastChild = null;

			return self;
		},

		/**
		 * Returns true/false if the node is to be considered empty or not.
		 *
		 * @example
		 * node.isEmpty({img : true});
		 * @method isEmpty
		 * @param {Object} elements Name/value object with elements that are automatically treated as non empty elements.
		 * @return {Boolean} true/false if the node is empty or not.
		 */
		isEmpty : function(elements) {
			var self = this, node = self.firstChild, i, name;

			if (node) {
				do {
					if (node.type === 1) {
						// Ignore bogus elements
						if (node.attributes.map['data-mce-bogus'])
							continue;

						// Keep empty elements like <img />
						if (elements[node.name])
							return false;

						// Keep elements with data attributes or name attribute like <a name="1"></a>
						i = node.attributes.length;
						while (i--) {
							name = node.attributes[i].name;
							if (name === "name" || name.indexOf('data-') === 0)
								return false;
						}
					}

					// Keep non whitespace text nodes
					if ((node.type === 3 && !whiteSpaceRegExp.test(node.value)))
						return false;
				} while (node = walk(node, self));
			}

			return true;
		},

		/**
		 * Walks to the next or previous node and returns that node or null if it wasn't found.
		 *
		 * @method walk
		 * @param {Boolean} prev Optional previous node state defaults to false.
		 * @return {tinymce.html.Node} Node that is next to or previous of the current node.
		 */
		walk : function(prev) {
			return walk(this, null, prev);
		}
	});

	tinymce.extend(Node, {
		/**
		 * Creates a node of a specific type.
		 *
		 * @static
		 * @method create
		 * @param {String} name Name of the node type to create for example "b" or "#text".
		 * @param {Object} attrs Name/value collection of attributes that will be applied to elements.
		 */
		create : function(name, attrs) {
			var node, attrName;

			// Create node
			node = new Node(name, typeLookup[name] || 1);

			// Add attributes if needed
			if (attrs) {
				for (attrName in attrs)
					node.attr(attrName, attrs[attrName]);
			}

			return node;
		}
	});

	tinymce.html.Node = Node;
})(tinymce);
/**
 * DomParser.js
 *
 * Copyright 2010, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var Node = tinymce.html.Node;

	/**
	 * This class parses HTML code into a DOM like structure of nodes it will remove redundant whitespace and make
	 * sure that the node tree is valid according to the specified schema. So for example: <p>a<p>b</p>c</p> will become <p>a</p><p>b</p><p>c</p>
	 *
	 * @example
	 * var parser = new tinymce.html.DomParser({validate: true}, schema);
	 * var rootNode = parser.parse('<h1>content</h1>');
	 *
	 * @class tinymce.html.DomParser
	 * @version 3.4
	 */

	/**
	 * Constructs a new DomParser instance.
	 *
	 * @constructor
	 * @method DomParser
	 * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.
	 * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.
	 */
	tinymce.html.DomParser = function(settings, schema) {
		var self = this, nodeFilters = {}, attributeFilters = [], matchedNodes = {}, matchedAttributes = {};

		settings = settings || {};
		settings.validate = "validate" in settings ? settings.validate : true;
		settings.root_name = settings.root_name || 'body';
		self.schema = schema = schema || new tinymce.html.Schema();

		function fixInvalidChildren(nodes) {
			var ni, node, parent, parents, newParent, currentNode, tempNode, childNode, i,
				childClone, nonEmptyElements, nonSplitableElements, sibling, nextNode;

			nonSplitableElements = tinymce.makeMap('tr,td,th,tbody,thead,tfoot,table');
			nonEmptyElements = schema.getNonEmptyElements();

			for (ni = 0; ni < nodes.length; ni++) {
				node = nodes[ni];

				// Already removed
				if (!node.parent)
					continue;

				// Get list of all parent nodes until we find a valid parent to stick the child into
				parents = [node];
				for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && !nonSplitableElements[parent.name]; parent = parent.parent)
					parents.push(parent);

				// Found a suitable parent
				if (parent && parents.length > 1) {
					// Reverse the array since it makes looping easier
					parents.reverse();

					// Clone the related parent and insert that after the moved node
					newParent = currentNode = self.filterNode(parents[0].clone());

					// Start cloning and moving children on the left side of the target node
					for (i = 0; i < parents.length - 1; i++) {
						if (schema.isValidChild(currentNode.name, parents[i].name)) {
							tempNode = self.filterNode(parents[i].clone());
							currentNode.append(tempNode);
						} else
							tempNode = currentNode;

						for (childNode = parents[i].firstChild; childNode && childNode != parents[i + 1]; ) {
							nextNode = childNode.next;
							tempNode.append(childNode);
							childNode = nextNode;
						}

						currentNode = tempNode;
					}

					if (!newParent.isEmpty(nonEmptyElements)) {
						parent.insert(newParent, parents[0], true);
						parent.insert(node, newParent);
					} else {
						parent.insert(node, parents[0], true);
					}

					// Check if the element is empty by looking through it's contents and special treatment for <p><br /></p>
					parent = parents[0];
					if (parent.isEmpty(nonEmptyElements) || parent.firstChild === parent.lastChild && parent.firstChild.name === 'br') {
						parent.empty().remove();
					}
				} else if (node.parent) {
					// If it's an LI try to find a UL/OL for it or wrap it
					if (node.name === 'li') {
						sibling = node.prev;
						if (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {
							sibling.append(node);
							continue;
						}

						sibling = node.next;
						if (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {
							sibling.insert(node, sibling.firstChild, true);
							continue;
						}

						node.wrap(self.filterNode(new Node('ul', 1)));
						continue;
					}

					// Try wrapping the element in a DIV
					if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
						node.wrap(self.filterNode(new Node('div', 1)));
					} else {
						// We failed wrapping it, then remove or unwrap it
						if (node.name === 'style' || node.name === 'script')
							node.empty().remove();
						else
							node.unwrap();
					}
				}
			}
		};

		/**
		 * Runs the specified node though the element and attributes filters.
		 *
		 * @param {tinymce.html.Node} Node the node to run filters on.
		 * @return {tinymce.html.Node} The passed in node.
		 */
		self.filterNode = function(node) {
			var i, name, list;

			// Run element filters
			if (name in nodeFilters) {
				list = matchedNodes[name];

				if (list)
					list.push(node);
				else
					matchedNodes[name] = [node];
			}

			// Run attribute filters
			i = attributeFilters.length;
			while (i--) {
				name = attributeFilters[i].name;

				if (name in node.attributes.map) {
					list = matchedAttributes[name];

					if (list)
						list.push(node);
					else
						matchedAttributes[name] = [node];
				}
			}

			return node;
		};

		/**
		 * Adds a node filter function to the parser, the parser will collect the specified nodes by name
		 * and then execute the callback ones it has finished parsing the document.
		 *
		 * @example
		 * parser.addNodeFilter('p,h1', function(nodes, name) {
		 *		for (var i = 0; i < nodes.length; i++) {
		 *			console.log(nodes[i].name);
		 *		}
		 * });
		 * @method addNodeFilter
		 * @method {String} name Comma separated list of nodes to collect.
		 * @param {function} callback Callback function to execute once it has collected nodes.
		 */
		self.addNodeFilter = function(name, callback) {
			tinymce.each(tinymce.explode(name), function(name) {
				var list = nodeFilters[name];

				if (!list)
					nodeFilters[name] = list = [];

				list.push(callback);
			});
		};

		/**
		 * Adds a attribute filter function to the parser, the parser will collect nodes that has the specified attributes
		 * and then execute the callback ones it has finished parsing the document.
		 *
		 * @example
		 * parser.addAttributeFilter('src,href', function(nodes, name) {
		 *		for (var i = 0; i < nodes.length; i++) {
		 *			console.log(nodes[i].name);
		 *		}
		 * });
		 * @method addAttributeFilter
		 * @method {String} name Comma separated list of nodes to collect.
		 * @param {function} callback Callback function to execute once it has collected nodes.
		 */
		self.addAttributeFilter = function(name, callback) {
			tinymce.each(tinymce.explode(name), function(name) {
				var i;

				for (i = 0; i < attributeFilters.length; i++) {
					if (attributeFilters[i].name === name) {
						attributeFilters[i].callbacks.push(callback);
						return;
					}
				}

				attributeFilters.push({name: name, callbacks: [callback]});
			});
		};

		/**
		 * Parses the specified HTML string into a DOM like node tree and returns the result.
		 *
		 * @example
		 * var rootNode = new DomParser({...}).parse('<b>text</b>');
		 * @method parse
		 * @param {String} html Html string to sax parse.
		 * @param {Object} args Optional args object that gets passed to all filter functions.
		 * @return {tinymce.html.Node} Root node containing the tree.
		 */
		self.parse = function(html, args) {
			var parser, rootNode, node, nodes, i, l, fi, fl, list, name, validate,
				blockElements, startWhiteSpaceRegExp, invalidChildren = [],
				endWhiteSpaceRegExp, allWhiteSpaceRegExp, whiteSpaceElements, children, nonEmptyElements, rootBlockName;

			args = args || {};
			matchedNodes = {};
			matchedAttributes = {};
			blockElements = tinymce.extend(tinymce.makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
			nonEmptyElements = schema.getNonEmptyElements();
			children = schema.children;
			validate = settings.validate;
			rootBlockName = "forced_root_block" in args ? args.forced_root_block : settings.forced_root_block;

			whiteSpaceElements = schema.getWhiteSpaceElements();
			startWhiteSpaceRegExp = /^[ \t\r\n]+/;
			endWhiteSpaceRegExp = /[ \t\r\n]+$/;
			allWhiteSpaceRegExp = /[ \t\r\n]+/g;

			function addRootBlocks() {
				var node = rootNode.firstChild, next, rootBlockNode;

				while (node) {
					next = node.next;

					if (node.type == 3 || (node.type == 1 && node.name !== 'p' && !blockElements[node.name] && !node.attr('data-mce-type'))) {
						if (!rootBlockNode) {
							// Create a new root block element
							rootBlockNode = createNode(rootBlockName, 1);
							rootNode.insert(rootBlockNode, node);
							rootBlockNode.append(node);
						} else
							rootBlockNode.append(node);
					} else {
						rootBlockNode = null;
					}

					node = next;
				};
			};

			function createNode(name, type) {
				var node = new Node(name, type), list;

				if (name in nodeFilters) {
					list = matchedNodes[name];

					if (list)
						list.push(node);
					else
						matchedNodes[name] = [node];
				}

				return node;
			};

			function removeWhitespaceBefore(node) {
				var textNode, textVal, sibling;

				for (textNode = node.prev; textNode && textNode.type === 3; ) {
					textVal = textNode.value.replace(endWhiteSpaceRegExp, '');

					if (textVal.length > 0) {
						textNode.value = textVal;
						textNode = textNode.prev;
					} else {
						sibling = textNode.prev;
						textNode.remove();
						textNode = sibling;
					}
				}
			};

			parser = new tinymce.html.SaxParser({
				validate : validate,
				fix_self_closing : !validate, // Let the DOM parser handle <li> in <li> or <p> in <p> for better results

				cdata: function(text) {
					node.append(createNode('#cdata', 4)).value = text;
				},

				text: function(text, raw) {
					var textNode;

					// Trim all redundant whitespace on non white space elements
					if (!whiteSpaceElements[node.name]) {
						text = text.replace(allWhiteSpaceRegExp, ' ');

						if (node.lastChild && blockElements[node.lastChild.name])
							text = text.replace(startWhiteSpaceRegExp, '');
					}

					// Do we need to create the node
					if (text.length !== 0) {
						textNode = createNode('#text', 3);
						textNode.raw = !!raw;
						node.append(textNode).value = text;
					}
				},

				comment: function(text) {
					node.append(createNode('#comment', 8)).value = text;
				},

				pi: function(name, text) {
					node.append(createNode(name, 7)).value = text;
					removeWhitespaceBefore(node);
				},

				doctype: function(text) {
					var newNode;

					newNode = node.append(createNode('#doctype', 10));
					newNode.value = text;
					removeWhitespaceBefore(node);
				},

				start: function(name, attrs, empty) {
					var newNode, attrFiltersLen, elementRule, textNode, attrName, text, sibling, parent;

					elementRule = validate ? schema.getElementRule(name) : {};
					if (elementRule) {
						newNode = createNode(elementRule.outputName || name, 1);
						newNode.attributes = attrs;
						newNode.shortEnded = empty;

						node.append(newNode);

						// Check if node is valid child of the parent node is the child is
						// unknown we don't collect it since it's probably a custom element
						parent = children[node.name];
						if (parent && children[newNode.name] && !parent[newNode.name])
							invalidChildren.push(newNode);

						attrFiltersLen = attributeFilters.length;
						while (attrFiltersLen--) {
							attrName = attributeFilters[attrFiltersLen].name;

							if (attrName in attrs.map) {
								list = matchedAttributes[attrName];

								if (list)
									list.push(newNode);
								else
									matchedAttributes[attrName] = [newNode];
							}
						}

						// Trim whitespace before block
						if (blockElements[name])
							removeWhitespaceBefore(newNode);

						// Change current node if the element wasn't empty i.e not <br /> or <img />
						if (!empty)
							node = newNode;
					}
				},

				end: function(name) {
					var textNode, elementRule, text, sibling, tempNode;

					elementRule = validate ? schema.getElementRule(name) : {};
					if (elementRule) {
						if (blockElements[name]) {
							if (!whiteSpaceElements[node.name]) {
								// Trim whitespace at beginning of block
								for (textNode = node.firstChild; textNode && textNode.type === 3; ) {
									text = textNode.value.replace(startWhiteSpaceRegExp, '');

									if (text.length > 0) {
										textNode.value = text;
										textNode = textNode.next;
									} else {
										sibling = textNode.next;
										textNode.remove();
										textNode = sibling;
									}
								}

								// Trim whitespace at end of block
								for (textNode = node.lastChild; textNode && textNode.type === 3; ) {
									text = textNode.value.replace(endWhiteSpaceRegExp, '');

									if (text.length > 0) {
										textNode.value = text;
										textNode = textNode.prev;
									} else {
										sibling = textNode.prev;
										textNode.remove();
										textNode = sibling;
									}
								}
							}

							// Trim start white space
							textNode = node.prev;
							if (textNode && textNode.type === 3) {
								text = textNode.value.replace(startWhiteSpaceRegExp, '');

								if (text.length > 0)
									textNode.value = text;
								else
									textNode.remove();
							}
						}

						// Handle empty nodes
						if (elementRule.removeEmpty || elementRule.paddEmpty) {
							if (node.isEmpty(nonEmptyElements)) {
								if (elementRule.paddEmpty)
									node.empty().append(new Node('#text', '3')).value = '\u00a0';
								else {
									// Leave nodes that have a name like <a name="name">
									if (!node.attributes.map.name) {
										tempNode = node.parent;
										node.empty().remove();
										node = tempNode;
										return;
									}
								}
							}
						}

						node = node.parent;
					}
				}
			}, schema);

			rootNode = node = new Node(args.context || settings.root_name, 11);

			parser.parse(html);

			// Fix invalid children or report invalid children in a contextual parsing
			if (validate && invalidChildren.length) {
				if (!args.context)
					fixInvalidChildren(invalidChildren);
				else
					args.invalid = true;
			}

			// Wrap nodes in the root into block elements if the root is body
			if (rootBlockName && rootNode.name == 'body')
				addRootBlocks();

			// Run filters only when the contents is valid
			if (!args.invalid) {
				// Run node filters
				for (name in matchedNodes) {
					list = nodeFilters[name];
					nodes = matchedNodes[name];

					// Remove already removed children
					fi = nodes.length;
					while (fi--) {
						if (!nodes[fi].parent)
							nodes.splice(fi, 1);
					}

					for (i = 0, l = list.length; i < l; i++)
						list[i](nodes, name, args);
				}

				// Run attribute filters
				for (i = 0, l = attributeFilters.length; i < l; i++) {
					list = attributeFilters[i];

					if (list.name in matchedAttributes) {
						nodes = matchedAttributes[list.name];

						// Remove already removed children
						fi = nodes.length;
						while (fi--) {
							if (!nodes[fi].parent)
								nodes.splice(fi, 1);
						}

						for (fi = 0, fl = list.callbacks.length; fi < fl; fi++)
							list.callbacks[fi](nodes, list.name, args);
					}
				}
			}

			return rootNode;
		};

		// Remove <br> at end of block elements Gecko and WebKit injects BR elements to
		// make it possible to place the caret inside empty blocks. This logic tries to remove
		// these elements and keep br elements that where intended to be there intact
		if (settings.remove_trailing_brs) {
			self.addNodeFilter('br', function(nodes, name) {
				var i, l = nodes.length, node, blockElements = schema.getBlockElements(),
					nonEmptyElements = schema.getNonEmptyElements(), parent, prev, prevName;

				// Remove brs from body element as well
				blockElements.body = 1;

				// Must loop forwards since it will otherwise remove all brs in <p>a<br><br><br></p>
				for (i = 0; i < l; i++) {
					node = nodes[i];
					parent = node.parent;

					if (blockElements[node.parent.name] && node === parent.lastChild) {
						// Loop all nodes to the right of the current node and check for other BR elements
						// excluding bookmarks since they are invisible
						prev = node.prev;
						while (prev) {
							prevName = prev.name;

							// Ignore bookmarks
							if (prevName !== "span" || prev.attr('data-mce-type') !== 'bookmark') {
								// Found a non BR element
								if (prevName !== "br")
									break;

								// Found another br it's a <br><br> structure then don't remove anything
								if (prevName === 'br') {
									node = null;
									break;
								}
							}

							prev = prev.prev;
						}

						if (node) {
							node.remove();

							// Is the parent to be considered empty after we removed the BR
							if (parent.isEmpty(nonEmptyElements)) {
								elementRule = schema.getElementRule(parent.name);

								// Remove or padd the element depending on schema rule
								if (elementRule) {
								  if (elementRule.removeEmpty)
									  parent.remove();
								  else if (elementRule.paddEmpty)
									  parent.empty().append(new tinymce.html.Node('#text', 3)).value = '\u00a0';
							  }
              }
						}
					}
				}
			});
		}
	}
})(tinymce);
/**
 * Writer.js
 *
 * Copyright 2010, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

/**
 * This class is used to write HTML tags out it can be used with the Serializer or the SaxParser.
 *
 * @class tinymce.html.Writer
 * @example
 * var writer = new tinymce.html.Writer({indent : true});
 * var parser = new tinymce.html.SaxParser(writer).parse('<p><br></p>');
 * console.log(writer.getContent());
 *
 * @class tinymce.html.Writer
 * @version 3.4
 */

/**
 * Constructs a new Writer instance.
 *
 * @constructor
 * @method Writer
 * @param {Object} settings Name/value settings object.
 */
tinymce.html.Writer = function(settings) {
	var html = [], indent, indentBefore, indentAfter, encode, htmlOutput;

	settings = settings || {};
	indent = settings.indent;
	indentBefore = tinymce.makeMap(settings.indent_before || '');
	indentAfter = tinymce.makeMap(settings.indent_after || '');
	encode = tinymce.html.Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);
	htmlOutput = settings.element_format == "html";

	return {
		/**
		 * Writes the a start element such as <p id="a">.
		 *
		 * @method start
		 * @param {String} name Name of the element.
		 * @param {Array} attrs Optional attribute array or undefined if it hasn't any.
		 * @param {Boolean} empty Optional empty state if the tag should end like <br />.
		 */
		start: function(name, attrs, empty) {
			var i, l, attr, value;

			if (indent && indentBefore[name] && html.length > 0) {
				value = html[html.length - 1];

				if (value.length > 0 && value !== '\n')
					html.push('\n');
			}

			html.push('<', name);

			if (attrs) {
				for (i = 0, l = attrs.length; i < l; i++) {
					attr = attrs[i];
					html.push(' ', attr.name, '="', encode(attr.value, true), '"');
				}
			}

			if (!empty || htmlOutput)
				html[html.length] = '>';
			else
				html[html.length] = ' />';

			if (empty && indent && indentAfter[name] && html.length > 0) {
				value = html[html.length - 1];

				if (value.length > 0 && value !== '\n')
					html.push('\n');
			}
		},

		/**
		 * Writes the a end element such as </p>.
		 *
		 * @method end
		 * @param {String} name Name of the element.
		 */
		end: function(name) {
			var value;

			/*if (indent && indentBefore[name] && html.length > 0) {
				value = html[html.length - 1];

				if (value.length > 0 && value !== '\n')
					html.push('\n');
			}*/

			html.push('</', name, '>');

			if (indent && indentAfter[name] && html.length > 0) {
				value = html[html.length - 1];

				if (value.length > 0 && value !== '\n')
					html.push('\n');
			}
		},

		/**
		 * Writes a text node.
		 *
		 * @method text
		 * @param {String} text String to write out.
		 * @param {Boolean} raw Optional raw state if true the contents wont get encoded.
		 */
		text: function(text, raw) {
			if (text.length > 0)
				html[html.length] = raw ? text : encode(text);
		},

		/**
		 * Writes a cdata node such as <![CDATA[data]]>.
		 *
		 * @method cdata
		 * @param {String} text String to write out inside the cdata.
		 */
		cdata: function(text) {
			html.push('<![CDATA[', text, ']]>');
		},

		/**
		 * Writes a comment node such as <!-- Comment -->.
		 *
		 * @method cdata
		 * @param {String} text String to write out inside the comment.
		 */
		comment: function(text) {
			html.push('<!--', text, '-->');
		},

		/**
		 * Writes a PI node such as <?xml attr="value" ?>.
		 *
		 * @method pi
		 * @param {String} name Name of the pi.
		 * @param {String} text String to write out inside the pi.
		 */
		pi: function(name, text) {
			if (text)
				html.push('<?', name, ' ', text, '?>');
			else
				html.push('<?', name, '?>');

			if (indent)
				html.push('\n');
		},

		/**
		 * Writes a doctype node such as <!DOCTYPE data>.
		 *
		 * @method doctype
		 * @param {String} text String to write out inside the doctype.
		 */
		doctype: function(text) {
			html.push('<!DOCTYPE', text, '>', indent ? '\n' : '');
		},

		/**
		 * Resets the internal buffer if one wants to reuse the writer.
		 *
		 * @method reset
		 */
		reset: function() {
			html.length = 0;
		},

		/**
		 * Returns the contents that got serialized.
		 *
		 * @method getContent
		 * @return {String} HTML contents that got written down.
		 */
		getContent: function() {
			return html.join('').replace(/\n$/, '');
		}
	};
};
/**
 * Serializer.js
 *
 * Copyright 2010, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	/**
	 * This class is used to serialize down the DOM tree into a string using a Writer instance.
	 *
	 *
	 * @example
	 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse('<p>text</p>'));
	 * @class tinymce.html.Serializer
	 * @version 3.4
	 */

	/**
	 * Constructs a new Serializer instance.
	 *
	 * @constructor
	 * @method Serializer
	 * @param {Object} settings Name/value settings object.
	 * @param {tinymce.html.Schema} schema Schema instance to use.
	 */
	tinymce.html.Serializer = function(settings, schema) {
		var self = this, writer = new tinymce.html.Writer(settings);

		settings = settings || {};
		settings.validate = "validate" in settings ? settings.validate : true;

		self.schema = schema = schema || new tinymce.html.Schema();
		self.writer = writer;

		/**
		 * Serializes the specified node into a string.
		 *
		 * @example
		 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse('<p>text</p>'));
		 * @method serialize
		 * @param {tinymce.html.Node} node Node instance to serialize.
		 * @return {String} String with HTML based on DOM tree.
		 */
		self.serialize = function(node) {
			var handlers, validate;

			validate = settings.validate;

			handlers = {
				// #text
				3: function(node, raw) {
					writer.text(node.value, node.raw);
				},

				// #comment
				8: function(node) {
					writer.comment(node.value);
				},

				// Processing instruction
				7: function(node) {
					writer.pi(node.name, node.value);
				},

				// Doctype
				10: function(node) {
					writer.doctype(node.value);
				},

				// CDATA
				4: function(node) {
					writer.cdata(node.value);
				},

 				// Document fragment
				11: function(node) {
					if ((node = node.firstChild)) {
						do {
							walk(node);
						} while (node = node.next);
					}
				}
			};

			writer.reset();

			function walk(node) {
				var handler = handlers[node.type], name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;

				if (!handler) {
					name = node.name;
					isEmpty = node.shortEnded;
					attrs = node.attributes;

					// Sort attributes
					if (validate && attrs && attrs.length > 1) {
						sortedAttrs = [];
						sortedAttrs.map = {};

						elementRule = schema.getElementRule(node.name);
						for (i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
							attrName = elementRule.attributesOrder[i];

							if (attrName in attrs.map) {
								attrValue = attrs.map[attrName];
								sortedAttrs.map[attrName] = attrValue;
								sortedAttrs.push({name: attrName, value: attrValue});
							}
						}

						for (i = 0, l = attrs.length; i < l; i++) {
							attrName = attrs[i].name;

							if (!(attrName in sortedAttrs.map)) {
								attrValue = attrs.map[attrName];
								sortedAttrs.map[attrName] = attrValue;
								sortedAttrs.push({name: attrName, value: attrValue});
							}
						}

						attrs = sortedAttrs;
					}

					writer.start(node.name, attrs, isEmpty);

					if (!isEmpty) {
						if ((node = node.firstChild)) {
							do {
								walk(node);
							} while (node = node.next);
						}

						writer.end(name);
					}
				} else
					handler(node);
			}

			// Serialize element and treat all non elements as fragments
			if (node.type == 1 && !settings.inner)
				walk(node);
			else
				handlers[11](node);

			return writer.getContent();
		};
	}
})(tinymce);
/**
 * DOMUtils.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	// Shorten names
	var each = tinymce.each,
		is = tinymce.is,
		isWebKit = tinymce.isWebKit,
		isIE = tinymce.isIE,
		Entities = tinymce.html.Entities,
		simpleSelectorRe = /^([a-z0-9],?)+$/i,
		blockElementsMap = tinymce.html.Schema.blockElementsMap,
		whiteSpaceRegExp = /^[ \t\r\n]*$/;

	/**
	 * Utility class for various DOM manipulation and retrival functions.
	 *
	 * @class tinymce.dom.DOMUtils
	 * @example
	 * // Add a class to an element by id in the page
	 * tinymce.DOM.addClass('someid', 'someclass');
	 *
	 * // Add a class to an element by id inside the editor
	 * tinyMCE.activeEditor.dom.addClass('someid', 'someclass');
	 */
	tinymce.create('tinymce.dom.DOMUtils', {
		doc : null,
		root : null,
		files : null,
		pixelStyles : /^(top|left|bottom|right|width|height|borderWidth)$/,
		props : {
			"for" : "htmlFor",
			"class" : "className",
			className : "className",
			checked : "checked",
			disabled : "disabled",
			maxlength : "maxLength",
			readonly : "readOnly",
			selected : "selected",
			value : "value",
			id : "id",
			name : "name",
			type : "type"
		},

		/**
		 * Constructs a new DOMUtils instance. Consult the Wiki for more details on settings etc for this class.
		 *
		 * @constructor
		 * @method DOMUtils
		 * @param {Document} d Document reference to bind the utility class to.
		 * @param {settings} s Optional settings collection.
		 */
		DOMUtils : function(d, s) {
			var t = this, globalStyle, name;

			t.doc = d;
			t.win = window;
			t.files = {};
			t.cssFlicker = false;
			t.counter = 0;
			t.stdMode = !tinymce.isIE || d.documentMode >= 8;
			t.boxModel = !tinymce.isIE || d.compatMode == "CSS1Compat" || t.stdMode;
			t.hasOuterHTML = "outerHTML" in d.createElement("a");

			t.settings = s = tinymce.extend({
				keep_values : false,
				hex_colors : 1
			}, s);

			t.schema = s.schema;
			t.styles = new tinymce.html.Styles({
				url_converter : s.url_converter,
				url_converter_scope : s.url_converter_scope
			}, s.schema);

			// Fix IE6SP2 flicker and check it failed for pre SP2
			if (tinymce.isIE6) {
				try {
					d.execCommand('BackgroundImageCache', false, true);
				} catch (e) {
					t.cssFlicker = true;
				}
			}

			if (isIE && s.schema) {
				// Add missing HTML 4/5 elements to IE
				('abbr article aside audio canvas ' +
				'details figcaption figure footer ' +
				'header hgroup mark menu meter nav ' +
				'output progress section summary ' +
				'time video').replace(/\w+/g, function(name) {
					d.createElement(name);
				});

				// Create all custom elements
				for (name in s.schema.getCustomElements()) {
					d.createElement(name);
				}
			}

			tinymce.addUnload(t.destroy, t);
		},

		/**
		 * Returns the root node of the document this is normally the body but might be a DIV. Parents like getParent will not
		 * go above the point of this root node.
		 *
		 * @method getRoot
		 * @return {Element} Root element for the utility class.
		 */
		getRoot : function() {
			var t = this, s = t.settings;

			return (s && t.get(s.root_element)) || t.doc.body;
		},

		/**
		 * Returns the viewport of the window.
		 *
		 * @method getViewPort
		 * @param {Window} w Optional window to get viewport of.
		 * @return {Object} Viewport object with fields x, y, w and h.
		 */
		getViewPort : function(w) {
			var d, b;

			w = !w ? this.win : w;
			d = w.document;
			b = this.boxModel ? d.documentElement : d.body;

			// Returns viewport size excluding scrollbars
			return {
				x : w.pageXOffset || b.scrollLeft,
				y : w.pageYOffset || b.scrollTop,
				w : w.innerWidth || b.clientWidth,
				h : w.innerHeight || b.clientHeight
			};
		},

		/**
		 * Returns the rectangle for a specific element.
		 *
		 * @method getRect
		 * @param {Element/String} e Element object or element ID to get rectange from.
		 * @return {object} Rectange for specified element object with x, y, w, h fields.
		 */
		getRect : function(e) {
			var p, t = this, sr;

			e = t.get(e);
			p = t.getPos(e);
			sr = t.getSize(e);

			return {
				x : p.x,
				y : p.y,
				w : sr.w,
				h : sr.h
			};
		},

		/**
		 * Returns the size dimensions of the specified element.
		 *
		 * @method getSize
		 * @param {Element/String} e Element object or element ID to get rectange from.
		 * @return {object} Rectange for specified element object with w, h fields.
		 */
		getSize : function(e) {
			var t = this, w, h;

			e = t.get(e);
			w = t.getStyle(e, 'width');
			h = t.getStyle(e, 'height');

			// Non pixel value, then force offset/clientWidth
			if (w.indexOf('px') === -1)
				w = 0;

			// Non pixel value, then force offset/clientWidth
			if (h.indexOf('px') === -1)
				h = 0;

			return {
				w : parseInt(w) || e.offsetWidth || e.clientWidth,
				h : parseInt(h) || e.offsetHeight || e.clientHeight
			};
		},

		/**
		 * Returns a node by the specified selector function. This function will
		 * loop through all parent nodes and call the specified function for each node.
		 * If the function then returns true indicating that it has found what it was looking for, the loop execution will then end
		 * and the node it found will be returned.
		 *
		 * @method getParent
		 * @param {Node/String} n DOM node to search parents on or ID string.
		 * @param {function} f Selection function to execute on each node or CSS pattern.
		 * @param {Node} r Optional root element, never go below this point.
		 * @return {Node} DOM Node or null if it wasn't found.
		 */
		getParent : function(n, f, r) {
			return this.getParents(n, f, r, false);
		},

		/**
		 * Returns a node list of all parents matching the specified selector function or pattern.
		 * If the function then returns true indicating that it has found what it was looking for and that node will be collected.
		 *
		 * @method getParents
		 * @param {Node/String} n DOM node to search parents on or ID string.
		 * @param {function} f Selection function to execute on each node or CSS pattern.
		 * @param {Node} r Optional root element, never go below this point.
		 * @return {Array} Array of nodes or null if it wasn't found.
		 */
		getParents : function(n, f, r, c) {
			var t = this, na, se = t.settings, o = [];

			n = t.get(n);
			c = c === undefined;

			if (se.strict_root)
				r = r || t.getRoot();

			// Wrap node name as func
			if (is(f, 'string')) {
				na = f;

				if (f === '*') {
					f = function(n) {return n.nodeType == 1;};
				} else {
					f = function(n) {
						return t.is(n, na);
					};
				}
			}

			while (n) {
				if (n == r || !n.nodeType || n.nodeType === 9)
					break;

				if (!f || f(n)) {
					if (c)
						o.push(n);
					else
						return n;
				}

				n = n.parentNode;
			}

			return c ? o : null;
		},

		/**
		 * Returns the specified element by ID or the input element if it isn't a string.
		 *
		 * @method get
		 * @param {String/Element} n Element id to look for or element to just pass though.
		 * @return {Element} Element matching the specified id or null if it wasn't found.
		 */
		get : function(e) {
			var n;

			if (e && this.doc && typeof(e) == 'string') {
				n = e;
				e = this.doc.getElementById(e);

				// IE and Opera returns meta elements when they match the specified input ID, but getElementsByName seems to do the trick
				if (e && e.id !== n)
					return this.doc.getElementsByName(n)[1];
			}

			return e;
		},

		/**
		 * Returns the next node that matches selector or function
		 *
		 * @method getNext
		 * @param {Node} node Node to find siblings from.
		 * @param {String/function} selector Selector CSS expression or function.
		 * @return {Node} Next node item matching the selector or null if it wasn't found.
		 */
		getNext : function(node, selector) {
			return this._findSib(node, selector, 'nextSibling');
		},

		/**
		 * Returns the previous node that matches selector or function
		 *
		 * @method getPrev
		 * @param {Node} node Node to find siblings from.
		 * @param {String/function} selector Selector CSS expression or function.
		 * @return {Node} Previous node item matching the selector or null if it wasn't found.
		 */
		getPrev : function(node, selector) {
			return this._findSib(node, selector, 'previousSibling');
		},

		// #ifndef jquery

		/**
		 * Selects specific elements by a CSS level 3 pattern. For example "div#a1 p.test".
		 * This function is optimized for the most common patterns needed in TinyMCE but it also performes good enough
		 * on more complex patterns.
		 *
		 * @method select
		 * @param {String} p CSS level 1 pattern to select/find elements by.
		 * @param {Object} s Optional root element/scope element to search in.
		 * @return {Array} Array with all matched elements.
		 * @example
		 * // Adds a class to all paragraphs in the currently active editor
		 * tinyMCE.activeEditor.dom.addClass(tinyMCE.activeEditor.dom.select('p'), 'someclass');
		 *
		 * // Adds a class to all spans that has the test class in the currently active editor
		 * tinyMCE.activeEditor.dom.addClass(tinyMCE.activeEditor.dom.select('span.test'), 'someclass')
		 */
		select : function(pa, s) {
			var t = this;

			return tinymce.dom.Sizzle(pa, t.get(s) || t.get(t.settings.root_element) || t.doc, []);
		},

		/**
		 * Returns true/false if the specified element matches the specified css pattern.
		 *
		 * @method is
		 * @param {Node/NodeList} n DOM node to match or an array of nodes to match.
		 * @param {String} selector CSS pattern to match the element agains.
		 */
		is : function(n, selector) {
			var i;

			// If it isn't an array then try to do some simple selectors instead of Sizzle for to boost performance
			if (n.length === undefined) {
				// Simple all selector
				if (selector === '*')
					return n.nodeType == 1;

				// Simple selector just elements
				if (simpleSelectorRe.test(selector)) {
					selector = selector.toLowerCase().split(/,/);
					n = n.nodeName.toLowerCase();

					for (i = selector.length - 1; i >= 0; i--) {
						if (selector[i] == n)
							return true;
					}

					return false;
				}
			}

			return tinymce.dom.Sizzle.matches(selector, n.nodeType ? [n] : n).length > 0;
		},

		// #endif

		/**
		 * Adds the specified element to another element or elements.
		 *
		 * @method add
		 * @param {String/Element/Array} Element id string, DOM node element or array of id's or elements to add to.
		 * @param {String/Element} n Name of new element to add or existing element to add.
		 * @param {Object} a Optional object collection with arguments to add to the new element(s).
		 * @param {String} h Optional inner HTML contents to add for each element.
		 * @param {Boolean} c Optional internal state to indicate if it should create or add.
		 * @return {Element/Array} Element that got created or array with elements if multiple elements where passed.
		 * @example
		 * // Adds a new paragraph to the end of the active editor
		 * tinyMCE.activeEditor.dom.add(tinyMCE.activeEditor.getBody(), 'p', {title : 'my title'}, 'Some content');
		 */
		add : function(p, n, a, h, c) {
			var t = this;

			return this.run(p, function(p) {
				var e, k;

				e = is(n, 'string') ? t.doc.createElement(n) : n;
				t.setAttribs(e, a);

				if (h) {
					if (h.nodeType)
						e.appendChild(h);
					else
						t.setHTML(e, h);
				}

				return !c ? p.appendChild(e) : e;
			});
		},

		/**
		 * Creates a new element.
		 *
		 * @method create
		 * @param {String} n Name of new element.
		 * @param {Object} a Optional object name/value collection with element attributes.
		 * @param {String} h Optional HTML string to set as inner HTML of the element.
		 * @return {Element} HTML DOM node element that got created.
		 * @example
		 * // Adds an element where the caret/selection is in the active editor
		 * var el = tinyMCE.activeEditor.dom.create('div', {id : 'test', 'class' : 'myclass'}, 'some content');
		 * tinyMCE.activeEditor.selection.setNode(el);
		 */
		create : function(n, a, h) {
			return this.add(this.doc.createElement(n), n, a, h, 1);
		},

		/**
		 * Create HTML string for element. The element will be closed unless an empty inner HTML string is passed.
		 *
		 * @method createHTML
		 * @param {String} n Name of new element.
		 * @param {Object} a Optional object name/value collection with element attributes.
		 * @param {String} h Optional HTML string to set as inner HTML of the element.
		 * @return {String} String with new HTML element like for example: <a href="#">test</a>.
		 * @example
		 * // Creates a html chunk and inserts it at the current selection/caret location
		 * tinyMCE.activeEditor.selection.setContent(tinyMCE.activeEditor.dom.createHTML('a', {href : 'test.html'}, 'some line'));
		 */
		createHTML : function(n, a, h) {
			var o = '', t = this, k;

			o += '<' + n;

			for (k in a) {
				if (a.hasOwnProperty(k))
					o += ' ' + k + '="' + t.encode(a[k]) + '"';
			}

			// A call to tinymce.is doesn't work for some odd reason on IE9 possible bug inside their JS runtime
			if (typeof(h) != "undefined")
				return o + '>' + h + '</' + n + '>';

			return o + ' />';
		},

		/**
		 * Removes/deletes the specified element(s) from the DOM.
		 *
		 * @method remove
		 * @param {String/Element/Array} node ID of element or DOM element object or array containing multiple elements/ids.
		 * @param {Boolean} keep_children Optional state to keep children or not. If set to true all children will be placed at the location of the removed element.
		 * @return {Element/Array} HTML DOM element that got removed or array of elements depending on input.
		 * @example
		 * // Removes all paragraphs in the active editor
		 * tinyMCE.activeEditor.dom.remove(tinyMCE.activeEditor.dom.select('p'));
		 *
		 * // Removes a element by id in the document
		 * tinyMCE.DOM.remove('mydiv');
		 */
		remove : function(node, keep_children) {
			return this.run(node, function(node) {
				var child, parent = node.parentNode;

				if (!parent)
					return null;

				if (keep_children) {
					while (child = node.firstChild) {
						// IE 8 will crash if you don't remove completely empty text nodes
						if (!tinymce.isIE || child.nodeType !== 3 || child.nodeValue)
							parent.insertBefore(child, node);
						else
							node.removeChild(child);
					}
				}

				return parent.removeChild(node);
			});
		},

		/**
		 * Sets the CSS style value on a HTML element. The name can be a camelcase string
		 * or the CSS style name like background-color.
		 *
		 * @method setStyle
		 * @param {String/Element/Array} n HTML element/Element ID or Array of elements/ids to set CSS style value on.
		 * @param {String} na Name of the style value to set.
		 * @param {String} v Value to set on the style.
		 * @example
		 * // Sets a style value on all paragraphs in the currently active editor
		 * tinyMCE.activeEditor.dom.setStyle(tinyMCE.activeEditor.dom.select('p'), 'background-color', 'red');
		 *
		 * // Sets a style value to an element by id in the current document
		 * tinyMCE.DOM.setStyle('mydiv', 'background-color', 'red');
		 */
		setStyle : function(n, na, v) {
			var t = this;

			return t.run(n, function(e) {
				var s, i;

				s = e.style;

				// Camelcase it, if needed
				na = na.replace(/-(\D)/g, function(a, b){
					return b.toUpperCase();
				});

				// Default px suffix on these
				if (t.pixelStyles.test(na) && (tinymce.is(v, 'number') || /^[\-0-9\.]+$/.test(v)))
					v += 'px';

				switch (na) {
					case 'opacity':
						// IE specific opacity
						if (isIE) {
							s.filter = v === '' ? '' : "alpha(opacity=" + (v * 100) + ")";

							if (!n.currentStyle || !n.currentStyle.hasLayout)
								s.display = 'inline-block';
						}

						// Fix for older browsers
						s[na] = s['-moz-opacity'] = s['-khtml-opacity'] = v || '';
						break;

					case 'float':
						isIE ? s.styleFloat = v : s.cssFloat = v;
						break;

					default:
						s[na] = v || '';
				}

				// Force update of the style data
				if (t.settings.update_styles)
					t.setAttrib(e, 'data-mce-style');
			});
		},

		/**
		 * Returns the current style or runtime/computed value of a element.
		 *
		 * @method getStyle
		 * @param {String/Element} n HTML element or element id string to get style from.
		 * @param {String} na Style name to return.
		 * @param {Boolean} c Computed style.
		 * @return {String} Current style or computed style value of a element.
		 */
		getStyle : function(n, na, c) {
			n = this.get(n);

			if (!n)
				return;

			// Gecko
			if (this.doc.defaultView && c) {
				// Remove camelcase
				na = na.replace(/[A-Z]/g, function(a){
					return '-' + a;
				});

				try {
					return this.doc.defaultView.getComputedStyle(n, null).getPropertyValue(na);
				} catch (ex) {
					// Old safari might fail
					return null;
				}
			}

			// Camelcase it, if needed
			na = na.replace(/-(\D)/g, function(a, b){
				return b.toUpperCase();
			});

			if (na == 'float')
				na = isIE ? 'styleFloat' : 'cssFloat';

			// IE & Opera
			if (n.currentStyle && c)
				return n.currentStyle[na];

			return n.style ? n.style[na] : undefined;
		},

		/**
		 * Sets multiple styles on the specified element(s).
		 *
		 * @method setStyles
		 * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set styles on.
		 * @param {Object} o Name/Value collection of style items to add to the element(s).
		 * @example
		 * // Sets styles on all paragraphs in the currently active editor
		 * tinyMCE.activeEditor.dom.setStyles(tinyMCE.activeEditor.dom.select('p'), {'background-color' : 'red', 'color' : 'green'});
		 *
		 * // Sets styles to an element by id in the current document
		 * tinyMCE.DOM.setStyles('mydiv', {'background-color' : 'red', 'color' : 'green'});
		 */
		setStyles : function(e, o) {
			var t = this, s = t.settings, ol;

			ol = s.update_styles;
			s.update_styles = 0;

			each(o, function(v, n) {
				t.setStyle(e, n, v);
			});

			// Update style info
			s.update_styles = ol;
			if (s.update_styles)
				t.setAttrib(e, s.cssText);
		},

		/**
		 * Removes all attributes from an element or elements.
		 *
		 * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to remove attributes from.
		 */
		removeAllAttribs: function(e) {
			return this.run(e, function(e) {
				var i, attrs = e.attributes;
				for (i = attrs.length - 1; i >= 0; i--) {
					e.removeAttributeNode(attrs.item(i));
				}
			});
		},

		/**
		 * Sets the specified attributes value of a element or elements.
		 *
		 * @method setAttrib
		 * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set attribute on.
		 * @param {String} n Name of attribute to set.
		 * @param {String} v Value to set on the attribute of this value is falsy like null 0 or '' it will remove the attribute instead.
		 * @example
		 * // Sets an attribute to all paragraphs in the active editor
		 * tinyMCE.activeEditor.dom.setAttrib(tinyMCE.activeEditor.dom.select('p'), 'class', 'myclass');
		 *
		 * // Sets an attribute to a specific element in the current page
		 * tinyMCE.dom.setAttrib('mydiv', 'class', 'myclass');
		 */
		setAttrib : function(e, n, v) {
			var t = this;

			// Whats the point
			if (!e || !n)
				return;

			// Strict XML mode
			if (t.settings.strict)
				n = n.toLowerCase();

			return this.run(e, function(e) {
				var s = t.settings;

				switch (n) {
					case "style":
						if (!is(v, 'string')) {
							each(v, function(v, n) {
								t.setStyle(e, n, v);
							});

							return;
						}

						// No mce_style for elements with these since they might get resized by the user
						if (s.keep_values) {
							if (v && !t._isRes(v))
								e.setAttribute('data-mce-style', v, 2);
							else
								e.removeAttribute('data-mce-style', 2);
						}

						e.style.cssText = v;
						break;

					case "class":
						e.className = v || ''; // Fix IE null bug
						break;

					case "src":
					case "href":
						if (s.keep_values) {
							if (s.url_converter)
								v = s.url_converter.call(s.url_converter_scope || t, v, n, e);

							t.setAttrib(e, 'data-mce-' + n, v, 2);
						}

						break;

					case "shape":
						e.setAttribute('data-mce-style', v);
						break;
				}

				if (is(v) && v !== null && v.length !== 0)
					e.setAttribute(n, '' + v, 2);
				else
					e.removeAttribute(n, 2);
			});
		},

		/**
		 * Sets the specified attributes of a element or elements.
		 *
		 * @method setAttribs
		 * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set attributes on.
		 * @param {Object} o Name/Value collection of attribute items to add to the element(s).
		 * @example
		 * // Sets some attributes to all paragraphs in the active editor
		 * tinyMCE.activeEditor.dom.setAttribs(tinyMCE.activeEditor.dom.select('p'), {'class' : 'myclass', title : 'some title'});
		 *
		 * // Sets some attributes to a specific element in the current page
		 * tinyMCE.DOM.setAttribs('mydiv', {'class' : 'myclass', title : 'some title'});
		 */
		setAttribs : function(e, o) {
			var t = this;

			return this.run(e, function(e) {
				each(o, function(v, n) {
					t.setAttrib(e, n, v);
				});
			});
		},

		/**
		 * Returns the specified attribute by name.
		 *
		 * @method getAttrib
		 * @param {String/Element} e Element string id or DOM element to get attribute from.
		 * @param {String} n Name of attribute to get.
		 * @param {String} dv Optional default value to return if the attribute didn't exist.
		 * @return {String} Attribute value string, default value or null if the attribute wasn't found.
		 */
		getAttrib : function(e, n, dv) {
			var v, t = this, undef;

			e = t.get(e);

			if (!e || e.nodeType !== 1)
				return dv === undef ? false : dv;

			if (!is(dv))
				dv = '';

			// Try the mce variant for these
			if (/^(src|href|style|coords|shape)$/.test(n)) {
				v = e.getAttribute("data-mce-" + n);

				if (v)
					return v;
			}

			if (isIE && t.props[n]) {
				v = e[t.props[n]];
				v = v && v.nodeValue ? v.nodeValue : v;
			}

			if (!v)
				v = e.getAttribute(n, 2);

			// Check boolean attribs
			if (/^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noshade|nowrap|readonly|selected)$/.test(n)) {
				if (e[t.props[n]] === true && v === '')
					return n;

				return v ? n : '';
			}

			// Inner input elements will override attributes on form elements
			if (e.nodeName === "FORM" && e.getAttributeNode(n))
				return e.getAttributeNode(n).nodeValue;

			if (n === 'style') {
				v = v || e.style.cssText;

				if (v) {
					v = t.serializeStyle(t.parseStyle(v), e.nodeName);

					if (t.settings.keep_values && !t._isRes(v))
						e.setAttribute('data-mce-style', v);
				}
			}

			// Remove Apple and WebKit stuff
			if (isWebKit && n === "class" && v)
				v = v.replace(/(apple|webkit)\-[a-z\-]+/gi, '');

			// Handle IE issues
			if (isIE) {
				switch (n) {
					case 'rowspan':
					case 'colspan':
						// IE returns 1 as default value
						if (v === 1)
							v = '';

						break;

					case 'size':
						// IE returns +0 as default value for size
						if (v === '+0' || v === 20 || v === 0)
							v = '';

						break;

					case 'width':
					case 'height':
					case 'vspace':
					case 'checked':
					case 'disabled':
					case 'readonly':
						if (v === 0)
							v = '';

						break;

					case 'hspace':
						// IE returns -1 as default value
						if (v === -1)
							v = '';

						break;

					case 'maxlength':
					case 'tabindex':
						// IE returns default value
						if (v === 32768 || v === 2147483647 || v === '32768')
							v = '';

						break;

					case 'multiple':
					case 'compact':
					case 'noshade':
					case 'nowrap':
						if (v === 65535)
							return n;

						return dv;

					case 'shape':
						v = v.toLowerCase();
						break;

					default:
						// IE has odd anonymous function for event attributes
						if (n.indexOf('on') === 0 && v)
							v = tinymce._replace(/^function\s+\w+\(\)\s+\{\s+(.*)\s+\}$/, '$1', '' + v);
				}
			}

			return (v !== undef && v !== null && v !== '') ? '' + v : dv;
		},

		/**
		 * Returns the absolute x, y position of a node. The position will be returned in a object with x, y fields.
		 *
		 * @method getPos
		 * @param {Element/String} n HTML element or element id to get x, y position from.
		 * @param {Element} ro Optional root element to stop calculations at.
		 * @return {object} Absolute position of the specified element object with x, y fields.
		 */
		getPos : function(n, ro) {
			var t = this, x = 0, y = 0, e, d = t.doc, r;

			n = t.get(n);
			ro = ro || d.body;

			if (n) {
				// Use getBoundingClientRect if it exists since it's faster than looping offset nodes
				if (n.getBoundingClientRect) {
					n = n.getBoundingClientRect();
					e = t.boxModel ? d.documentElement : d.body;

					// Add scroll offsets from documentElement or body since IE with the wrong box model will use d.body and so do WebKit
					// Also remove the body/documentelement clientTop/clientLeft on IE 6, 7 since they offset the position
					x = n.left + (d.documentElement.scrollLeft || d.body.scrollLeft) - e.clientTop;
					y = n.top + (d.documentElement.scrollTop || d.body.scrollTop) - e.clientLeft;

					return {x : x, y : y};
				}

				r = n;
				while (r && r != ro && r.nodeType) {
					x += r.offsetLeft || 0;
					y += r.offsetTop || 0;
					r = r.offsetParent;
				}

				r = n.parentNode;
				while (r && r != ro && r.nodeType) {
					x -= r.scrollLeft || 0;
					y -= r.scrollTop || 0;
					r = r.parentNode;
				}
			}

			return {x : x, y : y};
		},

		/**
		 * Parses the specified style value into an object collection. This parser will also
		 * merge and remove any redundant items that browsers might have added. It will also convert non hex
		 * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
		 *
		 * @method parseStyle
		 * @param {String} st Style value to parse for example: border:1px solid red;.
		 * @return {Object} Object representation of that style like {border : '1px solid red'}
		 */
		parseStyle : function(st) {
			return this.styles.parse(st);
		},

		/**
		 * Serializes the specified style object into a string.
		 *
		 * @method serializeStyle
		 * @param {Object} o Object to serialize as string for example: {border : '1px solid red'}
		 * @param {String} name Optional element name.
		 * @return {String} String representation of the style object for example: border: 1px solid red.
		 */
		serializeStyle : function(o, name) {
			return this.styles.serialize(o, name);
		},

		/**
		 * Imports/loads the specified CSS file into the document bound to the class.
		 *
		 * @method loadCSS
		 * @param {String} u URL to CSS file to load.
		 * @example
		 * // Loads a CSS file dynamically into the current document
		 * tinymce.DOM.loadCSS('somepath/some.css');
		 *
		 * // Loads a CSS file into the currently active editor instance
		 * tinyMCE.activeEditor.dom.loadCSS('somepath/some.css');
		 *
		 * // Loads a CSS file into an editor instance by id
		 * tinyMCE.get('someid').dom.loadCSS('somepath/some.css');
		 *
		 * // Loads multiple CSS files into the current document
		 * tinymce.DOM.loadCSS('somepath/some.css,somepath/someother.css');
		 */
		loadCSS : function(u) {
			var t = this, d = t.doc, head;

			if (!u)
				u = '';

			head = t.select('head')[0];

			each(u.split(','), function(u) {
				var link;

				if (t.files[u])
					return;

				t.files[u] = true;
				link = t.create('link', {rel : 'stylesheet', href : tinymce._addVer(u)});

				// IE 8 has a bug where dynamically loading stylesheets would produce a 1 item remaining bug
				// This fix seems to resolve that issue by realcing the document ones a stylesheet finishes loading
				// It's ugly but it seems to work fine.
				if (isIE && d.documentMode && d.recalc) {
					link.onload = function() {
						if (d.recalc)
							d.recalc();

						link.onload = null;
					};
				}

				head.appendChild(link);
			});
		},

		/**
		 * Adds a class to the specified element or elements.
		 *
		 * @method addClass
		 * @param {String/Element/Array} Element ID string or DOM element or array with elements or IDs.
		 * @param {String} c Class name to add to each element.
		 * @return {String/Array} String with new class value or array with new class values for all elements.
		 * @example
		 * // Adds a class to all paragraphs in the active editor
		 * tinyMCE.activeEditor.dom.addClass(tinyMCE.activeEditor.dom.select('p'), 'myclass');
		 *
		 * // Adds a class to a specific element in the current page
		 * tinyMCE.DOM.addClass('mydiv', 'myclass');
		 */
		addClass : function(e, c) {
			return this.run(e, function(e) {
				var o;

				if (!c)
					return 0;

				if (this.hasClass(e, c))
					return e.className;

				o = this.removeClass(e, c);

				return e.className = (o != '' ? (o + ' ') : '') + c;
			});
		},

		/**
		 * Removes a class from the specified element or elements.
		 *
		 * @method removeClass
		 * @param {String/Element/Array} Element ID string or DOM element or array with elements or IDs.
		 * @param {String} c Class name to remove to each element.
		 * @return {String/Array} String with new class value or array with new class values for all elements.
		 * @example
		 * // Removes a class from all paragraphs in the active editor
		 * tinyMCE.activeEditor.dom.removeClass(tinyMCE.activeEditor.dom.select('p'), 'myclass');
		 *
		 * // Removes a class from a specific element in the current page
		 * tinyMCE.DOM.removeClass('mydiv', 'myclass');
		 */
		removeClass : function(e, c) {
			var t = this, re;

			return t.run(e, function(e) {
				var v;

				if (t.hasClass(e, c)) {
					if (!re)
						re = new RegExp("(^|\\s+)" + c + "(\\s+|$)", "g");

					v = e.className.replace(re, ' ');
					v = tinymce.trim(v != ' ' ? v : '');

					e.className = v;

					// Empty class attr
					if (!v) {
						e.removeAttribute('class');
						e.removeAttribute('className');
					}

					return v;
				}

				return e.className;
			});
		},

		/**
		 * Returns true if the specified element has the specified class.
		 *
		 * @method hasClass
		 * @param {String/Element} n HTML element or element id string to check CSS class on.
		 * @param {String} c CSS class to check for.
		 * @return {Boolean} true/false if the specified element has the specified class.
		 */
		hasClass : function(n, c) {
			n = this.get(n);

			if (!n || !c)
				return false;

			return (' ' + n.className + ' ').indexOf(' ' + c + ' ') !== -1;
		},

		/**
		 * Shows the specified element(s) by ID by setting the "display" style.
		 *
		 * @method show
		 * @param {String/Element/Array} e ID of DOM element or DOM element or array with elements or IDs to show.
		 */
		show : function(e) {
			return this.setStyle(e, 'display', 'block');
		},

		/**
		 * Hides the specified element(s) by ID by setting the "display" style.
		 *
		 * @method hide
		 * @param {String/Element/Array} e ID of DOM element or DOM element or array with elements or IDs to hide.
		 * @example
		 * // Hides a element by id in the document
		 * tinymce.DOM.hide('myid');
		 */
		hide : function(e) {
			return this.setStyle(e, 'display', 'none');
		},

		/**
		 * Returns true/false if the element is hidden or not by checking the "display" style.
		 *
		 * @method isHidden
		 * @param {String/Element} e Id or element to check display state on.
		 * @return {Boolean} true/false if the element is hidden or not.
		 */
		isHidden : function(e) {
			e = this.get(e);

			return !e || e.style.display == 'none' || this.getStyle(e, 'display') == 'none';
		},

		/**
		 * Returns a unique id. This can be useful when generating elements on the fly.
		 * This method will not check if the element allready exists.
		 *
		 * @method uniqueId
		 * @param {String} p Optional prefix to add infront of all ids defaults to "mce_".
		 * @return {String} Unique id.
		 */
		uniqueId : function(p) {
			return (!p ? 'mce_' : p) + (this.counter++);
		},

		/**
		 * Sets the specified HTML content inside the element or elements. The HTML will first be processed this means
		 * URLs will get converted, hex color values fixed etc. Check processHTML for details.
		 *
		 * @method setHTML
		 * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set HTML inside.
		 * @param {String} h HTML content to set as inner HTML of the element.
		 * @example
		 * // Sets the inner HTML of all paragraphs in the active editor
		 * tinyMCE.activeEditor.dom.setHTML(tinyMCE.activeEditor.dom.select('p'), 'some inner html');
		 *
		 * // Sets the inner HTML of a element by id in the document
		 * tinyMCE.DOM.setHTML('mydiv', 'some inner html');
		 */
		setHTML : function(element, html) {
			var self = this;

			return self.run(element, function(element) {
				if (isIE) {
					// Remove all child nodes, IE keeps empty text nodes in DOM
					while (element.firstChild)
						element.removeChild(element.firstChild);

					try {
						// IE will remove comments from the beginning
						// unless you padd the contents with something
						element.innerHTML = '<br />' + html;
						element.removeChild(element.firstChild);
					} catch (ex) {
						// IE sometimes produces an unknown runtime error on innerHTML if it's an block element within a block element for example a div inside a p
						// This seems to fix this problem

						// Create new div with HTML contents and a BR infront to keep comments
						element = self.create('div');
						element.innerHTML = '<br />' + html;

						// Add all children from div to target
						each (element.childNodes, function(node, i) {
							// Skip br element
							if (i)
								element.appendChild(node);
						});
					}
				} else
					element.innerHTML = html;

				return html;
			});
		},

		/**
		 * Returns the outer HTML of an element.
		 *
		 * @method getOuterHTML
		 * @param {String/Element} elm Element ID or element object to get outer HTML from.
		 * @return {String} Outer HTML string.
		 * @example
		 * tinymce.DOM.getOuterHTML(editorElement);
		 * tinyMCE.activeEditor.getOuterHTML(tinyMCE.activeEditor.getBody());
		 */
		getOuterHTML : function(elm) {
			var doc, self = this;

			elm = self.get(elm);

			if (!elm)
				return null;

			if (elm.nodeType === 1 && self.hasOuterHTML)
				return elm.outerHTML;

			doc = (elm.ownerDocument || self.doc).createElement("body");
			doc.appendChild(elm.cloneNode(true));

			return doc.innerHTML;
		},

		/**
		 * Sets the specified outer HTML on a element or elements.
		 *
		 * @method setOuterHTML
		 * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set outer HTML on.
		 * @param {Object} h HTML code to set as outer value for the element.
		 * @param {Document} d Optional document scope to use in this process defaults to the document of the DOM class.
		 * @example
		 * // Sets the outer HTML of all paragraphs in the active editor
		 * tinyMCE.activeEditor.dom.setOuterHTML(tinyMCE.activeEditor.dom.select('p'), '<div>some html</div>');
		 *
		 * // Sets the outer HTML of a element by id in the document
		 * tinyMCE.DOM.setOuterHTML('mydiv', '<div>some html</div>');
		 */
		setOuterHTML : function(e, h, d) {
			var t = this;

			function setHTML(e, h, d) {
				var n, tp;

				tp = d.createElement("body");
				tp.innerHTML = h;

				n = tp.lastChild;
				while (n) {
					t.insertAfter(n.cloneNode(true), e);
					n = n.previousSibling;
				}

				t.remove(e);
			};

			return this.run(e, function(e) {
				e = t.get(e);

				// Only set HTML on elements
				if (e.nodeType == 1) {
					d = d || e.ownerDocument || t.doc;

					if (isIE) {
						try {
							// Try outerHTML for IE it sometimes produces an unknown runtime error
							if (isIE && e.nodeType == 1)
								e.outerHTML = h;
							else
								setHTML(e, h, d);
						} catch (ex) {
							// Fix for unknown runtime error
							setHTML(e, h, d);
						}
					} else
						setHTML(e, h, d);
				}
			});
		},

		/**
		 * Entity decode a string, resolves any HTML entities like &aring;.
		 *
		 * @method decode
		 * @param {String} s String to decode entities on.
		 * @return {String} Entity decoded string.
		 */
		decode : Entities.decode,

		/**
		 * Entity encodes a string, encodes the most common entities <>"& into entities.
		 *
		 * @method encode
		 * @param {String} text String to encode with entities.
		 * @return {String} Entity encoded string.
		 */
		encode : Entities.encodeAllRaw,

		/**
		 * Inserts a element after the reference element.
		 *
		 * @method insertAfter
		 * @param {Element} node Element to insert after the reference.
		 * @param {Element/String/Array} reference_node Reference element, element id or array of elements to insert after.
		 * @return {Element/Array} Element that got added or an array with elements.
		 */
		insertAfter : function(node, reference_node) {
			reference_node = this.get(reference_node);

			return this.run(node, function(node) {
				var parent, nextSibling;

				parent = reference_node.parentNode;
				nextSibling = reference_node.nextSibling;

				if (nextSibling)
					parent.insertBefore(node, nextSibling);
				else
					parent.appendChild(node);

				return node;
			});
		},

		/**
		 * Returns true/false if the specified element is a block element or not.
		 *
		 * @method isBlock
		 * @param {Node/String} node Element/Node to check.
		 * @return {Boolean} True/False state if the node is a block element or not.
		 */
		isBlock : function(node) {
			var type = node.nodeType;

			// If it's a node then check the type and use the nodeName
			if (type)
				return !!(type === 1 && blockElementsMap[node.nodeName]);

			return !!blockElementsMap[node];
		},

		/**
		 * Replaces the specified element or elements with the specified element, the new element will
		 * be cloned if multiple inputs elements are passed.
		 *
		 * @method replace
		 * @param {Element} n New element to replace old ones with.
		 * @param {Element/String/Array} o Element DOM node, element id or array of elements or ids to replace.
		 * @param {Boolean} k Optional keep children state, if set to true child nodes from the old object will be added to new ones.
		 */
		replace : function(n, o, k) {
			var t = this;

			if (is(o, 'array'))
				n = n.cloneNode(true);

			return t.run(o, function(o) {
				if (k) {
					each(tinymce.grep(o.childNodes), function(c) {
						n.appendChild(c);
					});
				}

				return o.parentNode.replaceChild(n, o);
			});
		},

		/**
		 * Renames the specified element to a new name and keep it's attributes and children.
		 *
		 * @method rename
		 * @param {Element} elm Element to rename.
		 * @param {String} name Name of the new element.
		 * @return New element or the old element if it needed renaming.
		 */
		rename : function(elm, name) {
			var t = this, newElm;

			if (elm.nodeName != name.toUpperCase()) {
				// Rename block element
				newElm = t.create(name);

				// Copy attribs to new block
				each(t.getAttribs(elm), function(attr_node) {
					t.setAttrib(newElm, attr_node.nodeName, t.getAttrib(elm, attr_node.nodeName));
				});

				// Replace block
				t.replace(newElm, elm, 1);
			}

			return newElm || elm;
		},

		/**
		 * Find the common ancestor of two elements. This is a shorter method than using the DOM Range logic.
		 *
		 * @method findCommonAncestor
		 * @param {Element} a Element to find common ancestor of.
		 * @param {Element} b Element to find common ancestor of.
		 * @return {Element} Common ancestor element of the two input elements.
		 */
		findCommonAncestor : function(a, b) {
			var ps = a, pe;

			while (ps) {
				pe = b;

				while (pe && ps != pe)
					pe = pe.parentNode;

				if (ps == pe)
					break;

				ps = ps.parentNode;
			}

			if (!ps && a.ownerDocument)
				return a.ownerDocument.documentElement;

			return ps;
		},

		/**
		 * Parses the specified RGB color value and returns a hex version of that color.
		 *
		 * @method toHex
		 * @param {String} s RGB string value like rgb(1,2,3)
		 * @return {String} Hex version of that RGB value like #FF00FF.
		 */
		toHex : function(s) {
			var c = /^\s*rgb\s*?\(\s*?([0-9]+)\s*?,\s*?([0-9]+)\s*?,\s*?([0-9]+)\s*?\)\s*$/i.exec(s);

			function hex(s) {
				s = parseInt(s).toString(16);

				return s.length > 1 ? s : '0' + s; // 0 -> 00
			};

			if (c) {
				s = '#' + hex(c[1]) + hex(c[2]) + hex(c[3]);

				return s;
			}

			return s;
		},

		/**
		 * Returns a array of all single CSS classes in the document. A single CSS class is a simple
		 * rule like ".class" complex ones like "div td.class" will not be added to output.
		 *
		 * @method getClasses
		 * @return {Array} Array with class objects each object has a class field might be other fields in the future.
		 */
		getClasses : function() {
			var t = this, cl = [], i, lo = {}, f = t.settings.class_filter, ov;

			if (t.classes)
				return t.classes;

			function addClasses(s) {
				// IE style imports
				each(s.imports, function(r) {
					addClasses(r);
				});

				each(s.cssRules || s.rules, function(r) {
					// Real type or fake it on IE
					switch (r.type || 1) {
						// Rule
						case 1:
							if (r.selectorText) {
								each(r.selectorText.split(','), function(v) {
									v = v.replace(/^\s*|\s*$|^\s\./g, "");

									// Is internal or it doesn't contain a class
									if (/\.mce/.test(v) || !/\.[\w\-]+$/.test(v))
										return;

									// Remove everything but class name
									ov = v;
									v = tinymce._replace(/.*\.([a-z0-9_\-]+).*/i, '$1', v);

									// Filter classes
									if (f && !(v = f(v, ov)))
										return;

									if (!lo[v]) {
										cl.push({'class' : v});
										lo[v] = 1;
									}
								});
							}
							break;

						// Import
						case 3:
							addClasses(r.styleSheet);
							break;
					}
				});
			};

			try {
				each(t.doc.styleSheets, addClasses);
			} catch (ex) {
				// Ignore
			}

			if (cl.length > 0)
				t.classes = cl;

			return cl;
		},

		/**
		 * Executes the specified function on the element by id or dom element node or array of elements/id.
		 *
		 * @method run
		 * @param {String/Element/Array} Element ID or DOM element object or array with ids or elements.
		 * @param {function} f Function to execute for each item.
		 * @param {Object} s Optional scope to execute the function in.
		 * @return {Object/Array} Single object or array with objects depending on multiple input or not.
		 */
		run : function(e, f, s) {
			var t = this, o;

			if (t.doc && typeof(e) === 'string')
				e = t.get(e);

			if (!e)
				return false;

			s = s || this;
			if (!e.nodeType && (e.length || e.length === 0)) {
				o = [];

				each(e, function(e, i) {
					if (e) {
						if (typeof(e) == 'string')
							e = t.doc.getElementById(e);

						o.push(f.call(s, e, i));
					}
				});

				return o;
			}

			return f.call(s, e);
		},

		/**
		 * Returns an NodeList with attributes for the element.
		 *
		 * @method getAttribs
		 * @param {HTMLElement/string} n Element node or string id to get attributes from.
		 * @return {NodeList} NodeList with attributes.
		 */
		getAttribs : function(n) {
			var o;

			n = this.get(n);

			if (!n)
				return [];

			if (isIE) {
				o = [];

				// Object will throw exception in IE
				if (n.nodeName == 'OBJECT')
					return n.attributes;

				// IE doesn't keep the selected attribute if you clone option elements
				if (n.nodeName === 'OPTION' && this.getAttrib(n, 'selected'))
					o.push({specified : 1, nodeName : 'selected'});

				// It's crazy that this is faster in IE but it's because it returns all attributes all the time
				n.cloneNode(false).outerHTML.replace(/<\/?[\w:\-]+ ?|=[\"][^\"]+\"|=\'[^\']+\'|=[\w\-]+|>/gi, '').replace(/[\w:\-]+/gi, function(a) {
					o.push({specified : 1, nodeName : a});
				});

				return o;
			}

			return n.attributes;
		},

		/**
		 * Returns true/false if the specified node is to be considered empty or not.
		 *
		 * @example
		 * tinymce.DOM.isEmpty(node, {img : true});
		 * @method isEmpty
		 * @param {Object} elements Optional name/value object with elements that are automatically treated as non empty elements.
		 * @return {Boolean} true/false if the node is empty or not.
		 */
		isEmpty : function(node, elements) {
			var self = this, i, attributes, type, walker, name, parentNode;

			node = node.firstChild;
			if (node) {
				walker = new tinymce.dom.TreeWalker(node);
				elements = elements || self.schema ? self.schema.getNonEmptyElements() : null;

				do {
					type = node.nodeType;

					if (type === 1) {
						// Ignore bogus elements
						if (node.getAttribute('data-mce-bogus'))
							continue;

						// Keep empty elements like <img />
						name = node.nodeName.toLowerCase();
						if (elements && elements[name]) {
							// Ignore single BR elements in blocks like <p><br /></p>
							parentNode = node.parentNode;
							if (name === 'br' && self.isBlock(parentNode) && parentNode.firstChild === node && parentNode.lastChild === node) {
								continue;
							}

							return false;
						}

						// Keep elements with data-bookmark attributes or name attribute like <a name="1"></a>
						attributes = self.getAttribs(node);
						i = node.attributes.length;
						while (i--) {
							name = node.attributes[i].nodeName;
							if (name === "name" || name === 'data-mce-bookmark')
								return false;
						}
					}

					// Keep non whitespace text nodes
					if ((type === 3 && !whiteSpaceRegExp.test(node.nodeValue)))
						return false;
				} while (node = walker.next());
			}

			return true;
		},

		/**
		 * Destroys all internal references to the DOM to solve IE leak issues.
		 *
		 * @method destroy
		 */
		destroy : function(s) {
			var t = this;

			if (t.events)
				t.events.destroy();

			t.win = t.doc = t.root = t.events = null;

			// Manual destroy then remove unload handler
			if (!s)
				tinymce.removeUnload(t.destroy);
		},

		/**
		 * Created a new DOM Range object. This will use the native DOM Range API if it's
		 * available if it's not it will fallback to the custom TinyMCE implementation.
		 *
		 * @method createRng
		 * @return {DOMRange} DOM Range object.
		 * @example
		 * var rng = tinymce.DOM.createRng();
		 * alert(rng.startContainer + "," + rng.startOffset);
		 */
		createRng : function() {
			var d = this.doc;

			return d.createRange ? d.createRange() : new tinymce.dom.Range(this);
		},

		/**
		 * Returns the index of the specified node within it's parent.
		 *
		 * @param {Node} node Node to look for.
		 * @param {boolean} normalized Optional true/false state if the index is what it would be after a normalization.
		 * @return {Number} Index of the specified node.
		 */
		nodeIndex : function(node, normalized) {
			var idx = 0, lastNodeType, lastNode, nodeType;

			if (node) {
				for (lastNodeType = node.nodeType, node = node.previousSibling, lastNode = node; node; node = node.previousSibling) {
					nodeType = node.nodeType;

					// Normalize text nodes
					if (normalized && nodeType == 3) {
						if (nodeType == lastNodeType || !node.nodeValue.length)
							continue;
					}
					idx++;
					lastNodeType = nodeType;
				}
			}

			return idx;
		},

		/**
		 * Splits an element into two new elements and places the specified split
		 * element or element between the new ones. For example splitting the paragraph at the bold element in
		 * this example <p>abc<b>abc</b>123</p> would produce <p>abc</p><b>abc</b><p>123</p>.
		 *
		 * @method split
		 * @param {Element} pe Parent element to split.
		 * @param {Element} e Element to split at.
		 * @param {Element} re Optional replacement element to replace the split element by.
		 * @return {Element} Returns the split element or the replacement element if that is specified.
		 */
		split : function(pe, e, re) {
			var t = this, r = t.createRng(), bef, aft, pa;

			// W3C valid browsers tend to leave empty nodes to the left/right side of the contents, this makes sense
			// but we don't want that in our code since it serves no purpose for the end user
			// For example if this is chopped:
			//   <p>text 1<span><b>CHOP</b></span>text 2</p>
			// would produce:
			//   <p>text 1<span></span></p><b>CHOP</b><p><span></span>text 2</p>
			// this function will then trim of empty edges and produce:
			//   <p>text 1</p><b>CHOP</b><p>text 2</p>
			function trim(node) {
				var i, children = node.childNodes, type = node.nodeType;

				if (type == 1 && node.getAttribute('data-mce-type') == 'bookmark')
					return;

				for (i = children.length - 1; i >= 0; i--)
					trim(children[i]);

				if (type != 9) {
					// Keep non whitespace text nodes
					if (type == 3 && node.nodeValue.length > 0) {
						// If parent element isn't a block or there isn't any useful contents for example "<p>   </p>"
						if (!t.isBlock(node.parentNode) || tinymce.trim(node.nodeValue).length > 0)
							return;
					} else if (type == 1) {
						// If the only child is a bookmark then move it up
						children = node.childNodes;
						if (children.length == 1 && children[0] && children[0].nodeType == 1 && children[0].getAttribute('data-mce-type') == 'bookmark')
							node.parentNode.insertBefore(children[0], node);

						// Keep non empty elements or img, hr etc
						if (children.length || /^(br|hr|input|img)$/i.test(node.nodeName))
							return;
					}

					t.remove(node);
				}

				return node;
			};

			if (pe && e) {
				// Get before chunk
				r.setStart(pe.parentNode, t.nodeIndex(pe));
				r.setEnd(e.parentNode, t.nodeIndex(e));
				bef = r.extractContents();

				// Get after chunk
				r = t.createRng();
				r.setStart(e.parentNode, t.nodeIndex(e) + 1);
				r.setEnd(pe.parentNode, t.nodeIndex(pe) + 1);
				aft = r.extractContents();

				// Insert before chunk
				pa = pe.parentNode;
				pa.insertBefore(trim(bef), pe);

				// Insert middle chunk
				if (re)
					pa.replaceChild(re, e);
				else
					pa.insertBefore(e, pe);

				// Insert after chunk
				pa.insertBefore(trim(aft), pe);
				t.remove(pe);

				return re || e;
			}
		},

		/**
		 * Adds an event handler to the specified object.
		 *
		 * @method bind
		 * @param {Element/Document/Window/Array/String} o Object or element id string to add event handler to or an array of elements/ids/documents.
		 * @param {String} n Name of event handler to add for example: click.
		 * @param {function} f Function to execute when the event occurs.
		 * @param {Object} s Optional scope to execute the function in.
		 * @return {function} Function callback handler the same as the one passed in.
		 */
		bind : function(target, name, func, scope) {
			var t = this;

			if (!t.events)
				t.events = new tinymce.dom.EventUtils();

			return t.events.add(target, name, func, scope || this);
		},

		/**
		 * Removes the specified event handler by name and function from a element or collection of elements.
		 *
		 * @method unbind
		 * @param {String/Element/Array} o Element ID string or HTML element or an array of elements or ids to remove handler from.
		 * @param {String} n Event handler name like for example: "click"
		 * @param {function} f Function to remove.
		 * @return {bool/Array} Bool state if true if the handler was removed or an array with states if multiple elements where passed in.
		 */
		unbind : function(target, name, func) {
			var t = this;

			if (!t.events)
				t.events = new tinymce.dom.EventUtils();

			return t.events.remove(target, name, func);
		},

		// #ifdef debug

		dumpRng : function(r) {
			return 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;
		},

		// #endif

		_findSib : function(node, selector, name) {
			var t = this, f = selector;

			if (node) {
				// If expression make a function of it using is
				if (is(f, 'string')) {
					f = function(node) {
						return t.is(node, selector);
					};
				}

				// Loop all siblings
				for (node = node[name]; node; node = node[name]) {
					if (f(node))
						return node;
				}
			}

			return null;
		},

		_isRes : function(c) {
			// Is live resizble element
			return /^(top|left|bottom|right|width|height)/i.test(c) || /;\s*(top|left|bottom|right|width|height)/i.test(c);
		}

		/*
		walk : function(n, f, s) {
			var d = this.doc, w;

			if (d.createTreeWalker) {
				w = d.createTreeWalker(n, NodeFilter.SHOW_TEXT, null, false);

				while ((n = w.nextNode()) != null)
					f.call(s || this, n);
			} else
				tinymce.walk(n, f, 'childNodes', s);
		}
		*/

		/*
		toRGB : function(s) {
			var c = /^\s*?#([0-9A-F]{2})([0-9A-F]{1,2})([0-9A-F]{2})?\s*?$/.exec(s);

			if (c) {
				// #FFF -> #FFFFFF
				if (!is(c[3]))
					c[3] = c[2] = c[1];

				return "rgb(" + parseInt(c[1], 16) + "," + parseInt(c[2], 16) + "," + parseInt(c[3], 16) + ")";
			}

			return s;
		}
		*/
	});

	/**
	 * Instance of DOMUtils for the current document.
	 *
	 * @property DOM
	 * @member tinymce
	 * @type tinymce.dom.DOMUtils
	 * @example
	 * // Example of how to add a class to some element by id
	 * tinymce.DOM.addClass('someid', 'someclass');
	 */
	tinymce.DOM = new tinymce.dom.DOMUtils(document, {process_html : 0});
})(tinymce);
/**
 * Range.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(ns) {
	// Range constructor
	function Range(dom) {
		var t = this,
			doc = dom.doc,
			EXTRACT = 0,
			CLONE = 1,
			DELETE = 2,
			TRUE = true,
			FALSE = false,
			START_OFFSET = 'startOffset',
			START_CONTAINER = 'startContainer',
			END_CONTAINER = 'endContainer',
			END_OFFSET = 'endOffset',
			extend = tinymce.extend,
			nodeIndex = dom.nodeIndex;

		extend(t, {
			// Inital states
			startContainer : doc,
			startOffset : 0,
			endContainer : doc,
			endOffset : 0,
			collapsed : TRUE,
			commonAncestorContainer : doc,

			// Range constants
			START_TO_START : 0,
			START_TO_END : 1,
			END_TO_END : 2,
			END_TO_START : 3,

			// Public methods
			setStart : setStart,
			setEnd : setEnd,
			setStartBefore : setStartBefore,
			setStartAfter : setStartAfter,
			setEndBefore : setEndBefore,
			setEndAfter : setEndAfter,
			collapse : collapse,
			selectNode : selectNode,
			selectNodeContents : selectNodeContents,
			compareBoundaryPoints : compareBoundaryPoints,
			deleteContents : deleteContents,
			extractContents : extractContents,
			cloneContents : cloneContents,
			insertNode : insertNode,
			surroundContents : surroundContents,
			cloneRange : cloneRange
		});

		function setStart(n, o) {
			_setEndPoint(TRUE, n, o);
		};

		function setEnd(n, o) {
			_setEndPoint(FALSE, n, o);
		};

		function setStartBefore(n) {
			setStart(n.parentNode, nodeIndex(n));
		};

		function setStartAfter(n) {
			setStart(n.parentNode, nodeIndex(n) + 1);
		};

		function setEndBefore(n) {
			setEnd(n.parentNode, nodeIndex(n));
		};

		function setEndAfter(n) {
			setEnd(n.parentNode, nodeIndex(n) + 1);
		};

		function collapse(ts) {
			if (ts) {
				t[END_CONTAINER] = t[START_CONTAINER];
				t[END_OFFSET] = t[START_OFFSET];
			} else {
				t[START_CONTAINER] = t[END_CONTAINER];
				t[START_OFFSET] = t[END_OFFSET];
			}

			t.collapsed = TRUE;
		};

		function selectNode(n) {
			setStartBefore(n);
			setEndAfter(n);
		};

		function selectNodeContents(n) {
			setStart(n, 0);
			setEnd(n, n.nodeType === 1 ? n.childNodes.length : n.nodeValue.length);
		};

		function compareBoundaryPoints(h, r) {
			var sc = t[START_CONTAINER], so = t[START_OFFSET], ec = t[END_CONTAINER], eo = t[END_OFFSET],
			rsc = r.startContainer, rso = r.startOffset, rec = r.endContainer, reo = r.endOffset;

			// Check START_TO_START
			if (h === 0)
				return _compareBoundaryPoints(sc, so, rsc, rso);

			// Check START_TO_END
			if (h === 1)
				return _compareBoundaryPoints(ec, eo, rsc, rso);

			// Check END_TO_END
			if (h === 2)
				return _compareBoundaryPoints(ec, eo, rec, reo);

			// Check END_TO_START
			if (h === 3)
				return _compareBoundaryPoints(sc, so, rec, reo);
		};

		function deleteContents() {
			_traverse(DELETE);
		};

		function extractContents() {
			return _traverse(EXTRACT);
		};

		function cloneContents() {
			return _traverse(CLONE);
		};

		function insertNode(n) {
			var startContainer = this[START_CONTAINER],
				startOffset = this[START_OFFSET], nn, o;

			// Node is TEXT_NODE or CDATA
			if ((startContainer.nodeType === 3 || startContainer.nodeType === 4) && startContainer.nodeValue) {
				if (!startOffset) {
					// At the start of text
					startContainer.parentNode.insertBefore(n, startContainer);
				} else if (startOffset >= startContainer.nodeValue.length) {
					// At the end of text
					dom.insertAfter(n, startContainer);
				} else {
					// Middle, need to split
					nn = startContainer.splitText(startOffset);
					startContainer.parentNode.insertBefore(n, nn);
				}
			} else {
				// Insert element node
				if (startContainer.childNodes.length > 0)
					o = startContainer.childNodes[startOffset];

				if (o)
					startContainer.insertBefore(n, o);
				else
					startContainer.appendChild(n);
			}
		};

		function surroundContents(n) {
			var f = t.extractContents();

			t.insertNode(n);
			n.appendChild(f);
			t.selectNode(n);
		};

		function cloneRange() {
			return extend(new Range(dom), {
				startContainer : t[START_CONTAINER],
				startOffset : t[START_OFFSET],
				endContainer : t[END_CONTAINER],
				endOffset : t[END_OFFSET],
				collapsed : t.collapsed,
				commonAncestorContainer : t.commonAncestorContainer
			});
		};

		// Private methods

		function _getSelectedNode(container, offset) {
			var child;

			if (container.nodeType == 3 /* TEXT_NODE */)
				return container;

			if (offset < 0)
				return container;

			child = container.firstChild;
			while (child && offset > 0) {
				--offset;
				child = child.nextSibling;
			}

			if (child)
				return child;

			return container;
		};

		function _isCollapsed() {
			return (t[START_CONTAINER] == t[END_CONTAINER] && t[START_OFFSET] == t[END_OFFSET]);
		};

		function _compareBoundaryPoints(containerA, offsetA, containerB, offsetB) {
			var c, offsetC, n, cmnRoot, childA, childB;

			// In the first case the boundary-points have the same container. A is before B
			// if its offset is less than the offset of B, A is equal to B if its offset is
			// equal to the offset of B, and A is after B if its offset is greater than the
			// offset of B.
			if (containerA == containerB) {
				if (offsetA == offsetB)
					return 0; // equal

				if (offsetA < offsetB)
					return -1; // before

				return 1; // after
			}

			// In the second case a child node C of the container of A is an ancestor
			// container of B. In this case, A is before B if the offset of A is less than or
			// equal to the index of the child node C and A is after B otherwise.
			c = containerB;
			while (c && c.parentNode != containerA)
				c = c.parentNode;

			if (c) {
				offsetC = 0;
				n = containerA.firstChild;

				while (n != c && offsetC < offsetA) {
					offsetC++;
					n = n.nextSibling;
				}

				if (offsetA <= offsetC)
					return -1; // before

				return 1; // after
			}

			// In the third case a child node C of the container of B is an ancestor container
			// of A. In this case, A is before B if the index of the child node C is less than
			// the offset of B and A is after B otherwise.
			c = containerA;
			while (c && c.parentNode != containerB) {
				c = c.parentNode;
			}

			if (c) {
				offsetC = 0;
				n = containerB.firstChild;

				while (n != c && offsetC < offsetB) {
					offsetC++;
					n = n.nextSibling;
				}

				if (offsetC < offsetB)
					return -1; // before

				return 1; // after
			}

			// In the fourth case, none of three other cases hold: the containers of A and B
			// are siblings or descendants of sibling nodes. In this case, A is before B if
			// the container of A is before the container of B in a pre-order traversal of the
			// Ranges' context tree and A is after B otherwise.
			cmnRoot = dom.findCommonAncestor(containerA, containerB);
			childA = containerA;

			while (childA && childA.parentNode != cmnRoot)
				childA = childA.parentNode;

			if (!childA)
				childA = cmnRoot;

			childB = containerB;
			while (childB && childB.parentNode != cmnRoot)
				childB = childB.parentNode;

			if (!childB)
				childB = cmnRoot;

			if (childA == childB)
				return 0; // equal

			n = cmnRoot.firstChild;
			while (n) {
				if (n == childA)
					return -1; // before

				if (n == childB)
					return 1; // after

				n = n.nextSibling;
			}
		};

		function _setEndPoint(st, n, o) {
			var ec, sc;

			if (st) {
				t[START_CONTAINER] = n;
				t[START_OFFSET] = o;
			} else {
				t[END_CONTAINER] = n;
				t[END_OFFSET] = o;
			}

			// If one boundary-point of a Range is set to have a root container
			// other than the current one for the Range, the Range is collapsed to
			// the new position. This enforces the restriction that both boundary-
			// points of a Range must have the same root container.
			ec = t[END_CONTAINER];
			while (ec.parentNode)
				ec = ec.parentNode;

			sc = t[START_CONTAINER];
			while (sc.parentNode)
				sc = sc.parentNode;

			if (sc == ec) {
				// The start position of a Range is guaranteed to never be after the
				// end position. To enforce this restriction, if the start is set to
				// be at a position after the end, the Range is collapsed to that
				// position.
				if (_compareBoundaryPoints(t[START_CONTAINER], t[START_OFFSET], t[END_CONTAINER], t[END_OFFSET]) > 0)
					t.collapse(st);
			} else
				t.collapse(st);

			t.collapsed = _isCollapsed();
			t.commonAncestorContainer = dom.findCommonAncestor(t[START_CONTAINER], t[END_CONTAINER]);
		};

		function _traverse(how) {
			var c, endContainerDepth = 0, startContainerDepth = 0, p, depthDiff, startNode, endNode, sp, ep;

			if (t[START_CONTAINER] == t[END_CONTAINER])
				return _traverseSameContainer(how);

			for (c = t[END_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {
				if (p == t[START_CONTAINER])
					return _traverseCommonStartContainer(c, how);

				++endContainerDepth;
			}

			for (c = t[START_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {
				if (p == t[END_CONTAINER])
					return _traverseCommonEndContainer(c, how);

				++startContainerDepth;
			}

			depthDiff = startContainerDepth - endContainerDepth;

			startNode = t[START_CONTAINER];
			while (depthDiff > 0) {
				startNode = startNode.parentNode;
				depthDiff--;
			}

			endNode = t[END_CONTAINER];
			while (depthDiff < 0) {
				endNode = endNode.parentNode;
				depthDiff++;
			}

			// ascend the ancestor hierarchy until we have a common parent.
			for (sp = startNode.parentNode, ep = endNode.parentNode; sp != ep; sp = sp.parentNode, ep = ep.parentNode) {
				startNode = sp;
				endNode = ep;
			}

			return _traverseCommonAncestors(startNode, endNode, how);
		};

		 function _traverseSameContainer(how) {
			var frag, s, sub, n, cnt, sibling, xferNode;

			if (how != DELETE)
				frag = doc.createDocumentFragment();

			// If selection is empty, just return the fragment
			if (t[START_OFFSET] == t[END_OFFSET])
				return frag;

			// Text node needs special case handling
			if (t[START_CONTAINER].nodeType == 3 /* TEXT_NODE */) {
				// get the substring
				s = t[START_CONTAINER].nodeValue;
				sub = s.substring(t[START_OFFSET], t[END_OFFSET]);

				// set the original text node to its new value
				if (how != CLONE) {
					t[START_CONTAINER].deleteData(t[START_OFFSET], t[END_OFFSET] - t[START_OFFSET]);

					// Nothing is partially selected, so collapse to start point
					t.collapse(TRUE);
				}

				if (how == DELETE)
					return;

				frag.appendChild(doc.createTextNode(sub));
				return frag;
			}

			// Copy nodes between the start/end offsets.
			n = _getSelectedNode(t[START_CONTAINER], t[START_OFFSET]);
			cnt = t[END_OFFSET] - t[START_OFFSET];

			while (cnt > 0) {
				sibling = n.nextSibling;
				xferNode = _traverseFullySelected(n, how);

				if (frag)
					frag.appendChild( xferNode );

				--cnt;
				n = sibling;
			}

			// Nothing is partially selected, so collapse to start point
			if (how != CLONE)
				t.collapse(TRUE);

			return frag;
		};

		function _traverseCommonStartContainer(endAncestor, how) {
			var frag, n, endIdx, cnt, sibling, xferNode;

			if (how != DELETE)
				frag = doc.createDocumentFragment();

			n = _traverseRightBoundary(endAncestor, how);

			if (frag)
				frag.appendChild(n);

			endIdx = nodeIndex(endAncestor);
			cnt = endIdx - t[START_OFFSET];

			if (cnt <= 0) {
				// Collapse to just before the endAncestor, which
				// is partially selected.
				if (how != CLONE) {
					t.setEndBefore(endAncestor);
					t.collapse(FALSE);
				}

				return frag;
			}

			n = endAncestor.previousSibling;
			while (cnt > 0) {
				sibling = n.previousSibling;
				xferNode = _traverseFullySelected(n, how);

				if (frag)
					frag.insertBefore(xferNode, frag.firstChild);

				--cnt;
				n = sibling;
			}

			// Collapse to just before the endAncestor, which
			// is partially selected.
			if (how != CLONE) {
				t.setEndBefore(endAncestor);
				t.collapse(FALSE);
			}

			return frag;
		};

		function _traverseCommonEndContainer(startAncestor, how) {
			var frag, startIdx, n, cnt, sibling, xferNode;

			if (how != DELETE)
				frag = doc.createDocumentFragment();

			n = _traverseLeftBoundary(startAncestor, how);
			if (frag)
				frag.appendChild(n);

			startIdx = nodeIndex(startAncestor);
			++startIdx; // Because we already traversed it

			cnt = t[END_OFFSET] - startIdx;
			n = startAncestor.nextSibling;
			while (cnt > 0) {
				sibling = n.nextSibling;
				xferNode = _traverseFullySelected(n, how);

				if (frag)
					frag.appendChild(xferNode);

				--cnt;
				n = sibling;
			}

			if (how != CLONE) {
				t.setStartAfter(startAncestor);
				t.collapse(TRUE);
			}

			return frag;
		};

		function _traverseCommonAncestors(startAncestor, endAncestor, how) {
			var n, frag, commonParent, startOffset, endOffset, cnt, sibling, nextSibling;

			if (how != DELETE)
				frag = doc.createDocumentFragment();

			n = _traverseLeftBoundary(startAncestor, how);
			if (frag)
				frag.appendChild(n);

			commonParent = startAncestor.parentNode;
			startOffset = nodeIndex(startAncestor);
			endOffset = nodeIndex(endAncestor);
			++startOffset;

			cnt = endOffset - startOffset;
			sibling = startAncestor.nextSibling;

			while (cnt > 0) {
				nextSibling = sibling.nextSibling;
				n = _traverseFullySelected(sibling, how);

				if (frag)
					frag.appendChild(n);

				sibling = nextSibling;
				--cnt;
			}

			n = _traverseRightBoundary(endAncestor, how);

			if (frag)
				frag.appendChild(n);

			if (how != CLONE) {
				t.setStartAfter(startAncestor);
				t.collapse(TRUE);
			}

			return frag;
		};

		function _traverseRightBoundary(root, how) {
			var next = _getSelectedNode(t[END_CONTAINER], t[END_OFFSET] - 1), parent, clonedParent, prevSibling, clonedChild, clonedGrandParent, isFullySelected = next != t[END_CONTAINER];

			if (next == root)
				return _traverseNode(next, isFullySelected, FALSE, how);

			parent = next.parentNode;
			clonedParent = _traverseNode(parent, FALSE, FALSE, how);

			while (parent) {
				while (next) {
					prevSibling = next.previousSibling;
					clonedChild = _traverseNode(next, isFullySelected, FALSE, how);

					if (how != DELETE)
						clonedParent.insertBefore(clonedChild, clonedParent.firstChild);

					isFullySelected = TRUE;
					next = prevSibling;
				}

				if (parent == root)
					return clonedParent;

				next = parent.previousSibling;
				parent = parent.parentNode;

				clonedGrandParent = _traverseNode(parent, FALSE, FALSE, how);

				if (how != DELETE)
					clonedGrandParent.appendChild(clonedParent);

				clonedParent = clonedGrandParent;
			}
		};

		function _traverseLeftBoundary(root, how) {
			var next = _getSelectedNode(t[START_CONTAINER], t[START_OFFSET]), isFullySelected = next != t[START_CONTAINER], parent, clonedParent, nextSibling, clonedChild, clonedGrandParent;

			if (next == root)
				return _traverseNode(next, isFullySelected, TRUE, how);

			parent = next.parentNode;
			clonedParent = _traverseNode(parent, FALSE, TRUE, how);

			while (parent) {
				while (next) {
					nextSibling = next.nextSibling;
					clonedChild = _traverseNode(next, isFullySelected, TRUE, how);

					if (how != DELETE)
						clonedParent.appendChild(clonedChild);

					isFullySelected = TRUE;
					next = nextSibling;
				}

				if (parent == root)
					return clonedParent;

				next = parent.nextSibling;
				parent = parent.parentNode;

				clonedGrandParent = _traverseNode(parent, FALSE, TRUE, how);

				if (how != DELETE)
					clonedGrandParent.appendChild(clonedParent);

				clonedParent = clonedGrandParent;
			}
		};

		function _traverseNode(n, isFullySelected, isLeft, how) {
			var txtValue, newNodeValue, oldNodeValue, offset, newNode;

			if (isFullySelected)
				return _traverseFullySelected(n, how);

			if (n.nodeType == 3 /* TEXT_NODE */) {
				txtValue = n.nodeValue;

				if (isLeft) {
					offset = t[START_OFFSET];
					newNodeValue = txtValue.substring(offset);
					oldNodeValue = txtValue.substring(0, offset);
				} else {
					offset = t[END_OFFSET];
					newNodeValue = txtValue.substring(0, offset);
					oldNodeValue = txtValue.substring(offset);
				}

				if (how != CLONE)
					n.nodeValue = oldNodeValue;

				if (how == DELETE)
					return;

				newNode = n.cloneNode(FALSE);
				newNode.nodeValue = newNodeValue;

				return newNode;
			}

			if (how == DELETE)
				return;

			return n.cloneNode(FALSE);
		};

		function _traverseFullySelected(n, how) {
			if (how != DELETE)
				return how == CLONE ? n.cloneNode(TRUE) : n;

			n.parentNode.removeChild(n);
		};
	};

	ns.Range = Range;
})(tinymce.dom);
/**
 * TridentSelection.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function() {
	function Selection(selection) {
		var self = this, dom = selection.dom, TRUE = true, FALSE = false;

		function getPosition(rng, start) {
			var checkRng, startIndex = 0, endIndex, inside,
				children, child, offset, index, position = -1, parent;

			// Setup test range, collapse it and get the parent
			checkRng = rng.duplicate();
			checkRng.collapse(start);
			parent = checkRng.parentElement();

			// Check if the selection is within the right document
			if (parent.ownerDocument !== selection.dom.doc)
				return;

			// IE will report non editable elements as it's parent so look for an editable one
			while (parent.contentEditable === "false") {
				parent = parent.parentNode;
			}

			// If parent doesn't have any children then return that we are inside the element
			if (!parent.hasChildNodes()) {
				return {node : parent, inside : 1};
			}

			// Setup node list and endIndex
			children = parent.children;
			endIndex = children.length - 1;

			// Perform a binary search for the position
			while (startIndex <= endIndex) {
				index = Math.floor((startIndex + endIndex) / 2);

				// Move selection to node and compare the ranges
				child = children[index];
				checkRng.moveToElementText(child);
				position = checkRng.compareEndPoints(start ? 'StartToStart' : 'EndToEnd', rng);

				// Before/after or an exact match
				if (position > 0) {
					endIndex = index - 1;
				} else if (position < 0) {
					startIndex = index + 1;
				} else {
					return {node : child};
				}
			}

			// Check if child position is before or we didn't find a position
			if (position < 0) {
				// No element child was found use the parent element and the offset inside that
				if (!child) {
					checkRng.moveToElementText(parent);
					checkRng.collapse(true);
					child = parent;
					inside = true;
				} else
					checkRng.collapse(false);

				checkRng.setEndPoint(start ? 'EndToStart' : 'EndToEnd', rng);

				// Fix for edge case: <div style="width: 100px; height:100px;"><table>..</table>ab|c</div>
				if (checkRng.compareEndPoints(start ? 'StartToStart' : 'StartToEnd', rng) > 0) {
					checkRng = rng.duplicate();
					checkRng.collapse(start);

					offset = -1;
					while (parent == checkRng.parentElement()) {
						if (checkRng.move('character', -1) == 0)
							break;

						offset++;
					}
				}

				offset = offset || checkRng.text.replace('\r\n', ' ').length;
			} else {
				// Child position is after the selection endpoint
				checkRng.collapse(true);
				checkRng.setEndPoint(start ? 'StartToStart' : 'StartToEnd', rng);

				// Get the length of the text to find where the endpoint is relative to it's container
				offset = checkRng.text.replace('\r\n', ' ').length;
			}

			return {node : child, position : position, offset : offset, inside : inside};
		};

		// Returns a W3C DOM compatible range object by using the IE Range API
		function getRange() {
			var ieRange = selection.getRng(), domRange = dom.createRng(), element, collapsed, tmpRange, element2, bookmark, fail;

			// If selection is outside the current document just return an empty range
			element = ieRange.item ? ieRange.item(0) : ieRange.parentElement();
			if (element.ownerDocument != dom.doc)
				return domRange;

			collapsed = selection.isCollapsed();

			// Handle control selection
			if (ieRange.item) {
				domRange.setStart(element.parentNode, dom.nodeIndex(element));
				domRange.setEnd(domRange.startContainer, domRange.startOffset + 1);

				return domRange;
			}

			function findEndPoint(start) {
				var endPoint = getPosition(ieRange, start), container, offset, textNodeOffset = 0, sibling, undef, nodeValue;

				container = endPoint.node;
				offset = endPoint.offset;

				if (endPoint.inside && !container.hasChildNodes()) {
					domRange[start ? 'setStart' : 'setEnd'](container, 0);
					return;
				}

				if (offset === undef) {
					domRange[start ? 'setStartBefore' : 'setEndAfter'](container);
					return;
				}

				if (endPoint.position < 0) {
					sibling = endPoint.inside ? container.firstChild : container.nextSibling;

					if (!sibling) {
						domRange[start ? 'setStartAfter' : 'setEndAfter'](container);
						return;
					}

					if (!offset) {
						if (sibling.nodeType == 3)
							domRange[start ? 'setStart' : 'setEnd'](sibling, 0);
						else
							domRange[start ? 'setStartBefore' : 'setEndBefore'](sibling);

						return;
					}

					// Find the text node and offset
					while (sibling) {
						nodeValue = sibling.nodeValue;
						textNodeOffset += nodeValue.length;

						// We are at or passed the position we where looking for
						if (textNodeOffset >= offset) {
							container = sibling;
							textNodeOffset -= offset;
							textNodeOffset = nodeValue.length - textNodeOffset;
							break;
						}

						sibling = sibling.nextSibling;
					}
				} else {
					// Find the text node and offset
					sibling = container.previousSibling;

					if (!sibling)
						return domRange[start ? 'setStartBefore' : 'setEndBefore'](container);

					// If there isn't any text to loop then use the first position
					if (!offset) {
						if (container.nodeType == 3)
							domRange[start ? 'setStart' : 'setEnd'](sibling, container.nodeValue.length);
						else
							domRange[start ? 'setStartAfter' : 'setEndAfter'](sibling);

						return;
					}

					while (sibling) {
						textNodeOffset += sibling.nodeValue.length;

						// We are at or passed the position we where looking for
						if (textNodeOffset >= offset) {
							container = sibling;
							textNodeOffset -= offset;
							break;
						}

						sibling = sibling.previousSibling;
					}
				}

				domRange[start ? 'setStart' : 'setEnd'](container, textNodeOffset);
			};

			try {
				// Find start point
				findEndPoint(true);

				// Find end point if needed
				if (!collapsed)
					findEndPoint();
			} catch (ex) {
				// IE has a nasty bug where text nodes might throw "invalid argument" when you
				// access the nodeValue or other properties of text nodes. This seems to happend when
				// text nodes are split into two nodes by a delete/backspace call. So lets detect it and try to fix it.
				if (ex.number == -2147024809) {
					// Get the current selection
					bookmark = self.getBookmark(2);

					// Get start element
					tmpRange = ieRange.duplicate();
					tmpRange.collapse(true);
					element = tmpRange.parentElement();

					// Get end element
					if (!collapsed) {
						tmpRange = ieRange.duplicate();
						tmpRange.collapse(false);
						element2 = tmpRange.parentElement();
						element2.innerHTML = element2.innerHTML;
					}

					// Remove the broken elements
					element.innerHTML = element.innerHTML;

					// Restore the selection
					self.moveToBookmark(bookmark);

					// Since the range has moved we need to re-get it
					ieRange = selection.getRng();

					// Find start point
					findEndPoint(true);

					// Find end point if needed
					if (!collapsed)
						findEndPoint();
				} else
					throw ex; // Throw other errors
			}

			return domRange;
		};

		this.getBookmark = function(type) {
			var rng = selection.getRng(), start, end, bookmark = {};

			function getIndexes(node) {
				var node, parent, root, children, i, indexes = [];

				parent = node.parentNode;
				root = dom.getRoot().parentNode;

				while (parent != root) {
					children = parent.children;

					i = children.length;
					while (i--) {
						if (node === children[i]) {
							indexes.push(i);
							break;
						}
					}

					node = parent;
					parent = parent.parentNode;
				}

				return indexes;
			};

			function getBookmarkEndPoint(start) {
				var position;

				position = getPosition(rng, start);
				if (position) {
					return {
						position : position.position,
						offset : position.offset,
						indexes : getIndexes(position.node),
						inside : position.inside
					};
				}
			};

			// Non ubstructive bookmark
			if (type === 2) {
				// Handle text selection
				if (!rng.item) {
					bookmark.start = getBookmarkEndPoint(true);

					if (!selection.isCollapsed())
						bookmark.end = getBookmarkEndPoint();
				} else
					bookmark.start = {ctrl : true, indexes : getIndexes(rng.item(0))};
			}

			return bookmark;
		};

		this.moveToBookmark = function(bookmark) {
			var rng, body = dom.doc.body;

			function resolveIndexes(indexes) {
				var node, i, idx, children;

				node = dom.getRoot();
				for (i = indexes.length - 1; i >= 0; i--) {
					children = node.children;
					idx = indexes[i];

					if (idx <= children.length - 1) {
						node = children[idx];
					}
				}

				return node;
			};

			function setBookmarkEndPoint(start) {
				var endPoint = bookmark[start ? 'start' : 'end'], moveLeft, moveRng, undef;

				if (endPoint) {
					moveLeft = endPoint.position > 0;

					moveRng = body.createTextRange();
					moveRng.moveToElementText(resolveIndexes(endPoint.indexes));

					offset = endPoint.offset;
					if (offset !== undef) {
						moveRng.collapse(endPoint.inside || moveLeft);
						moveRng.moveStart('character', moveLeft ? -offset : offset);
					} else
						moveRng.collapse(start);

					rng.setEndPoint(start ? 'StartToStart' : 'EndToStart', moveRng);

					if (start)
						rng.collapse(true);
				}
			};

			if (bookmark.start) {
				if (bookmark.start.ctrl) {
					rng = body.createControlRange();
					rng.addElement(resolveIndexes(bookmark.start.indexes));
					rng.select();
				} else {
					rng = body.createTextRange();
					setBookmarkEndPoint(true);
					setBookmarkEndPoint();
					rng.select();
				}
			}
		};

		this.addRange = function(rng) {
			var ieRng, ctrlRng, startContainer, startOffset, endContainer, endOffset, doc = selection.dom.doc, body = doc.body;

			function setEndPoint(start) {
				var container, offset, marker, tmpRng, nodes;

				marker = dom.create('a');
				container = start ? startContainer : endContainer;
				offset = start ? startOffset : endOffset;
				tmpRng = ieRng.duplicate();

				if (container == doc || container == doc.documentElement) {
					container = body;
					offset = 0;
				}

				if (container.nodeType == 3) {
					container.parentNode.insertBefore(marker, container);
					tmpRng.moveToElementText(marker);
					tmpRng.moveStart('character', offset);
					dom.remove(marker);
					ieRng.setEndPoint(start ? 'StartToStart' : 'EndToEnd', tmpRng);
				} else {
					nodes = container.childNodes;

					if (nodes.length) {
						if (offset >= nodes.length) {
							dom.insertAfter(marker, nodes[nodes.length - 1]);
						} else {
							container.insertBefore(marker, nodes[offset]);
						}

						tmpRng.moveToElementText(marker);
					} else {
						// Empty node selection for example <div>|</div>
						marker = doc.createTextNode('\uFEFF');
						container.appendChild(marker);
						tmpRng.moveToElementText(marker.parentNode);
						tmpRng.collapse(TRUE);
					}

					ieRng.setEndPoint(start ? 'StartToStart' : 'EndToEnd', tmpRng);
					dom.remove(marker);
				}
			}

			// Setup some shorter versions
			startContainer = rng.startContainer;
			startOffset = rng.startOffset;
			endContainer = rng.endContainer;
			endOffset = rng.endOffset;
			ieRng = body.createTextRange();

			// If single element selection then try making a control selection out of it
			if (startContainer == endContainer && startContainer.nodeType == 1 && startOffset == endOffset - 1) {
				if (startOffset == endOffset - 1) {
					try {
						ctrlRng = body.createControlRange();
						ctrlRng.addElement(startContainer.childNodes[startOffset]);
						ctrlRng.select();
						return;
					} catch (ex) {
						// Ignore
					}
				}
			}

			// Set start/end point of selection
			setEndPoint(true);
			setEndPoint();

			// Select the new range and scroll it into view
			ieRng.select();
		};

		// Expose range method
		this.getRangeAt = getRange;
	};

	// Expose the selection object
	tinymce.dom.TridentSelection = Selection;
})();
// #ifndef jquery

/*
 * Sizzle CSS Selector Engine - v1.0
 *  Copyright 2009, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function(){
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function(selector, context, results, seed) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var parts = [], m, set, checkSet, extra, prune = true, contextXML = Sizzle.isXML(context),
		soFar = selector, ret, cur, pop, i;

	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec("");
		m = chunker.exec(soFar);

		if ( m ) {
			soFar = m[3];

			parts.push( m[1] );

			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {
		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );
		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}

				set = posProcess( selector, set );
			}
		}
	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
			set = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray(set);
			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}
		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );
		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}
		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}
	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function(results){
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort(sortOrder);

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[i-1] ) {
					results.splice(i--, 1);
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function(expr, set){
	return Sizzle(expr, null, null, set);
};

Sizzle.find = function(expr, context, isXML){
	var set;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var type = Expr.order[i], match;

		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			var left = match[1];
			match.splice(1,1);

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace(/\\/g, "");
				set = Expr.find[ type ]( match, context, isXML );
				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = context.getElementsByTagName("*");
	}

	return {set: set, expr: expr};
};

Sizzle.filter = function(expr, set, inplace, not){
	var old = expr, result = [], curLoop = set, match, anyFound,
		isXMLFilter = set && set[0] && Sizzle.isXML(set[0]);

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				var filter = Expr.filter[ type ], found, item, left = match[1];
				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;
					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;
								} else {
									curLoop[i] = false;
								}
							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );
			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw "Syntax error, unrecognized expression: " + msg;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],
	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},
	leftMatch: {},
	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},
	attrHandle: {
		href: function(elem){
			return elem.getAttribute("href");
		}
	},
	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !/\W/.test(part),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},
		">": function(checkSet, part){
			var isPartStr = typeof part === "string",
				elem, i = 0, l = checkSet.length;

			if ( isPartStr && !/\W/.test(part) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];
					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}
			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];
					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},
		"": function(checkSet, part, isXML){
			var doneName = done++, checkFn = dirCheck, nodeCheck;

			if ( typeof part === "string" && !/\W/.test(part) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
		},
		"~": function(checkSet, part, isXML){
			var doneName = done++, checkFn = dirCheck, nodeCheck;

			if ( typeof part === "string" && !/\W/.test(part) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
		}
	},
	find: {
		ID: function(match, context, isXML){
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m ? [m] : [];
			}
		},
		NAME: function(match, context){
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [], results = context.getElementsByName(match[1]);

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},
		TAG: function(match, context){
			return context.getElementsByTagName(match[1]);
		}
	},
	preFilter: {
		CLASS: function(match, curLoop, inplace, result, not, isXML){
			match = " " + match[1].replace(/\\/g, "") + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}
					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},
		ID: function(match){
			return match[1].replace(/\\/g, "");
		},
		TAG: function(match, curLoop){
			return match[1].toLowerCase();
		},
		CHILD: function(match){
			if ( match[1] === "nth" ) {
				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},
		ATTR: function(match, curLoop, inplace, result, not, isXML){
			var name = match[1].replace(/\\/g, "");

			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},
		PSEUDO: function(match, curLoop, inplace, result, not){
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);
				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
					if ( !inplace ) {
						result.push.apply( result, ret );
					}
					return false;
				}
			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}

			return match;
		},
		POS: function(match){
			match.unshift( true );
			return match;
		}
	},
	filters: {
		enabled: function(elem){
			return elem.disabled === false && elem.type !== "hidden";
		},
		disabled: function(elem){
			return elem.disabled === true;
		},
		checked: function(elem){
			return elem.checked === true;
		},
		selected: function(elem){
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			elem.parentNode.selectedIndex;
			return elem.selected === true;
		},
		parent: function(elem){
			return !!elem.firstChild;
		},
		empty: function(elem){
			return !elem.firstChild;
		},
		has: function(elem, i, match){
			return !!Sizzle( match[3], elem ).length;
		},
		header: function(elem){
			return (/h\d/i).test( elem.nodeName );
		},
		text: function(elem){
			return "text" === elem.type;
		},
		radio: function(elem){
			return "radio" === elem.type;
		},
		checkbox: function(elem){
			return "checkbox" === elem.type;
		},
		file: function(elem){
			return "file" === elem.type;
		},
		password: function(elem){
			return "password" === elem.type;
		},
		submit: function(elem){
			return "submit" === elem.type;
		},
		image: function(elem){
			return "image" === elem.type;
		},
		reset: function(elem){
			return "reset" === elem.type;
		},
		button: function(elem){
			return "button" === elem.type || elem.nodeName.toLowerCase() === "button";
		},
		input: function(elem){
			return (/input|select|textarea|button/i).test(elem.nodeName);
		}
	},
	setFilters: {
		first: function(elem, i){
			return i === 0;
		},
		last: function(elem, i, match, array){
			return i === array.length - 1;
		},
		even: function(elem, i){
			return i % 2 === 0;
		},
		odd: function(elem, i){
			return i % 2 === 1;
		},
		lt: function(elem, i, match){
			return i < match[3] - 0;
		},
		gt: function(elem, i, match){
			return i > match[3] - 0;
		},
		nth: function(elem, i, match){
			return match[3] - 0 === i;
		},
		eq: function(elem, i, match){
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function(elem, match, i, array){
			var name = match[1], filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;
			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;
			} else {
				Sizzle.error( "Syntax error, unrecognized expression: " + name );
			}
		},
		CHILD: function(elem, match){
			var type = match[1], node = elem;
			switch (type) {
				case 'only':
				case 'first':
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}
					if ( type === "first" ) {
						return true;
					}
					node = elem;
				case 'last':
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}
					return true;
				case 'nth':
					var first = match[2], last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}

					var doneName = match[0],
						parent = elem.parentNode;

					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}
						parent.sizcache = doneName;
					}

					var diff = elem.nodeIndex - last;
					if ( first === 0 ) {
						return diff === 0;
					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},
		ID: function(elem, match){
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},
		TAG: function(elem, match){
			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
		},
		CLASS: function(elem, match){
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},
		ATTR: function(elem, match){
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},
		POS: function(elem, match, i, array){
			var name = match[2], filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function(array, results) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}

	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch(e){
	makeArray = function(array, results) {
		var ret = results || [], i = 0;

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );
		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}
			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			if ( a == b ) {
				hasDuplicate = true;
			}
			return a.compareDocumentPosition ? -1 : 1;
		}

		var ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
} else if ( "sourceIndex" in document.documentElement ) {
	sortOrder = function( a, b ) {
		if ( !a.sourceIndex || !b.sourceIndex ) {
			if ( a == b ) {
				hasDuplicate = true;
			}
			return a.sourceIndex ? -1 : 1;
		}

		var ret = a.sourceIndex - b.sourceIndex;
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
} else if ( document.createRange ) {
	sortOrder = function( a, b ) {
		if ( !a.ownerDocument || !b.ownerDocument ) {
			if ( a == b ) {
				hasDuplicate = true;
			}
			return a.ownerDocument ? -1 : 1;
		}

		var aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();
		aRange.setStart(a, 0);
		aRange.setEnd(a, 0);
		bRange.setStart(b, 0);
		bRange.setEnd(b, 0);
		var ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
}

// Utility function for retreiving the text value of an array of DOM nodes
Sizzle.getText = function( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += Sizzle.getText( elem.childNodes );
		}
	}

	return ret;
};

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime();
	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	var root = document.documentElement;
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function(match, context, isXML){
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m ? m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ? [m] : undefined : [];
			}
		};

		Expr.filter.ID = function(elem, match){
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );
	root = form = null; // release memory in IE
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function(match, context){
			var results = context.getElementsByTagName(match[1]);

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";
	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {
		Expr.attrHandle.href = function(elem){
			return elem.getAttribute("href", 2);
		};
	}

	div = null; // release memory in IE
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle, div = document.createElement("div");
		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}

		Sizzle = function(query, context, extra, seed){
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && context.nodeType === 9 && !Sizzle.isXML(context) ) {
				try {
					return makeArray( context.querySelectorAll(query), extra );
				} catch(e){}
			}

			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		div = null; // release memory in IE
	})();
}

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}

	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function(match, context, isXML) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	div = null; // release memory in IE
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			elem = elem[dir];
			var match = false;

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			elem = elem[dir];
			var match = false;

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}
					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

Sizzle.contains = document.compareDocumentPosition ? function(a, b){
	return !!(a.compareDocumentPosition(b) & 16);
} : function(a, b){
	return a !== b && (a.contains ? a.contains(b) : true);
};

Sizzle.isXML = function(elem){
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function(selector, context){
	var tmpSet = [], later = "", match,
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE

window.tinymce.dom.Sizzle = Sizzle;

})();

// #endif
/**
 * EventUtils.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	// Shorten names
	var each = tinymce.each, DOM = tinymce.DOM, isIE = tinymce.isIE, isWebKit = tinymce.isWebKit, Event;

	/**
	 * This class handles DOM events in a cross platform fasion it also keeps track of element
	 * and handler references to be able to clean elements to reduce IE memory leaks.
	 *
	 * @class tinymce.dom.EventUtils
	 */
	tinymce.create('tinymce.dom.EventUtils', {
		/**
		 * Constructs a new EventUtils instance.
		 *
		 * @constructor
		 * @method EventUtils
		 */
		EventUtils : function() {
			this.inits = [];
			this.events = [];
		},

		/**
		 * Adds an event handler to the specified object.
		 *
		 * @method add
		 * @param {Element/Document/Window/Array/String} o Object or element id string to add event handler to or an array of elements/ids/documents.
		 * @param {String/Array} n Name of event handler to add for example: click.
		 * @param {function} f Function to execute when the event occurs.
		 * @param {Object} s Optional scope to execute the function in.
		 * @return {function} Function callback handler the same as the one passed in.
		 * @example
		 * // Adds a click handler to the current document
		 * tinymce.dom.Event.add(document, 'click', function(e) {
		 *    console.debug(e.target);
		 * });
		 */
		add : function(o, n, f, s) {
			var cb, t = this, el = t.events, r;

			if (n instanceof Array) {
				r = [];

				each(n, function(n) {
					r.push(t.add(o, n, f, s));
				});

				return r;
			}

			// Handle array
			if (o && o.hasOwnProperty && o instanceof Array) {
				r = [];

				each(o, function(o) {
					o = DOM.get(o);
					r.push(t.add(o, n, f, s));
				});

				return r;
			}

			o = DOM.get(o);

			if (!o)
				return;

			// Setup event callback
			cb = function(e) {
				// Is all events disabled
				if (t.disabled)
					return;

				e = e || window.event;

				// Patch in target, preventDefault and stopPropagation in IE it's W3C valid
				if (e && isIE) {
					if (!e.target)
						e.target = e.srcElement;

					// Patch in preventDefault, stopPropagation methods for W3C compatibility
					tinymce.extend(e, t._stoppers);
				}

				if (!s)
					return f(e);

				return f.call(s, e);
			};

			if (n == 'unload') {
				tinymce.unloads.unshift({func : cb});
				return cb;
			}

			if (n == 'init') {
				if (t.domLoaded)
					cb();
				else
					t.inits.push(cb);

				return cb;
			}

			// Store away listener reference
			el.push({
				obj : o,
				name : n,
				func : f,
				cfunc : cb,
				scope : s
			});

			t._add(o, n, cb);

			return f;
		},

		/**
		 * Removes the specified event handler by name and function from a element or collection of elements.
		 *
		 * @method remove
		 * @param {String/Element/Array} o Element ID string or HTML element or an array of elements or ids to remove handler from.
		 * @param {String} n Event handler name like for example: "click"
		 * @param {function} f Function to remove.
		 * @return {bool/Array} Bool state if true if the handler was removed or an array with states if multiple elements where passed in.
		 * @example
		 * // Adds a click handler to the current document
		 * var func = tinymce.dom.Event.add(document, 'click', function(e) {
		 *    console.debug(e.target);
		 * });
		 *
		 * // Removes the click handler from the document
		 * tinymce.dom.Event.remove(document, 'click', func);
		 */
		remove : function(o, n, f) {
			var t = this, a = t.events, s = false, r;

			// Handle array
			if (o && o.hasOwnProperty && o instanceof Array) {
				r = [];

				each(o, function(o) {
					o = DOM.get(o);
					r.push(t.remove(o, n, f));
				});

				return r;
			}

			o = DOM.get(o);

			each(a, function(e, i) {
				if (e.obj == o && e.name == n && (!f || (e.func == f || e.cfunc == f))) {
					a.splice(i, 1);
					t._remove(o, n, e.cfunc);
					s = true;
					return false;
				}
			});

			return s;
		},

		/**
		 * Clears all events of a specific object.
		 *
		 * @method clear
		 * @param {Object} o DOM element or object to remove all events from.
		 * @example
		 * // Cancels all mousedown events in the active editor
		 * tinyMCE.activeEditor.onMouseDown.add(function(ed, e) {
		 *    return tinymce.dom.Event.cancel(e);
		 * });
		 */
		clear : function(o) {
			var t = this, a = t.events, i, e;

			if (o) {
				o = DOM.get(o);

				for (i = a.length - 1; i >= 0; i--) {
					e = a[i];

					if (e.obj === o) {
						t._remove(e.obj, e.name, e.cfunc);
						e.obj = e.cfunc = null;
						a.splice(i, 1);
					}
				}
			}
		},

		/**
		 * Cancels an event for both bubbeling and the default browser behavior.
		 *
		 * @method cancel
		 * @param {Event} e Event object to cancel.
		 * @return {Boolean} Always false.
		 */
		cancel : function(e) {
			if (!e)
				return false;

			this.stop(e);

			return this.prevent(e);
		},

		/**
		 * Stops propogation/bubbeling of an event.
		 *
		 * @method stop
		 * @param {Event} e Event to cancel bubbeling on.
		 * @return {Boolean} Always false.
		 */
		stop : function(e) {
			if (e.stopPropagation)
				e.stopPropagation();
			else
				e.cancelBubble = true;

			return false;
		},

		/**
		 * Prevent default browser behvaior of an event.
		 *
		 * @method prevent
		 * @param {Event} e Event to prevent default browser behvaior of an event.
		 * @return {Boolean} Always false.
		 */
		prevent : function(e) {
			if (e.preventDefault)
				e.preventDefault();
			else
				e.returnValue = false;

			return false;
		},

		/**
		 * Destroys the instance.
		 *
		 * @method destroy
		 */
		destroy : function() {
			var t = this;

			each(t.events, function(e, i) {
				t._remove(e.obj, e.name, e.cfunc);
				e.obj = e.cfunc = null;
			});

			t.events = [];
			t = null;
		},

		_add : function(o, n, f) {
			if (o.attachEvent)
				o.attachEvent('on' + n, f);
			else if (o.addEventListener)
				o.addEventListener(n, f, false);
			else
				o['on' + n] = f;
		},

		_remove : function(o, n, f) {
			if (o) {
				try {
					if (o.detachEvent)
						o.detachEvent('on' + n, f);
					else if (o.removeEventListener)
						o.removeEventListener(n, f, false);
					else
						o['on' + n] = null;
				} catch (ex) {
					// Might fail with permission denined on IE so we just ignore that
				}
			}
		},

		_pageInit : function(win) {
			var t = this;

			// Keep it from running more than once
			if (t.domLoaded)
				return;

			t.domLoaded = true;

			each(t.inits, function(c) {
				c();
			});

			t.inits = [];
		},

		_wait : function(win) {
			var t = this, doc = win.document;

			// No need since the document is already loaded
			if (win.tinyMCE_GZ && tinyMCE_GZ.loaded) {
				t.domLoaded = 1;
				return;
			}

			// Use IE method
			if (doc.attachEvent) {
				doc.attachEvent("onreadystatechange", function() {
					if (doc.readyState === "complete") {
						doc.detachEvent("onreadystatechange", arguments.callee);
						t._pageInit(win);
					}
				});

				if (doc.documentElement.doScroll && win == win.top) {
					(function() {
						if (t.domLoaded)
							return;

						try {
							// If IE is used, use the trick by Diego Perini licensed under MIT by request to the author.
							// http://javascript.nwbox.com/IEContentLoaded/
							doc.documentElement.doScroll("left");
						} catch (ex) {
							setTimeout(arguments.callee, 0);
							return;
						}

						t._pageInit(win);
					})();
				}
			} else if (doc.addEventListener) {
				t._add(win, 'DOMContentLoaded', function() {
					t._pageInit(win);
				});
			}

			t._add(win, 'load', function() {
				t._pageInit(win);
			});
		},

		_stoppers : {
			preventDefault : function() {
				this.returnValue = false;
			},

			stopPropagation : function() {
				this.cancelBubble = true;
			}
		}
	});

	/**
	 * Instance of EventUtils for the current document.
	 *
	 * @property Event
	 * @member tinymce.dom
	 * @type tinymce.dom.EventUtils
	 */
	Event = tinymce.dom.Event = new tinymce.dom.EventUtils();

	// Dispatch DOM content loaded event for IE and Safari
	Event._wait(window);

	tinymce.addUnload(function() {
		Event.destroy();
	});
})(tinymce);
/**
 * Element.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	/**
	 * Element class, this enables element blocking in IE. Element blocking is a method to block out select blockes that
	 * gets visible though DIVs on IE 6 it uses a iframe for this blocking. This class also shortens the length of some DOM API calls
	 * since it's bound to an element.
	 *
	 * @class tinymce.dom.Element
	 * @example
	 * // Creates an basic element for an existing element
	 * var elm = new tinymce.dom.Element('someid');
	 *
	 * elm.setStyle('background-color', 'red');
	 * elm.moveTo(10, 10);
	 */

	/**
	 * Constructs a new Element instance. Consult the Wiki for more details on this class.
	 *
	 * @constructor
	 * @method Element
	 * @param {String} id Element ID to bind/execute methods on.
	 * @param {Object} settings Optional settings name/value collection.
	 */
	tinymce.dom.Element = function(id, settings) {
		var t = this, dom, el;

		t.settings = settings = settings || {};
		t.id = id;
		t.dom = dom = settings.dom || tinymce.DOM;

		// Only IE leaks DOM references, this is a lot faster
		if (!tinymce.isIE)
			el = dom.get(t.id);

		tinymce.each(
				('getPos,getRect,getParent,add,setStyle,getStyle,setStyles,' +
				'setAttrib,setAttribs,getAttrib,addClass,removeClass,' +
				'hasClass,getOuterHTML,setOuterHTML,remove,show,hide,' +
				'isHidden,setHTML,get').split(/,/)
			, function(k) {
				t[k] = function() {
					var a = [id], i;

					for (i = 0; i < arguments.length; i++)
						a.push(arguments[i]);

					a = dom[k].apply(dom, a);
					t.update(k);

					return a;
				};
		});

		tinymce.extend(t, {
			/**
			 * Adds a event handler to the element.
			 *
			 * @method on
			 * @param {String} n Event name like for example "click".
			 * @param {function} f Function to execute on the specified event.
			 * @param {Object} s Optional scope to execute function on.
			 * @return {function} Event handler function the same as the input function.
			 */
			on : function(n, f, s) {
				return tinymce.dom.Event.add(t.id, n, f, s);
			},

			/**
			 * Returns the absolute X, Y cordinate of the element.
			 *
			 * @method getXY
			 * @return {Object} Objext with x, y cordinate fields.
			 */
			getXY : function() {
				return {
					x : parseInt(t.getStyle('left')),
					y : parseInt(t.getStyle('top'))
				};
			},

			/**
			 * Returns the size of the element by a object with w and h fields.
			 *
			 * @method getSize
			 * @return {Object} Object with element size with a w and h field.
			 */
			getSize : function() {
				var n = dom.get(t.id);

				return {
					w : parseInt(t.getStyle('width') || n.clientWidth),
					h : parseInt(t.getStyle('height') || n.clientHeight)
				};
			},

			/**
			 * Moves the element to a specific absolute position.
			 *
			 * @method moveTo
			 * @param {Number} x X cordinate of element position.
			 * @param {Number} y Y cordinate of element position.
			 */
			moveTo : function(x, y) {
				t.setStyles({left : x, top : y});
			},

			/**
			 * Moves the element relative to the current position.
			 *
			 * @method moveBy
			 * @param {Number} x Relative X cordinate of element position.
			 * @param {Number} y Relative Y cordinate of element position.
			 */
			moveBy : function(x, y) {
				var p = t.getXY();

				t.moveTo(p.x + x, p.y + y);
			},

			/**
			 * Resizes the element to a specific size.
			 *
			 * @method resizeTo
			 * @param {Number} w New width of element.
			 * @param {Numner} h New height of element.
			 */
			resizeTo : function(w, h) {
				t.setStyles({width : w, height : h});
			},

			/**
			 * Resizes the element relative to the current sizeto a specific size.
			 *
			 * @method resizeBy
			 * @param {Number} w Relative width of element.
			 * @param {Numner} h Relative height of element.
			 */
			resizeBy : function(w, h) {
				var s = t.getSize();

				t.resizeTo(s.w + w, s.h + h);
			},

			/**
			 * Updates the element blocker in IE6 based on the style information of the element.
			 *
			 * @method update
			 * @param {String} k Optional function key. Used internally.
			 */
			update : function(k) {
				var b;

				if (tinymce.isIE6 && settings.blocker) {
					k = k || '';

					// Ignore getters
					if (k.indexOf('get') === 0 || k.indexOf('has') === 0 || k.indexOf('is') === 0)
						return;

					// Remove blocker on remove
					if (k == 'remove') {
						dom.remove(t.blocker);
						return;
					}

					if (!t.blocker) {
						t.blocker = dom.uniqueId();
						b = dom.add(settings.container || dom.getRoot(), 'iframe', {id : t.blocker, style : 'position:absolute;', frameBorder : 0, src : 'javascript:""'});
						dom.setStyle(b, 'opacity', 0);
					} else
						b = dom.get(t.blocker);

					dom.setStyles(b, {
						left : t.getStyle('left', 1),
						top : t.getStyle('top', 1),
						width : t.getStyle('width', 1),
						height : t.getStyle('height', 1),
						display : t.getStyle('display', 1),
						zIndex : parseInt(t.getStyle('zIndex', 1) || 0) - 1
					});
				}
			}
		});
	};
})(tinymce);
/**
 * Selection.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	function trimNl(s) {
		return s.replace(/[\n\r]+/g, '');
	};

	// Shorten names
	var is = tinymce.is, isIE = tinymce.isIE, each = tinymce.each;

	/**
	 * This class handles text and control selection it's an crossbrowser utility class.
	 * Consult the TinyMCE Wiki API for more details and examples on how to use this class.
	 *
	 * @class tinymce.dom.Selection
	 * @example
	 * // Getting the currently selected node for the active editor
	 * alert(tinymce.activeEditor.selection.getNode().nodeName);
	 */
	tinymce.create('tinymce.dom.Selection', {
		/**
		 * Constructs a new selection instance.
		 *
		 * @constructor
		 * @method Selection
		 * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.
		 * @param {Window} win Window to bind the selection object to.
		 * @param {tinymce.dom.Serializer} serializer DOM serialization class to use for getContent.
		 */
		Selection : function(dom, win, serializer) {
			var t = this;

			t.dom = dom;
			t.win = win;
			t.serializer = serializer;

			// Add events
			each([
				/**
				 * This event gets executed before contents is extracted from the selection.
				 *
				 * @event onBeforeSetContent
				 * @param {tinymce.dom.Selection} selection Selection object that fired the event.
				 * @param {Object} args Contains things like the contents that will be returned.
				 */
				'onBeforeSetContent',

				/**
				 * This event gets executed before contents is inserted into selection.
				 *
				 * @event onBeforeGetContent
				 * @param {tinymce.dom.Selection} selection Selection object that fired the event.
				 * @param {Object} args Contains things like the contents that will be inserted.
				 */
				'onBeforeGetContent',

				/**
				 * This event gets executed when contents is inserted into selection.
				 *
				 * @event onSetContent
				 * @param {tinymce.dom.Selection} selection Selection object that fired the event.
				 * @param {Object} args Contains things like the contents that will be inserted.
				 */
				'onSetContent',

				/**
				 * This event gets executed when contents is extracted from the selection.
				 *
				 * @event onGetContent
				 * @param {tinymce.dom.Selection} selection Selection object that fired the event.
				 * @param {Object} args Contains things like the contents that will be returned.
				 */
				'onGetContent'
			], function(e) {
				t[e] = new tinymce.util.Dispatcher(t);
			});

			// No W3C Range support
			if (!t.win.getSelection)
				t.tridentSel = new tinymce.dom.TridentSelection(t);

			if (tinymce.isIE && dom.boxModel)
				this._fixIESelection();

			// Prevent leaks
			tinymce.addUnload(t.destroy, t);
		},

		/**
		 * Move the selection cursor range to the specified node and offset.
		 * @param node Node to put the cursor in.
		 * @param offset Offset from the start of the node to put the cursor at.
		 */
		setCursorLocation: function(node, offset) {
			var t = this; var r = t.dom.createRng();
			r.setStart(node, offset);
			r.setEnd(node, offset);
			t.setRng(r);
			t.collapse(false);
		},
		/**
		 * Returns the selected contents using the DOM serializer passed in to this class.
		 *
		 * @method getContent
		 * @param {Object} s Optional settings class with for example output format text or html.
		 * @return {String} Selected contents in for example HTML format.
		 * @example
		 * // Alerts the currently selected contents
		 * alert(tinyMCE.activeEditor.selection.getContent());
		 *
		 * // Alerts the currently selected contents as plain text
		 * alert(tinyMCE.activeEditor.selection.getContent({format : 'text'}));
		 */
		getContent : function(s) {
			var t = this, r = t.getRng(), e = t.dom.create("body"), se = t.getSel(), wb, wa, n;

			s = s || {};
			wb = wa = '';
			s.get = true;
			s.format = s.format || 'html';
			s.forced_root_block = '';
			t.onBeforeGetContent.dispatch(t, s);

			if (s.format == 'text')
				return t.isCollapsed() ? '' : (r.text || (se.toString ? se.toString() : ''));

			if (r.cloneContents) {
				n = r.cloneContents();

				if (n)
					e.appendChild(n);
			} else if (is(r.item) || is(r.htmlText)) {
				// IE will produce invalid markup if elements are present that
				// it doesn't understand like custom elements or HTML5 elements.
				// Adding a BR in front of the contents and then remoiving it seems to fix it though.
				e.innerHTML = '<br>' + (r.item ? r.item(0).outerHTML : r.htmlText);
				e.removeChild(e.firstChild);
			} else
				e.innerHTML = r.toString();

			// Keep whitespace before and after
			if (/^\s/.test(e.innerHTML))
				wb = ' ';

			if (/\s+$/.test(e.innerHTML))
				wa = ' ';

			s.getInner = true;

			s.content = t.isCollapsed() ? '' : wb + t.serializer.serialize(e, s) + wa;
			t.onGetContent.dispatch(t, s);

			return s.content;
		},

		/**
		 * Sets the current selection to the specified content. If any contents is selected it will be replaced
		 * with the contents passed in to this function. If there is no selection the contents will be inserted
		 * where the caret is placed in the editor/page.
		 *
		 * @method setContent
		 * @param {String} content HTML contents to set could also be other formats depending on settings.
		 * @param {Object} args Optional settings object with for example data format.
		 * @example
		 * // Inserts some HTML contents at the current selection
		 * tinyMCE.activeEditor.selection.setContent('<strong>Some contents</strong>');
		 */
		setContent : function(content, args) {
			var self = this, rng = self.getRng(), caretNode, doc = self.win.document, frag, temp;

			args = args || {format : 'html'};
			args.set = true;
			content = args.content = content;

			// Dispatch before set content event
			if (!args.no_events)
				self.onBeforeSetContent.dispatch(self, args);

			content = args.content;

			if (rng.insertNode) {
				// Make caret marker since insertNode places the caret in the beginning of text after insert
				content += '<span id="__caret">_</span>';

				// Delete and insert new node
				if (rng.startContainer == doc && rng.endContainer == doc) {
					// WebKit will fail if the body is empty since the range is then invalid and it can't insert contents
					doc.body.innerHTML = content;
				} else {
					rng.deleteContents();

					if (doc.body.childNodes.length == 0) {
						doc.body.innerHTML = content;
					} else {
						// createContextualFragment doesn't exists in IE 9 DOMRanges
						if (rng.createContextualFragment) {
							rng.insertNode(rng.createContextualFragment(content));
						} else {
							// Fake createContextualFragment call in IE 9
							frag = doc.createDocumentFragment();
							temp = doc.createElement('div');

							frag.appendChild(temp);
							temp.outerHTML = content;

							rng.insertNode(frag);
						}
					}
				}

				// Move to caret marker
				caretNode = self.dom.get('__caret');

				// Make sure we wrap it compleatly, Opera fails with a simple select call
				rng = doc.createRange();
				rng.setStartBefore(caretNode);
				rng.setEndBefore(caretNode);
				self.setRng(rng);

				// Remove the caret position
				self.dom.remove('__caret');

				try {
					self.setRng(rng);
				} catch (ex) {
					// Might fail on Opera for some odd reason
				}
			} else {
				if (rng.item) {
					// Delete content and get caret text selection
					doc.execCommand('Delete', false, null);
					rng = self.getRng();
				}

				// Explorer removes spaces from the beginning of pasted contents
				if (/^\s+/.test(content)) {
					rng.pasteHTML('<span id="__mce_tmp">_</span>' + content);
					self.dom.remove('__mce_tmp');
				} else
					rng.pasteHTML(content);
			}

			// Dispatch set content event
			if (!args.no_events)
				self.onSetContent.dispatch(self, args);
		},

		/**
		 * Returns the start element of a selection range. If the start is in a text
		 * node the parent element will be returned.
		 *
		 * @method getStart
		 * @return {Element} Start element of selection range.
		 */
		getStart : function() {
			var rng = this.getRng(), startElement, parentElement, checkRng, node;

			if (rng.duplicate || rng.item) {
				// Control selection, return first item
				if (rng.item)
					return rng.item(0);

				// Get start element
				checkRng = rng.duplicate();
				checkRng.collapse(1);
				startElement = checkRng.parentElement();

				// Check if range parent is inside the start element, then return the inner parent element
				// This will fix issues when a single element is selected, IE would otherwise return the wrong start element
				parentElement = node = rng.parentElement();
				while (node = node.parentNode) {
					if (node == startElement) {
						startElement = parentElement;
						break;
					}
				}

				return startElement;
			} else {
				startElement = rng.startContainer;

				if (startElement.nodeType == 1 && startElement.hasChildNodes())
					startElement = startElement.childNodes[Math.min(startElement.childNodes.length - 1, rng.startOffset)];

				if (startElement && startElement.nodeType == 3)
					return startElement.parentNode;

				return startElement;
			}
		},

		/**
		 * Returns the end element of a selection range. If the end is in a text
		 * node the parent element will be returned.
		 *
		 * @method getEnd
		 * @return {Element} End element of selection range.
		 */
		getEnd : function() {
			var t = this, r = t.getRng(), e, eo;

			if (r.duplicate || r.item) {
				if (r.item)
					return r.item(0);

				r = r.duplicate();
				r.collapse(0);
				e = r.parentElement();

				if (e && e.nodeName == 'BODY')
					return e.lastChild || e;

				return e;
			} else {
				e = r.endContainer;
				eo = r.endOffset;

				if (e.nodeType == 1 && e.hasChildNodes())
					e = e.childNodes[eo > 0 ? eo - 1 : eo];

				if (e && e.nodeType == 3)
					return e.parentNode;

				return e;
			}
		},

		/**
		 * Returns a bookmark location for the current selection. This bookmark object
		 * can then be used to restore the selection after some content modification to the document.
		 *
		 * @method getBookmark
		 * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
		 * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
		 * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
		 * @example
		 * // Stores a bookmark of the current selection
		 * var bm = tinyMCE.activeEditor.selection.getBookmark();
		 *
		 * tinyMCE.activeEditor.setContent(tinyMCE.activeEditor.getContent() + 'Some new content');
		 *
		 * // Restore the selection bookmark
		 * tinyMCE.activeEditor.selection.moveToBookmark(bm);
		 */
		getBookmark : function(type, normalized) {
			var t = this, dom = t.dom, rng, rng2, id, collapsed, name, element, index, chr = '\uFEFF', styles;

			function findIndex(name, element) {
				var index = 0;

				each(dom.select(name), function(node, i) {
					if (node == element)
						index = i;
				});

				return index;
			};

			if (type == 2) {
				function getLocation() {
					var rng = t.getRng(true), root = dom.getRoot(), bookmark = {};

					function getPoint(rng, start) {
						var container = rng[start ? 'startContainer' : 'endContainer'],
							offset = rng[start ? 'startOffset' : 'endOffset'], point = [], node, childNodes, after = 0;

						if (container.nodeType == 3) {
							if (normalized) {
								for (node = container.previousSibling; node && node.nodeType == 3; node = node.previousSibling)
									offset += node.nodeValue.length;
							}

							point.push(offset);
						} else {
							childNodes = container.childNodes;

							if (offset >= childNodes.length && childNodes.length) {
								after = 1;
								offset = Math.max(0, childNodes.length - 1);
							}

							point.push(t.dom.nodeIndex(childNodes[offset], normalized) + after);
						}

						for (; container && container != root; container = container.parentNode)
							point.push(t.dom.nodeIndex(container, normalized));

						return point;
					};

					bookmark.start = getPoint(rng, true);

					if (!t.isCollapsed())
						bookmark.end = getPoint(rng);

					return bookmark;
				};

				if (t.tridentSel)
					return t.tridentSel.getBookmark(type);

				return getLocation();
			}

			// Handle simple range
			if (type)
				return {rng : t.getRng()};

			rng = t.getRng();
			id = dom.uniqueId();
			collapsed = tinyMCE.activeEditor.selection.isCollapsed();
			styles = 'overflow:hidden;line-height:0px';

			// Explorer method
			if (rng.duplicate || rng.item) {
				// Text selection
				if (!rng.item) {
					rng2 = rng.duplicate();

					try {
						// Insert start marker
						rng.collapse();
						rng.pasteHTML('<span data-mce-type="bookmark" id="' + id + '_start" style="' + styles + '">' + chr + '</span>');

						// Insert end marker
						if (!collapsed) {
							rng2.collapse(false);

							// Detect the empty space after block elements in IE and move the end back one character <p></p>] becomes <p>]</p>
							rng.moveToElementText(rng2.parentElement());
							if (rng.compareEndPoints('StartToEnd', rng2) == 0)
								rng2.move('character', -1);

							rng2.pasteHTML('<span data-mce-type="bookmark" id="' + id + '_end" style="' + styles + '">' + chr + '</span>');
						}
					} catch (ex) {
						// IE might throw unspecified error so lets ignore it
						return null;
					}
				} else {
					// Control selection
					element = rng.item(0);
					name = element.nodeName;

					return {name : name, index : findIndex(name, element)};
				}
			} else {
				element = t.getNode();
				name = element.nodeName;
				if (name == 'IMG')
					return {name : name, index : findIndex(name, element)};

				// W3C method
				rng2 = rng.cloneRange();

				// Insert end marker
				if (!collapsed) {
					rng2.collapse(false);
					rng2.insertNode(dom.create('span', {'data-mce-type' : "bookmark", id : id + '_end', style : styles}, chr));
				}

				rng.collapse(true);
				rng.insertNode(dom.create('span', {'data-mce-type' : "bookmark", id : id + '_start', style : styles}, chr));
			}

			t.moveToBookmark({id : id, keep : 1});

			return {id : id};
		},

		/**
		 * Restores the selection to the specified bookmark.
		 *
		 * @method moveToBookmark
		 * @param {Object} bookmark Bookmark to restore selection from.
		 * @return {Boolean} true/false if it was successful or not.
		 * @example
		 * // Stores a bookmark of the current selection
		 * var bm = tinyMCE.activeEditor.selection.getBookmark();
		 *
		 * tinyMCE.activeEditor.setContent(tinyMCE.activeEditor.getContent() + 'Some new content');
		 *
		 * // Restore the selection bookmark
		 * tinyMCE.activeEditor.selection.moveToBookmark(bm);
		 */
		moveToBookmark : function(bookmark) {
			var t = this, dom = t.dom, marker1, marker2, rng, root, startContainer, endContainer, startOffset, endOffset;

			if (bookmark) {
				if (bookmark.start) {
					rng = dom.createRng();
					root = dom.getRoot();

					function setEndPoint(start) {
						var point = bookmark[start ? 'start' : 'end'], i, node, offset, children;

						if (point) {
							offset = point[0];

							// Find container node
							for (node = root, i = point.length - 1; i >= 1; i--) {
								children = node.childNodes;

								if (point[i] > children.length - 1)
									return;

								node = children[point[i]];
							}

							// Move text offset to best suitable location
							if (node.nodeType === 3)
								offset = Math.min(point[0], node.nodeValue.length);

							// Move element offset to best suitable location
							if (node.nodeType === 1)
								offset = Math.min(point[0], node.childNodes.length);

							// Set offset within container node
							if (start)
								rng.setStart(node, offset);
							else
								rng.setEnd(node, offset);
						}

						return true;
					};

					if (t.tridentSel)
						return t.tridentSel.moveToBookmark(bookmark);

					if (setEndPoint(true) && setEndPoint()) {
						t.setRng(rng);
					}
				} else if (bookmark.id) {
					function restoreEndPoint(suffix) {
						var marker = dom.get(bookmark.id + '_' + suffix), node, idx, next, prev, keep = bookmark.keep;

						if (marker) {
							node = marker.parentNode;

							if (suffix == 'start') {
								if (!keep) {
									idx = dom.nodeIndex(marker);
								} else {
									node = marker.firstChild;
									idx = 1;
								}

								startContainer = endContainer = node;
								startOffset = endOffset = idx;
							} else {
								if (!keep) {
									idx = dom.nodeIndex(marker);
								} else {
									node = marker.firstChild;
									idx = 1;
								}

								endContainer = node;
								endOffset = idx;
							}

							if (!keep) {
								prev = marker.previousSibling;
								next = marker.nextSibling;

								// Remove all marker text nodes
								each(tinymce.grep(marker.childNodes), function(node) {
									if (node.nodeType == 3)
										node.nodeValue = node.nodeValue.replace(/\uFEFF/g, '');
								});

								// Remove marker but keep children if for example contents where inserted into the marker
								// Also remove duplicated instances of the marker for example by a split operation or by WebKit auto split on paste feature
								while (marker = dom.get(bookmark.id + '_' + suffix))
									dom.remove(marker, 1);

								// If siblings are text nodes then merge them unless it's Opera since it some how removes the node
								// and we are sniffing since adding a lot of detection code for a browser with 3% of the market isn't worth the effort. Sorry, Opera but it's just a fact
								if (prev && next && prev.nodeType == next.nodeType && prev.nodeType == 3 && !tinymce.isOpera) {
									idx = prev.nodeValue.length;
									prev.appendData(next.nodeValue);
									dom.remove(next);

									if (suffix == 'start') {
										startContainer = endContainer = prev;
										startOffset = endOffset = idx;
									} else {
										endContainer = prev;
										endOffset = idx;
									}
								}
							}
						}
					};

					function addBogus(node) {
						// Adds a bogus BR element for empty block elements or just a space on IE since it renders BR elements incorrectly
						if (dom.isBlock(node) && !node.innerHTML)
							node.innerHTML = !isIE ? '<br data-mce-bogus="1" />' : ' ';

						return node;
					};

					// Restore start/end points
					restoreEndPoint('start');
					restoreEndPoint('end');

					if (startContainer) {
						rng = dom.createRng();
						rng.setStart(addBogus(startContainer), startOffset);
						rng.setEnd(addBogus(endContainer), endOffset);
						t.setRng(rng);
					}
				} else if (bookmark.name) {
					t.select(dom.select(bookmark.name)[bookmark.index]);
				} else if (bookmark.rng)
					t.setRng(bookmark.rng);
			}
		},

		/**
		 * Selects the specified element. This will place the start and end of the selection range around the element.
		 *
		 * @method select
		 * @param {Element} node HMTL DOM element to select.
		 * @param {Boolean} content Optional bool state if the contents should be selected or not on non IE browser.
		 * @return {Element} Selected element the same element as the one that got passed in.
		 * @example
		 * // Select the first paragraph in the active editor
		 * tinyMCE.activeEditor.selection.select(tinyMCE.activeEditor.dom.select('p')[0]);
		 */
		select : function(node, content) {
			var t = this, dom = t.dom, rng = dom.createRng(), idx;

			if (node) {
				idx = dom.nodeIndex(node);
				rng.setStart(node.parentNode, idx);
				rng.setEnd(node.parentNode, idx + 1);

				// Find first/last text node or BR element
				if (content) {
					function setPoint(node, start) {
						var walker = new tinymce.dom.TreeWalker(node, node);

						do {
							// Text node
							if (node.nodeType == 3 && tinymce.trim(node.nodeValue).length != 0) {
								if (start)
									rng.setStart(node, 0);
								else
									rng.setEnd(node, node.nodeValue.length);

								return;
							}

							// BR element
							if (node.nodeName == 'BR') {
								if (start)
									rng.setStartBefore(node);
								else
									rng.setEndBefore(node);

								return;
							}
						} while (node = (start ? walker.next() : walker.prev()));
					};

					setPoint(node, 1);
					setPoint(node);
				}

				t.setRng(rng);
			}

			return node;
		},

		/**
		 * Returns true/false if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.
		 *
		 * @method isCollapsed
		 * @return {Boolean} true/false state if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.
		 */
		isCollapsed : function() {
			var t = this, r = t.getRng(), s = t.getSel();

			if (!r || r.item)
				return false;

			if (r.compareEndPoints)
				return r.compareEndPoints('StartToEnd', r) === 0;

			return !s || r.collapsed;
		},

		/**
		 * Collapse the selection to start or end of range.
		 *
		 * @method collapse
		 * @param {Boolean} to_start Optional boolean state if to collapse to end or not. Defaults to start.
		 */
		collapse : function(to_start) {
			var self = this, rng = self.getRng(), node;

			// Control range on IE
			if (rng.item) {
				node = rng.item(0);
				rng = self.win.document.body.createTextRange();
				rng.moveToElementText(node);
			}

			rng.collapse(!!to_start);
			self.setRng(rng);
		},

		/**
		 * Returns the browsers internal selection object.
		 *
		 * @method getSel
		 * @return {Selection} Internal browser selection object.
		 */
		getSel : function() {
			var t = this, w = this.win;

			return w.getSelection ? w.getSelection() : w.document.selection;
		},

		/**
		 * Returns the browsers internal range object.
		 *
		 * @method getRng
		 * @param {Boolean} w3c Forces a compatible W3C range on IE.
		 * @return {Range} Internal browser range object.
		 * @see http://www.quirksmode.org/dom/range_intro.html
		 * @see http://www.dotvoid.com/2001/03/using-the-range-object-in-mozilla/
		 */
		getRng : function(w3c) {
			var t = this, s, r, elm, doc = t.win.document;

			// Found tridentSel object then we need to use that one
			if (w3c && t.tridentSel)
				return t.tridentSel.getRangeAt(0);

			try {
				if (s = t.getSel())
					r = s.rangeCount > 0 ? s.getRangeAt(0) : (s.createRange ? s.createRange() : doc.createRange());
			} catch (ex) {
				// IE throws unspecified error here if TinyMCE is placed in a frame/iframe
			}

			// We have W3C ranges and it's IE then fake control selection since IE9 doesn't handle that correctly yet
			if (tinymce.isIE && r && r.setStart && doc.selection.createRange().item) {
				elm = doc.selection.createRange().item(0);
				r = doc.createRange();
				r.setStartBefore(elm);
				r.setEndAfter(elm);
			}

			// No range found then create an empty one
			// This can occur when the editor is placed in a hidden container element on Gecko
			// Or on IE when there was an exception
			if (!r)
				r = doc.createRange ? doc.createRange() : doc.body.createTextRange();

			if (t.selectedRange && t.explicitRange) {
				if (r.compareBoundaryPoints(r.START_TO_START, t.selectedRange) === 0 && r.compareBoundaryPoints(r.END_TO_END, t.selectedRange) === 0) {
					// Safari, Opera and Chrome only ever select text which causes the range to change.
					// This lets us use the originally set range if the selection hasn't been changed by the user.
					r = t.explicitRange;
				} else {
					t.selectedRange = null;
					t.explicitRange = null;
				}
			}

			return r;
		},

		/**
		 * Changes the selection to the specified DOM range.
		 *
		 * @method setRng
		 * @param {Range} r Range to select.
		 */
		setRng : function(r) {
			var s, t = this;

			if (!t.tridentSel) {
				s = t.getSel();

				if (s) {

					t.explicitRange = r;

					try {
						s.removeAllRanges();
					} catch (ex) {
						// IE9 might throw errors here don't know why
					}

					s.addRange(r);

					// berkel: MAIL-4335 (INDEX_SIZE_ERR: DOM Exception when rangeCount = 0)
					if (s.rangeCount > 0) {
						t.selectedRange = s.getRangeAt(0);
					}
				}
			} else {
				// Is W3C Range
				if (r.cloneRange) {
					t.tridentSel.addRange(r);
					return;
				}

				// Is IE specific range
				try {
					r.select();
				} catch (ex) {
					// Needed for some odd IE bug #1843306
				}
			}
		},

		/**
		 * Sets the current selection to the specified DOM element.
		 *
		 * @method setNode
		 * @param {Element} n Element to set as the contents of the selection.
		 * @return {Element} Returns the element that got passed in.
		 * @example
		 * // Inserts a DOM node at current selection/caret location
		 * tinyMCE.activeEditor.selection.setNode(tinyMCE.activeEditor.dom.create('img', {src : 'some.gif', title : 'some title'}));
		 */
		setNode : function(n) {
			var t = this;

			t.setContent(t.dom.getOuterHTML(n));

			return n;
		},

		/**
		 * Returns the currently selected element or the common ancestor element for both start and end of the selection.
		 *
		 * @method getNode
		 * @return {Element} Currently selected element or common ancestor element.
		 * @example
		 * // Alerts the currently selected elements node name
		 * alert(tinyMCE.activeEditor.selection.getNode().nodeName);
		 */
		getNode : function() {
			var t = this, rng = t.getRng(), sel = t.getSel(), elm, start = rng.startContainer, end = rng.endContainer;

			// Range maybe lost after the editor is made visible again
			if (!rng)
				return t.dom.getRoot();

			if (rng.setStart) {
				elm = rng.commonAncestorContainer;

				// Handle selection a image or other control like element such as anchors
				if (!rng.collapsed) {
					if (rng.startContainer == rng.endContainer) {
						if (rng.endOffset - rng.startOffset < 2) {
							if (rng.startContainer.hasChildNodes())
								elm = rng.startContainer.childNodes[rng.startOffset];
						}
					}

					// If the anchor node is a element instead of a text node then return this element
					//if (tinymce.isWebKit && sel.anchorNode && sel.anchorNode.nodeType == 1)
					//	return sel.anchorNode.childNodes[sel.anchorOffset];

					// Handle cases where the selection is immediately wrapped around a node and return that node instead of it's parent.
					// This happens when you double click an underlined word in FireFox.
					if (start.nodeType === 3 && end.nodeType === 3) {
						function skipEmptyTextNodes(n, forwards) {
							var orig = n;
							while (n && n.nodeType === 3 && n.length === 0) {
								n = forwards ? n.nextSibling : n.previousSibling;
							}
							return n || orig;
						}
						if (start.length === rng.startOffset) {
							start = skipEmptyTextNodes(start.nextSibling, true);
						} else {
							start = start.parentNode;
						}
						if (rng.endOffset === 0) {
							end = skipEmptyTextNodes(end.previousSibling, false);
						} else {
							end = end.parentNode;
						}

						if (start && start === end)
							return start;
					}
				}

				if (elm && elm.nodeType == 3)
					return elm.parentNode;

				return elm;
			}

			return rng.item ? rng.item(0) : rng.parentElement();
		},

		getSelectedBlocks : function(st, en) {
			var t = this, dom = t.dom, sb, eb, n, bl = [];

			sb = dom.getParent(st || t.getStart(), dom.isBlock);
			eb = dom.getParent(en || t.getEnd(), dom.isBlock);

			if (sb)
				bl.push(sb);

			if (sb && eb && sb != eb) {
				n = sb;

				while ((n = n.nextSibling) && n != eb) {
					if (dom.isBlock(n))
						bl.push(n);
				}
			}

			if (eb && sb != eb)
				bl.push(eb);

			return bl;
		},

		normalize : function() {
			var self = this, rng, normalized;

			// Normalize only on non IE browsers for now
			if (tinymce.isIE)
				return;

			function normalizeEndPoint(start) {
				var container, offset, walker, dom = self.dom, body = dom.getRoot(), node;

				container = rng[(start ? 'start' : 'end') + 'Container'];
				offset = rng[(start ? 'start' : 'end') + 'Offset'];

				// If the container is a document move it to the body element
				if (container.nodeType === 9) {
					container = container.body;
					offset = 0;
				}

				// If the container is body try move it into the closest text node or position
				// TODO: Add more logic here to handle element selection cases
				if (container === body) {
					// Resolve the index
					if (container.hasChildNodes()) {
						container = container.childNodes[Math.min(!start && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1)];
						offset = 0;

						// Don't walk into elements that doesn't have any child nodes like a IMG
						if (container.hasChildNodes()) {
							// Walk the DOM to find a text node to place the caret at or a BR
							node = container;
							walker = new tinymce.dom.TreeWalker(container, body);
							do {
								// Found a text node use that position
								// berkel: MAIL-4260 (INDEX_SIZE_ERR: DOM Exception when offset = -1)
								if (node.nodeType === 3 && node.nodeValue) {
									offset = start ? 0 : node.nodeValue.length - 1;
									container = node;
									break;
								}

								// Found a BR element that we can place the caret before
								if (node.nodeName === 'BR') {
									offset = dom.nodeIndex(node);
									container = node.parentNode;
									break;
								}
							} while (node = (start ? walker.next() : walker.prev()));

							normalized = true;
						}
					}
				}

				// Set endpoint if it was normalized
				if (normalized)
					rng['set' + (start ? 'Start' : 'End')](container, offset);
			};

			rng = self.getRng();

			// Normalize the end points
			normalizeEndPoint(true);

			if (rng.collapsed)
				normalizeEndPoint();

			// Set the selection if it was normalized
			if (normalized) {
				//console.log(self.dom.dumpRng(rng));
				self.setRng(rng);
			}
		},

		destroy : function(s) {
			var t = this;

			t.win = null;

			// Manual destroy then remove unload handler
			if (!s)
				tinymce.removeUnload(t.destroy);
		},

		// IE has an issue where you can't select/move the caret by clicking outside the body if the document is in standards mode
		_fixIESelection : function() {
			var dom = this.dom, doc = dom.doc, body = doc.body, started, startRng, htmlElm;

			// Make HTML element unselectable since we are going to handle selection by hand
			doc.documentElement.unselectable = true;

			// Return range from point or null if it failed
			function rngFromPoint(x, y) {
				var rng = body.createTextRange();

				try {
					rng.moveToPoint(x, y);
				} catch (ex) {
					// IE sometimes throws and exception, so lets just ignore it
					rng = null;
				}

				return rng;
			};

			// Fires while the selection is changing
			function selectionChange(e) {
				var pointRng;

				// Check if the button is down or not
				if (e.button) {
					// Create range from mouse position
					pointRng = rngFromPoint(e.x, e.y);

					if (pointRng) {
						// Check if pointRange is before/after selection then change the endPoint
						if (pointRng.compareEndPoints('StartToStart', startRng) > 0)
							pointRng.setEndPoint('StartToStart', startRng);
						else
							pointRng.setEndPoint('EndToEnd', startRng);

						pointRng.select();
					}
				} else
					endSelection();
			}

			// Removes listeners
			function endSelection() {
				var rng = doc.selection.createRange();

				// If the range is collapsed then use the last start range
				if (startRng && !rng.item && rng.compareEndPoints('StartToEnd', rng) === 0)
					startRng.select();

				dom.unbind(doc, 'mouseup', endSelection);
				dom.unbind(doc, 'mousemove', selectionChange);
				startRng = started = 0;
			};

			// Detect when user selects outside BODY
			dom.bind(doc, ['mousedown', 'contextmenu'], function(e) {
				if (e.target.nodeName === 'HTML') {
					if (started)
						endSelection();

					// Detect vertical scrollbar, since IE will fire a mousedown on the scrollbar and have target set as HTML
					htmlElm = doc.documentElement;
					if (htmlElm.scrollHeight > htmlElm.clientHeight)
						return;

					started = 1;
					// Setup start position
					startRng = rngFromPoint(e.x, e.y);
					if (startRng) {
						// Listen for selection change events
						dom.bind(doc, 'mouseup', endSelection);
						dom.bind(doc, 'mousemove', selectionChange);

						dom.win.focus();
						startRng.select();
					}
				}
			});
		}
	});
})(tinymce);
/**
 * Serializer.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	/**
	 * This class is used to serialize DOM trees into a string. Consult the TinyMCE Wiki API for more details and examples on how to use this class.
	 *
	 * @class tinymce.dom.Serializer
	 */

	/**
	 * Constucts a new DOM serializer class.
	 *
	 * @constructor
	 * @method Serializer
	 * @param {Object} settings Serializer settings object.
	 * @param {tinymce.dom.DOMUtils} dom DOMUtils instance reference.
	 * @param {tinymce.html.Schema} schema Optional schema reference.
	 */
	tinymce.dom.Serializer = function(settings, dom, schema) {
		var onPreProcess, onPostProcess, isIE = tinymce.isIE, each = tinymce.each, htmlParser;

		// Support the old apply_source_formatting option
		if (!settings.apply_source_formatting)
			settings.indent = false;

		settings.remove_trailing_brs = true;

		// Default DOM and Schema if they are undefined
		dom = dom || tinymce.DOM;
		schema = schema || new tinymce.html.Schema(settings);
		settings.entity_encoding = settings.entity_encoding || 'named';

		/**
		 * This event gets executed before a HTML fragment gets serialized into a HTML string. This event enables you to do modifications to the DOM before the serialization occurs. It's important to know that the element that is getting serialized is cloned so it's not inside a document.
		 *
		 * @event onPreProcess
		 * @param {tinymce.dom.Serializer} sender object/Serializer instance that is serializing an element.
		 * @param {Object} args Object containing things like the current node.
		 * @example
		 * // Adds an observer to the onPreProcess event
		 * serializer.onPreProcess.add(function(se, o) {
		 *     // Add a class to each paragraph
		 *     se.dom.addClass(se.dom.select('p', o.node), 'myclass');
		 * });
		 */
		onPreProcess = new tinymce.util.Dispatcher(self);

		/**
		 * This event gets executed after a HTML fragment has been serialized into a HTML string. This event enables you to do modifications to the HTML string like regexp replaces etc.
		 *
		 * @event onPreProcess
		 * @param {tinymce.dom.Serializer} sender object/Serializer instance that is serializing an element.
		 * @param {Object} args Object containing things like the current contents.
		 * @example
		 * // Adds an observer to the onPostProcess event
		 * serializer.onPostProcess.add(function(se, o) {
		 *    // Remove all paragraphs and replace with BR
		 *    o.content = o.content.replace(/<p[^>]+>|<p>/g, '');
		 *    o.content = o.content.replace(/<\/p>/g, '<br />');
		 * });
		 */
		onPostProcess = new tinymce.util.Dispatcher(self);

		htmlParser = new tinymce.html.DomParser(settings, schema);

		// Convert move data-mce-src, data-mce-href and data-mce-style into nodes or process them if needed
		htmlParser.addAttributeFilter('src,href,style', function(nodes, name) {
			var i = nodes.length, node, value, internalName = 'data-mce-' + name, urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope, undef;

			while (i--) {
				node = nodes[i];

				value = node.attributes.map[internalName];
				if (value !== undef) {
					// Set external name to internal value and remove internal
					node.attr(name, value.length > 0 ? value : null);
					node.attr(internalName, null);
				} else {
					// No internal attribute found then convert the value we have in the DOM
					value = node.attributes.map[name];

					if (name === "style")
						value = dom.serializeStyle(dom.parseStyle(value), node.name);
					else if (urlConverter)
						value = urlConverter.call(urlConverterScope, value, name, node.name);

					node.attr(name, value.length > 0 ? value : null);
				}
			}
		});

		// Remove internal classes mceItem<..>
		htmlParser.addAttributeFilter('class', function(nodes, name) {
			var i = nodes.length, node, value;

			while (i--) {
				node = nodes[i];
				value = node.attr('class').replace(/\s*mce(Item\w+|Selected)\s*/g, '');
				node.attr('class', value.length > 0 ? value : null);
			}
		});

		// Remove bookmark elements
		htmlParser.addAttributeFilter('data-mce-type', function(nodes, name, args) {
			var i = nodes.length, node;

			while (i--) {
				node = nodes[i];

				if (node.attributes.map['data-mce-type'] === 'bookmark' && !args.cleanup)
					node.remove();
			}
		});

		// Force script into CDATA sections and remove the mce- prefix also add comments around styles
		htmlParser.addNodeFilter('script,style', function(nodes, name) {
			var i = nodes.length, node, value;

			function trim(value) {
				return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n')
						.replace(/^[\r\n]*|[\r\n]*$/g, '')
						.replace(/^\s*(\/\/\s*<!--|\/\/\s*<!\[CDATA\[|<!--|<!\[CDATA\[)[\r\n]*/g, '')
						.replace(/\s*(\/\/\s*\]\]>|\/\/\s*-->|\]\]>|-->|\]\]-->)\s*$/g, '');
			};

			while (i--) {
				node = nodes[i];
				value = node.firstChild ? node.firstChild.value : '';

				if (name === "script") {
					// Remove mce- prefix from script elements
					node.attr('type', (node.attr('type') || 'text/javascript').replace(/^mce\-/, ''));

					if (value.length > 0)
						node.firstChild.value = '// <![CDATA[\n' + trim(value) + '\n// ]]>';
				} else {
					if (value.length > 0)
						node.firstChild.value = '<!--\n' + trim(value) + '\n-->';
				}
			}
		});

		// Convert comments to cdata and handle protected comments
		htmlParser.addNodeFilter('#comment', function(nodes, name) {
			var i = nodes.length, node;

			while (i--) {
				node = nodes[i];

				if (node.value.indexOf('[CDATA[') === 0) {
					node.name = '#cdata';
					node.type = 4;
					node.value = node.value.replace(/^\[CDATA\[|\]\]$/g, '');
				} else if (node.value.indexOf('mce:protected ') === 0) {
					node.name = "#text";
					node.type = 3;
					node.raw = true;
					node.value = unescape(node.value).substr(14);
				}
			}
		});

		htmlParser.addNodeFilter('xml:namespace,input', function(nodes, name) {
			var i = nodes.length, node;

			while (i--) {
				node = nodes[i];
				if (node.type === 7)
					node.remove();
				else if (node.type === 1) {
					if (name === "input" && !("type" in node.attributes.map))
						node.attr('type', 'text');
				}
			}
		});

		// Fix list elements, TODO: Replace this later
		if (settings.fix_list_elements) {
			htmlParser.addNodeFilter('ul,ol', function(nodes, name) {
				var i = nodes.length, node, parentNode;

				while (i--) {
					node = nodes[i];
					parentNode = node.parent;

					if (parentNode.name === 'ul' || parentNode.name === 'ol') {
						if (node.prev && node.prev.name === 'li') {
							node.prev.append(node);
						}
					}
				}
			});
		}

		// Remove internal data attributes
		htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style', function(nodes, name) {
			var i = nodes.length;

			while (i--) {
				nodes[i].attr(name, null);
			}
		});

		// Return public methods
		return {
			/**
			 * Schema instance that was used to when the Serializer was constructed.
			 *
			 * @field {tinymce.html.Schema} schema
			 */
			schema : schema,

			/**
			 * Adds a node filter function to the parser used by the serializer, the parser will collect the specified nodes by name
			 * and then execute the callback ones it has finished parsing the document.
			 *
			 * @example
			 * parser.addNodeFilter('p,h1', function(nodes, name) {
			 *		for (var i = 0; i < nodes.length; i++) {
			 *			console.log(nodes[i].name);
			 *		}
			 * });
			 * @method addNodeFilter
			 * @method {String} name Comma separated list of nodes to collect.
			 * @param {function} callback Callback function to execute once it has collected nodes.
			 */
			addNodeFilter : htmlParser.addNodeFilter,

			/**
			 * Adds a attribute filter function to the parser used by the serializer, the parser will collect nodes that has the specified attributes
			 * and then execute the callback ones it has finished parsing the document.
			 *
			 * @example
			 * parser.addAttributeFilter('src,href', function(nodes, name) {
			 *		for (var i = 0; i < nodes.length; i++) {
			 *			console.log(nodes[i].name);
			 *		}
			 * });
			 * @method addAttributeFilter
			 * @method {String} name Comma separated list of nodes to collect.
			 * @param {function} callback Callback function to execute once it has collected nodes.
			 */
			addAttributeFilter : htmlParser.addAttributeFilter,

			/**
			 * Fires when the Serializer does a preProcess on the contents.
			 *
			 * @event onPreProcess
			 * @param {tinymce.Editor} sender Editor instance.
			 * @param {Object} obj PreProcess object.
			 * @option {Node} node DOM node for the item being serialized.
			 * @option {String} format The specified output format normally "html".
			 * @option {Boolean} get Is true if the process is on a getContent operation.
			 * @option {Boolean} set Is true if the process is on a setContent operation.
			 * @option {Boolean} cleanup Is true if the process is on a cleanup operation.
			 */
			onPreProcess : onPreProcess,

			/**
			 * Fires when the Serializer does a postProcess on the contents.
			 *
			 * @event onPostProcess
			 * @param {tinymce.Editor} sender Editor instance.
			 * @param {Object} obj PreProcess object.
			 */
			onPostProcess : onPostProcess,

			/**
			 * Serializes the specified browser DOM node into a HTML string.
			 *
			 * @method serialize
			 * @param {DOMNode} node DOM node to serialize.
			 * @param {Object} args Arguments option that gets passed to event handlers.
			 */
			serialize : function(node, args) {
				var impl, doc, oldDoc, htmlSerializer, content;

				// Explorer won't clone contents of script and style and the
				// selected index of select elements are cleared on a clone operation.
				if (isIE && dom.select('script,style,select,map').length > 0) {
					content = node.innerHTML;
					node = node.cloneNode(false);
					dom.setHTML(node, content);
				} else
					node = node.cloneNode(true);

				// Nodes needs to be attached to something in WebKit/Opera
				// Older builds of Opera crashes if you attach the node to an document created dynamically
				// and since we can't feature detect a crash we need to sniff the acutal build number
				// This fix will make DOM ranges and make Sizzle happy!
				impl = node.ownerDocument.implementation;
				if (impl.createHTMLDocument) {
					// Create an empty HTML document
					doc = impl.createHTMLDocument("");

					// Add the element or it's children if it's a body element to the new document
					each(node.nodeName == 'BODY' ? node.childNodes : [node], function(node) {
						doc.body.appendChild(doc.importNode(node, true));
					});

					// Grab first child or body element for serialization
					if (node.nodeName != 'BODY')
						node = doc.body.firstChild;
					else
						node = doc.body;

					// set the new document in DOMUtils so createElement etc works
					oldDoc = dom.doc;
					dom.doc = doc;
				}

				args = args || {};
				args.format = args.format || 'html';

				// Pre process
				if (!args.no_events) {
					args.node = node;
					onPreProcess.dispatch(self, args);
				}

				// Setup serializer
				htmlSerializer = new tinymce.html.Serializer(settings, schema);

				// Parse and serialize HTML
				args.content = htmlSerializer.serialize(
					htmlParser.parse(args.getInner ? node.innerHTML : tinymce.trim(dom.getOuterHTML(node), args), args)
				);

				// Replace all BOM characters for now until we can find a better solution
				if (!args.cleanup)
					args.content = args.content.replace(/\uFEFF/g, '');

				// Post process
				if (!args.no_events)
					onPostProcess.dispatch(self, args);

				// Restore the old document if it was changed
				if (oldDoc)
					dom.doc = oldDoc;

				args.node = null;

				return args.content;
			},

			/**
			 * Adds valid elements rules to the serializers schema instance this enables you to specify things
			 * like what elements should be outputted and what attributes specific elements might have.
			 * Consult the Wiki for more details on this format.
			 *
			 * @method addRules
			 * @param {String} rules Valid elements rules string to add to schema.
			 */
			addRules : function(rules) {
				schema.addValidElements(rules);
			},

			/**
			 * Sets the valid elements rules to the serializers schema instance this enables you to specify things
			 * like what elements should be outputted and what attributes specific elements might have.
			 * Consult the Wiki for more details on this format.
			 *
			 * @method setRules
			 * @param {String} rules Valid elements rules string.
			 */
			setRules : function(rules) {
				schema.setValidElements(rules);
			}
		};
	};
})(tinymce);/**
 * ScriptLoader.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	/**
	 * This class handles asynchronous/synchronous loading of JavaScript files it will execute callbacks when various items gets loaded. This class is useful to load external JavaScript files.
	 *
	 * @class tinymce.dom.ScriptLoader
	 * @example
	 * // Load a script from a specific URL using the global script loader
	 * tinymce.ScriptLoader.load('somescript.js');
	 *
	 * // Load a script using a unique instance of the script loader
	 * var scriptLoader = new tinymce.dom.ScriptLoader();
	 *
	 * scriptLoader.load('somescript.js');
	 *
	 * // Load multiple scripts
	 * var scriptLoader = new tinymce.dom.ScriptLoader();
	 *
	 * scriptLoader.add('somescript1.js');
	 * scriptLoader.add('somescript2.js');
	 * scriptLoader.add('somescript3.js');
	 *
	 * scriptLoader.loadQueue(function() {
	 *    alert('All scripts are now loaded.');
	 * });
	 */
	tinymce.dom.ScriptLoader = function(settings) {
		var QUEUED = 0,
			LOADING = 1,
			LOADED = 2,
			states = {},
			queue = [],
			scriptLoadedCallbacks = {},
			queueLoadedCallbacks = [],
			loading = 0,
			undefined;

		/**
		 * Loads a specific script directly without adding it to the load queue.
		 *
		 * @method load
		 * @param {String} url Absolute URL to script to add.
		 * @param {function} callback Optional callback function to execute ones this script gets loaded.
		 * @param {Object} scope Optional scope to execute callback in.
		 */
		function loadScript(url, callback) {
			var t = this, dom = tinymce.DOM, elm, uri, loc, id;

			// Execute callback when script is loaded
			function done() {
				dom.remove(id);

				if (elm)
					elm.onreadystatechange = elm.onload = elm = null;

				callback();
			};

			function error() {
				// Report the error so it's easier for people to spot loading errors
				if (typeof(console) !== "undefined" && console.log)
					console.log("Failed to load: " + url);

				// We can't mark it as done if there is a load error since
				// A) We don't want to produce 404 errors on the server and
				// B) the onerror event won't fire on all browsers.
				// done();
			};

			id = dom.uniqueId();

			if (tinymce.isIE6) {
				uri = new tinymce.util.URI(url);
				loc = location;

				// If script is from same domain and we
				// use IE 6 then use XHR since it's more reliable
				if (uri.host == loc.hostname && uri.port == loc.port && (uri.protocol + ':') == loc.protocol && uri.protocol.toLowerCase() != 'file') {
					tinymce.util.XHR.send({
						url : tinymce._addVer(uri.getURI()),
						success : function(content) {
							// Create new temp script element
							var script = dom.create('script', {
								type : 'text/javascript'
							});

							// Evaluate script in global scope
							script.text = content;
							document.getElementsByTagName('head')[0].appendChild(script);
							dom.remove(script);

							done();
						},

						error : error
					});

					return;
				}
			}

			// Create new script element
			elm = dom.create('script', {
				id : id,
				type : 'text/javascript',
				src : tinymce._addVer(url)
			});

			// Add onload listener for non IE browsers since IE9
			// fires onload event before the script is parsed and executed
			if (!tinymce.isIE)
				elm.onload = done;

			// Add onerror event will get fired on some browsers but not all of them
			elm.onerror = error;

			// Opera 9.60 doesn't seem to fire the onreadystate event at correctly
			if (!tinymce.isOpera) {
				elm.onreadystatechange = function() {
					var state = elm.readyState;

					// Loaded state is passed on IE 6 however there
					// are known issues with this method but we can't use
					// XHR in a cross domain loading
					if (state == 'complete' || state == 'loaded')
						done();
				};
			}

			// Most browsers support this feature so we report errors
			// for those at least to help users track their missing plugins etc
			// todo: Removed since it produced error if the document is unloaded by navigating away, re-add it as an option
			/*elm.onerror = function() {
				alert('Failed to load: ' + url);
			};*/

			// Add script to document
			(document.getElementsByTagName('head')[0] || document.body).appendChild(elm);
		};

		/**
		 * Returns true/false if a script has been loaded or not.
		 *
		 * @method isDone
		 * @param {String} url URL to check for.
		 * @return [Boolean} true/false if the URL is loaded.
		 */
		this.isDone = function(url) {
			return states[url] == LOADED;
		};

		/**
		 * Marks a specific script to be loaded. This can be useful if a script got loaded outside
		 * the script loader or to skip it from loading some script.
		 *
		 * @method markDone
		 * @param {string} u Absolute URL to the script to mark as loaded.
		 */
		this.markDone = function(url) {
			states[url] = LOADED;
		};

		/**
		 * Adds a specific script to the load queue of the script loader.
		 *
		 * @method add
		 * @param {String} url Absolute URL to script to add.
		 * @param {function} callback Optional callback function to execute ones this script gets loaded.
		 * @param {Object} scope Optional scope to execute callback in.
		 */
		this.add = this.load = function(url, callback, scope) {
			var item, state = states[url];

			// Add url to load queue
			if (state == undefined) {
				queue.push(url);
				states[url] = QUEUED;
			}

			if (callback) {
				// Store away callback for later execution
				if (!scriptLoadedCallbacks[url])
					scriptLoadedCallbacks[url] = [];

				scriptLoadedCallbacks[url].push({
					func : callback,
					scope : scope || this
				});
			}
		};

		/**
		 * Starts the loading of the queue.
		 *
		 * @method loadQueue
		 * @param {function} callback Optional callback to execute when all queued items are loaded.
		 * @param {Object} scope Optional scope to execute the callback in.
		 */
		this.loadQueue = function(callback, scope) {
			this.loadScripts(queue, callback, scope);
		};

		/**
		 * Loads the specified queue of files and executes the callback ones they are loaded.
		 * This method is generally not used outside this class but it might be useful in some scenarios.
		 *
		 * @method loadScripts
		 * @param {Array} scripts Array of queue items to load.
		 * @param {function} callback Optional callback to execute ones all items are loaded.
		 * @param {Object} scope Optional scope to execute callback in.
		 */
		this.loadScripts = function(scripts, callback, scope) {
			var loadScripts;

			function execScriptLoadedCallbacks(url) {
				// Execute URL callback functions
				tinymce.each(scriptLoadedCallbacks[url], function(callback) {
					callback.func.call(callback.scope);
				});

				scriptLoadedCallbacks[url] = undefined;
			};

			queueLoadedCallbacks.push({
				func : callback,
				scope : scope || this
			});

			loadScripts = function() {
				var loadingScripts = tinymce.grep(scripts);

				// Current scripts has been handled
				scripts.length = 0;

				// Load scripts that needs to be loaded
				tinymce.each(loadingScripts, function(url) {
					// Script is already loaded then execute script callbacks directly
					if (states[url] == LOADED) {
						execScriptLoadedCallbacks(url);
						return;
					}

					// Is script not loading then start loading it
					if (states[url] != LOADING) {
						states[url] = LOADING;
						loading++;

						loadScript(url, function() {
							states[url] = LOADED;
							loading--;

							execScriptLoadedCallbacks(url);

							// Load more scripts if they where added by the recently loaded script
							loadScripts();
						});
					}
				});

				// No scripts are currently loading then execute all pending queue loaded callbacks
				if (!loading) {
					tinymce.each(queueLoadedCallbacks, function(callback) {
						callback.func.call(callback.scope);
					});

					queueLoadedCallbacks.length = 0;
				}
			};

			loadScripts();
		};
	};

	// Global script loader
	tinymce.ScriptLoader = new tinymce.dom.ScriptLoader();
})(tinymce);
/**
 * TreeWalker.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

tinymce.dom.TreeWalker = function(start_node, root_node) {
	var node = start_node;

	function findSibling(node, start_name, sibling_name, shallow) {
		var sibling, parent;

		if (node) {
			// Walk into nodes if it has a start
			if (!shallow && node[start_name])
				return node[start_name];

			// Return the sibling if it has one
			if (node != root_node) {
				sibling = node[sibling_name];
				if (sibling)
					return sibling;

				// Walk up the parents to look for siblings
				for (parent = node.parentNode; parent && parent != root_node; parent = parent.parentNode) {
					sibling = parent[sibling_name];
					if (sibling)
						return sibling;
				}
			}
		}
	};

	/**
	 * Returns the current node.
	 *
	 * @return {Node} Current node where the walker is.
	 */
	this.current = function() {
		return node;
	};

	/**
	 * Walks to the next node in tree.
	 *
	 * @return {Node} Current node where the walker is after moving to the next node.
	 */
	this.next = function(shallow) {
		return (node = findSibling(node, 'firstChild', 'nextSibling', shallow));
	};

	/**
	 * Walks to the previous node in tree.
	 *
	 * @return {Node} Current node where the walker is after moving to the previous node.
	 */
	this.prev = function(shallow) {
		return (node = findSibling(node, 'lastChild', 'previousSibling', shallow));
	};
};
/**
 * Range.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	tinymce.dom.RangeUtils = function(dom) {
		var INVISIBLE_CHAR = '\uFEFF';

		/**
		 * Walks the specified range like object and executes the callback for each sibling collection it finds.
		 *
		 * @param {Object} rng Range like object.
		 * @param {function} callback Callback function to execute for each sibling collection.
		 */
		this.walk = function(rng, callback) {
			var startContainer = rng.startContainer,
				startOffset = rng.startOffset,
				endContainer = rng.endContainer,
				endOffset = rng.endOffset,
				ancestor, startPoint,
				endPoint, node, parent, siblings, nodes;

			// Handle table cell selection the table plugin enables
			// you to fake select table cells and perform formatting actions on them
			nodes = dom.select('td.mceSelected,th.mceSelected');
			if (nodes.length > 0) {
				tinymce.each(nodes, function(node) {
					callback([node]);
				});

				return;
			}

			/**
			 * Collects siblings
			 *
			 * @private
			 * @param {Node} node Node to collect siblings from.
			 * @param {String} name Name of the sibling to check for.
			 * @return {Array} Array of collected siblings.
			 */
			function collectSiblings(node, name, end_node) {
				var siblings = [];

				for (; node && node != end_node; node = node[name])
					siblings.push(node);

				return siblings;
			};

			/**
			 * Find an end point this is the node just before the common ancestor root.
			 *
			 * @private
			 * @param {Node} node Node to start at.
			 * @param {Node} root Root/ancestor element to stop just before.
			 * @return {Node} Node just before the root element.
			 */
			function findEndPoint(node, root) {
				do {
					if (node.parentNode == root)
						return node;

					node = node.parentNode;
				} while(node);
			};

			function walkBoundary(start_node, end_node, next) {
				var siblingName = next ? 'nextSibling' : 'previousSibling';

				for (node = start_node, parent = node.parentNode; node && node != end_node; node = parent) {
					parent = node.parentNode;
					siblings = collectSiblings(node == start_node ? node : node[siblingName], siblingName);

					if (siblings.length) {
						if (!next)
							siblings.reverse();

						callback(siblings);
					}
				}
			};

			// If index based start position then resolve it
			if (startContainer.nodeType == 1 && startContainer.hasChildNodes())
				startContainer = startContainer.childNodes[startOffset];

			// If index based end position then resolve it
			if (endContainer.nodeType == 1 && endContainer.hasChildNodes())
				endContainer = endContainer.childNodes[Math.min(endOffset - 1, endContainer.childNodes.length - 1)];

			// Find common ancestor and end points
			ancestor = dom.findCommonAncestor(startContainer, endContainer);

			// Same container
			if (startContainer == endContainer)
				return callback([startContainer]);

			// Process left side
			for (node = startContainer; node; node = node.parentNode) {
				if (node == endContainer)
					return walkBoundary(startContainer, ancestor, true);

				if (node == ancestor)
					break;
			}

			// Process right side
			for (node = endContainer; node; node = node.parentNode) {
				if (node == startContainer)
					return walkBoundary(endContainer, ancestor);

				if (node == ancestor)
					break;
			}

			// Find start/end point
			startPoint = findEndPoint(startContainer, ancestor) || startContainer;
			endPoint = findEndPoint(endContainer, ancestor) || endContainer;

			// Walk left leaf
			walkBoundary(startContainer, startPoint, true);

			// Walk the middle from start to end point
			siblings = collectSiblings(
				startPoint == startContainer ? startPoint : startPoint.nextSibling,
				'nextSibling',
				endPoint == endContainer ? endPoint.nextSibling : endPoint
			);

			if (siblings.length)
				callback(siblings);

			// Walk right leaf
			walkBoundary(endContainer, endPoint);
		};

		/**
		 * Splits the specified range at it's start/end points.
		 *
		 * @param {Range/RangeObject} rng Range to split.
		 * @return {Object} Range position object.
		 */
/*		this.split = function(rng) {
			var startContainer = rng.startContainer,
				startOffset = rng.startOffset,
				endContainer = rng.endContainer,
				endOffset = rng.endOffset;

			function splitText(node, offset) {
				if (offset == node.nodeValue.length)
					node.appendData(INVISIBLE_CHAR);

				node = node.splitText(offset);

				if (node.nodeValue === INVISIBLE_CHAR)
					node.nodeValue = '';

				return node;
			};

			// Handle single text node
			if (startContainer == endContainer) {
				if (startContainer.nodeType == 3) {
					if (startOffset != 0)
						startContainer = endContainer = splitText(startContainer, startOffset);

					if (endOffset - startOffset != startContainer.nodeValue.length)
						splitText(startContainer, endOffset - startOffset);
				}
			} else {
				// Split startContainer text node if needed
				if (startContainer.nodeType == 3 && startOffset != 0) {
					startContainer = splitText(startContainer, startOffset);
					startOffset = 0;
				}

				// Split endContainer text node if needed
				if (endContainer.nodeType == 3 && endOffset != endContainer.nodeValue.length) {
					endContainer = splitText(endContainer, endOffset).previousSibling;
					endOffset = endContainer.nodeValue.length;
				}
			}

			return {
				startContainer : startContainer,
				startOffset : startOffset,
				endContainer : endContainer,
				endOffset : endOffset
			};
		};
*/
	};

	/**
	 * Compares two ranges and checks if they are equal.
	 *
	 * @static
	 * @param {DOMRange} rng1 First range to compare.
	 * @param {DOMRange} rng2 First range to compare.
	 * @return {Boolean} true/false if the ranges are equal.
	 */
	tinymce.dom.RangeUtils.compareRanges = function(rng1, rng2) {
		if (rng1 && rng2) {
			// Compare native IE ranges
			if (rng1.item || rng1.duplicate) {
				// Both are control ranges and the selected element matches
				if (rng1.item && rng2.item && rng1.item(0) === rng2.item(0))
					return true;

				// Both are text ranges and the range matches
				if (rng1.isEqual && rng2.isEqual && rng2.isEqual(rng1))
					return true;
			} else {
				// Compare w3c ranges
				return rng1.startContainer == rng2.startContainer && rng1.startOffset == rng2.startOffset;
			}
		}

		return false;
	};
})(tinymce);
/**
 * KeyboardNavigation.js
 *
 * Copyright 2011, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var Event = tinymce.dom.Event, each = tinymce.each;

	/**
	 * This class provides basic keyboard navigation using the arrow keys to children of a component.
	 * For example, this class handles moving between the buttons on the toolbars.
	 *
	 * @class tinymce.ui.KeyboardNavigation
	 */
	tinymce.create('tinymce.ui.KeyboardNavigation', {
		/**
		 * Create a new KeyboardNavigation instance to handle the focus for a specific element.
		 *
		 * @constructor
		 * @method KeyboardNavigation
		 * @param {Object} settings the settings object to define how keyboard navigation works.
		 * @param {DOMUtils} dom the DOMUtils instance to use.
		 *
		 * @setting {Element/String} root the root element or ID of the root element for the control.
		 * @setting {Array} items an array containing the items to move focus between. Every object in this array must have an id attribute which maps to the actual DOM element. If the actual elements are passed without an ID then one is automatically assigned.
		 * @setting {Function} onCancel the callback for when the user presses escape or otherwise indicates cancelling.
		 * @setting {Function} onAction (optional) the action handler to call when the user activates an item.
		 * @setting {Boolean} enableLeftRight (optional, default) when true, the up/down arrows move through items.
		 * @setting {Boolean} enableUpDown (optional) when true, the up/down arrows move through items.
		 * Note for both up/down and left/right explicitly set both enableLeftRight and enableUpDown to true.
		 */
		KeyboardNavigation: function(settings, dom) {
			var t = this, root = settings.root, items = settings.items,
					enableUpDown = settings.enableUpDown, enableLeftRight = settings.enableLeftRight || !settings.enableUpDown,
					excludeFromTabOrder = settings.excludeFromTabOrder,
					itemFocussed, itemBlurred, rootKeydown, rootFocussed, focussedId;

			dom = dom || tinymce.DOM;

			itemFocussed = function(evt) {
				focussedId = evt.target.id;
			};

			itemBlurred = function(evt) {
				dom.setAttrib(evt.target.id, 'tabindex', '-1');
			};

			rootFocussed = function(evt) {
				var item = dom.get(focussedId);
				dom.setAttrib(item, 'tabindex', '0');
				item.focus();
			};

			t.focus = function() {
				dom.get(focussedId).focus();
			};

			/**
			 * Destroys the KeyboardNavigation and unbinds any focus/blur event handles it might have added.
			 *
			 * @method destroy
			 */
			t.destroy = function() {
				each(items, function(item) {
					dom.unbind(dom.get(item.id), 'focus', itemFocussed);
					dom.unbind(dom.get(item.id), 'blur', itemBlurred);
				});

				dom.unbind(dom.get(root), 'focus', rootFocussed);
				dom.unbind(dom.get(root), 'keydown', rootKeydown);

				items = dom = root = t.focus = itemFocussed = itemBlurred = rootKeydown = rootFocussed = null;
				t.destroy = function() {};
			};

			t.moveFocus = function(dir, evt) {
				var idx = -1, controls = t.controls, newFocus;

				if (!focussedId)
					return;

				each(items, function(item, index) {
					if (item.id === focussedId) {
						idx = index;
						return false;
					}
				});

				idx += dir;
				if (idx < 0) {
					idx = items.length - 1;
				} else if (idx >= items.length) {
					idx = 0;
				}

				newFocus = items[idx];
				dom.setAttrib(focussedId, 'tabindex', '-1');
				dom.setAttrib(newFocus.id, 'tabindex', '0');
				dom.get(newFocus.id).focus();

				if (settings.actOnFocus) {
					settings.onAction(newFocus.id);
				}

				if (evt)
					Event.cancel(evt);
			};

			rootKeydown = function(evt) {
				var DOM_VK_LEFT = 37, DOM_VK_RIGHT = 39, DOM_VK_UP = 38, DOM_VK_DOWN = 40, DOM_VK_ESCAPE = 27, DOM_VK_ENTER = 14, DOM_VK_RETURN = 13, DOM_VK_SPACE = 32;

				switch (evt.keyCode) {
					case DOM_VK_LEFT:
						if (enableLeftRight) t.moveFocus(-1);
						break;

					case DOM_VK_RIGHT:
						if (enableLeftRight) t.moveFocus(1);
						break;

					case DOM_VK_UP:
						if (enableUpDown) t.moveFocus(-1);
						break;

					case DOM_VK_DOWN:
						if (enableUpDown) t.moveFocus(1);
						break;

					case DOM_VK_ESCAPE:
						if (settings.onCancel) {
							settings.onCancel();
							Event.cancel(evt);
						}
						break;

					case DOM_VK_ENTER:
					case DOM_VK_RETURN:
					case DOM_VK_SPACE:
						if (settings.onAction) {
							settings.onAction(focussedId);
							Event.cancel(evt);
						}
						break;
				}
			};

			// Set up state and listeners for each item.
			each(items, function(item, idx) {
				var tabindex;

				if (!item.id) {
					item.id = dom.uniqueId('_mce_item_');
				}

				if (excludeFromTabOrder) {
					dom.bind(item.id, 'blur', itemBlurred);
					tabindex = '-1';
				} else {
					tabindex = (idx === 0 ? '0' : '-1');
				}

				dom.setAttrib(item.id, 'tabindex', tabindex);
				dom.bind(dom.get(item.id), 'focus', itemFocussed);
			});

			// Setup initial state for root element.
			if (items[0]){
				focussedId = items[0].id;
			}

			dom.setAttrib(root, 'tabindex', '-1');

			// Setup listeners for root element.
			dom.bind(dom.get(root), 'focus', rootFocussed);
			dom.bind(dom.get(root), 'keydown', rootKeydown);
		}
	});
})(tinymce);
/**
 * Control.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	// Shorten class names
	var DOM = tinymce.DOM, is = tinymce.is;

	/**
	 * This class is the base class for all controls like buttons, toolbars, containers. This class should not
	 * be instantiated directly other controls should inherit from this one.
	 *
	 * @class tinymce.ui.Control
	 */
	tinymce.create('tinymce.ui.Control', {
		/**
		 * Constructs a new control instance.
		 *
		 * @constructor
		 * @method Control
		 * @param {String} id Control id.
		 * @param {Object} s Optional name/value settings object.
		 */
		Control : function(id, s, editor) {
			this.id = id;
			this.settings = s = s || {};
			this.rendered = false;
			this.onRender = new tinymce.util.Dispatcher(this);
			this.classPrefix = '';
			this.scope = s.scope || this;
			this.disabled = 0;
			this.active = 0;
			this.editor = editor;
		},

		setAriaProperty : function(property, value) {
			var element = DOM.get(this.id + '_aria') || DOM.get(this.id);
			if (element) {
				DOM.setAttrib(element, 'aria-' + property, !!value);
			}
		},

		focus : function() {
			DOM.get(this.id).focus();
		},

		/**
		 * Sets the disabled state for the control. This will add CSS classes to the
		 * element that contains the control. So that it can be disabled visually.
		 *
		 * @method setDisabled
		 * @param {Boolean} s Boolean state if the control should be disabled or not.
		 */
		setDisabled : function(s) {
			if (s != this.disabled) {
				this.setAriaProperty('disabled', s);

				this.setState('Disabled', s);
				this.setState('Enabled', !s);
				this.disabled = s;
			}
		},

		/**
		 * Returns true/false if the control is disabled or not. This is a method since you can then
		 * choose to check some class or some internal bool state in subclasses.
		 *
		 * @method isDisabled
		 * @return {Boolean} true/false if the control is disabled or not.
		 */
		isDisabled : function() {
			return this.disabled;
		},

		/**
		 * Sets the activated state for the control. This will add CSS classes to the
		 * element that contains the control. So that it can be activated visually.
		 *
		 * @method setActive
		 * @param {Boolean} s Boolean state if the control should be activated or not.
		 */
		setActive : function(s) {
			if (s != this.active) {
				this.setState('Active', s);
				this.active = s;
				this.setAriaProperty('pressed', s);
			}
		},

		/**
		 * Returns true/false if the control is disabled or not. This is a method since you can then
		 * choose to check some class or some internal bool state in subclasses.
		 *
		 * @method isActive
		 * @return {Boolean} true/false if the control is disabled or not.
		 */
		isActive : function() {
			return this.active;
		},

		/**
		 * Sets the specified class state for the control.
		 *
		 * @method setState
		 * @param {String} c Class name to add/remove depending on state.
		 * @param {Boolean} s True/false state if the class should be removed or added.
		 */
		setState : function(c, s) {
			var n = DOM.get(this.id);

			c = this.classPrefix + c;

			if (s)
				DOM.addClass(n, c);
			else
				DOM.removeClass(n, c);
		},

		/**
		 * Returns true/false if the control has been rendered or not.
		 *
		 * @method isRendered
		 * @return {Boolean} State if the control has been rendered or not.
		 */
		isRendered : function() {
			return this.rendered;
		},

		/**
		 * Renders the control as a HTML string. This method is much faster than using the DOM and when
		 * creating a whole toolbar with buttons it does make a lot of difference.
		 *
		 * @method renderHTML
		 * @return {String} HTML for the button control element.
		 */
		renderHTML : function() {
		},

		/**
		 * Renders the control to the specified container element.
		 *
		 * @method renderTo
		 * @param {Element} n HTML DOM element to add control to.
		 */
		renderTo : function(n) {
			DOM.setHTML(n, this.renderHTML());
		},

		/**
		 * Post render event. This will be executed after the control has been rendered and can be used to
		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, b;

			// Set pending states
			if (is(t.disabled)) {
				b = t.disabled;
				t.disabled = -1;
				t.setDisabled(b);
			}

			if (is(t.active)) {
				b = t.active;
				t.active = -1;
				t.setActive(b);
			}
		},

		/**
		 * Removes the control. This means it will be removed from the DOM and any
		 * events tied to it will also be removed.
		 *
		 * @method remove
		 */
		remove : function() {
			DOM.remove(this.id);
			this.destroy();
		},

		/**
		 * Destroys the control will free any memory by removing event listeners etc.
		 *
		 * @method destroy
		 */
		destroy : function() {
			tinymce.dom.Event.clear(this.id);
		}
	});
})(tinymce);/**
 * Container.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

/**
 * This class is the base class for all container controls like toolbars. This class should not
 * be instantiated directly other container controls should inherit from this one.
 *
 * @class tinymce.ui.Container
 * @extends tinymce.ui.Control
 */
tinymce.create('tinymce.ui.Container:tinymce.ui.Control', {
	/**
	 * Base contrustor a new container control instance.
	 *
	 * @constructor
	 * @method Container
	 * @param {String} id Control id to use for the container.
	 * @param {Object} s Optional name/value settings object.
	 */
	Container : function(id, s, editor) {
		this.parent(id, s, editor);

		/**
		 * Array of controls added to the container.
		 *
		 * @property controls
		 * @type Array
		 */
		this.controls = [];

		this.lookup = {};
	},

	/**
	 * Adds a control to the collection of controls for the container.
	 *
	 * @method add
	 * @param {tinymce.ui.Control} c Control instance to add to the container.
	 * @return {tinymce.ui.Control} Same control instance that got passed in.
	 */
	add : function(c) {
		this.lookup[c.id] = c;
		this.controls.push(c);

		return c;
	},

	/**
	 * Returns a control by id from the containers collection.
	 *
	 * @method get
	 * @param {String} n Id for the control to retrive.
	 * @return {tinymce.ui.Control} Control instance by the specified name or undefined if it wasn't found.
	 */
	get : function(n) {
		return this.lookup[n];
	}
});

/**
 * Separator.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

/**
 * This class is used to create vertical separator between other controls.
 *
 * @class tinymce.ui.Separator
 * @extends tinymce.ui.Control
 */
tinymce.create('tinymce.ui.Separator:tinymce.ui.Control', {
	/**
	 * Separator constructor.
	 *
	 * @constructor
	 * @method Separator
	 * @param {String} id Control id to use for the Separator.
	 * @param {Object} s Optional name/value settings object.
	 */
	Separator : function(id, s) {
		this.parent(id, s);
		this.classPrefix = 'mceSeparator';
		this.setDisabled(true);
	},

	/**
	 * Renders the separator as a HTML string. This method is much faster than using the DOM and when
	 * creating a whole toolbar with buttons it does make a lot of difference.
	 *
	 * @method renderHTML
	 * @return {String} HTML for the separator control element.
	 */
	renderHTML : function() {
		return tinymce.DOM.createHTML('span', {'class' : this.classPrefix, role : 'separator', 'aria-orientation' : 'vertical', tabindex : '-1'});
	}
});
/**
 * MenuItem.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var is = tinymce.is, DOM = tinymce.DOM, each = tinymce.each, walk = tinymce.walk;

	/**
	 * This class is base class for all menu item types like DropMenus items etc. This class should not
	 * be instantiated directly other menu items should inherit from this one.
	 *
	 * @class tinymce.ui.MenuItem
	 * @extends tinymce.ui.Control
	 */
	tinymce.create('tinymce.ui.MenuItem:tinymce.ui.Control', {
		/**
		 * Constructs a new button control instance.
		 *
		 * @constructor
		 * @method MenuItem
		 * @param {String} id Button control id for the button.
		 * @param {Object} s Optional name/value settings object.
		 */
		MenuItem : function(id, s) {
			this.parent(id, s);
			this.classPrefix = 'mceMenuItem';
		},

		/**
		 * Sets the selected state for the control. This will add CSS classes to the
		 * element that contains the control. So that it can be selected visually.
		 *
		 * @method setSelected
		 * @param {Boolean} s Boolean state if the control should be selected or not.
		 */
		setSelected : function(s) {
			this.setState('Selected', s);
			this.setAriaProperty('checked', !!s);
			this.selected = s;
		},

		/**
		 * Returns true/false if the control is selected or not.
		 *
		 * @method isSelected
		 * @return {Boolean} true/false if the control is selected or not.
		 */
		isSelected : function() {
			return this.selected;
		},

		/**
		 * Post render handler. This function will be called after the UI has been
		 * rendered so that events can be added.
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this;

			t.parent();

			// Set pending state
			if (is(t.selected))
				t.setSelected(t.selected);
		}
	});
})(tinymce);
/**
 * Menu.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var is = tinymce.is, DOM = tinymce.DOM, each = tinymce.each, walk = tinymce.walk;

	/**
	 * This class is base class for all menu types like DropMenus etc. This class should not
	 * be instantiated directly other menu controls should inherit from this one.
	 *
	 * @class tinymce.ui.Menu
	 * @extends tinymce.ui.MenuItem
	 */
	tinymce.create('tinymce.ui.Menu:tinymce.ui.MenuItem', {
		/**
		 * Constructs a new button control instance.
		 *
		 * @constructor
		 * @method Menu
		 * @param {String} id Button control id for the button.
		 * @param {Object} s Optional name/value settings object.
		 */
		Menu : function(id, s) {
			var t = this;

			t.parent(id, s);
			t.items = {};
			t.collapsed = false;
			t.menuCount = 0;
			t.onAddItem = new tinymce.util.Dispatcher(this);
		},

		/**
		 * Expands the menu, this will show them menu and all menu items.
		 *
		 * @method expand
		 * @param {Boolean} d Optional deep state. If this is set to true all children will be expanded as well.
		 */
		expand : function(d) {
			var t = this;

			if (d) {
				walk(t, function(o) {
					if (o.expand)
						o.expand();
				}, 'items', t);
			}

			t.collapsed = false;
		},

		/**
		 * Collapses the menu, this will hide the menu and all menu items.
		 *
		 * @method collapse
		 * @param {Boolean} d Optional deep state. If this is set to true all children will be collapsed as well.
		 */
		collapse : function(d) {
			var t = this;

			if (d) {
				walk(t, function(o) {
					if (o.collapse)
						o.collapse();
				}, 'items', t);
			}

			t.collapsed = true;
		},

		/**
		 * Returns true/false if the menu has been collapsed or not.
		 *
		 * @method isCollapsed
		 * @return {Boolean} True/false state if the menu has been collapsed or not.
		 */
		isCollapsed : function() {
			return this.collapsed;
		},

		/**
		 * Adds a new menu, menu item or sub classes of them to the drop menu.
		 *
		 * @method add
		 * @param {tinymce.ui.Control} o Menu or menu item to add to the drop menu.
		 * @return {tinymce.ui.Control} Same as the input control, the menu or menu item.
		 */
		add : function(o) {
			if (!o.settings)
				o = new tinymce.ui.MenuItem(o.id || DOM.uniqueId(), o);

			this.onAddItem.dispatch(this, o);

			return this.items[o.id] = o;
		},

		/**
		 * Adds a menu separator between the menu items.
		 *
		 * @method addSeparator
		 * @return {tinymce.ui.MenuItem} Menu item instance for the separator.
		 */
		addSeparator : function() {
			return this.add({separator : true});
		},

		/**
		 * Adds a sub menu to the menu.
		 *
		 * @method addMenu
		 * @param {Object} o Menu control or a object with settings to be created into an control.
		 * @return {tinymce.ui.Menu} Menu control instance passed in or created.
		 */
		addMenu : function(o) {
			if (!o.collapse)
				o = this.createMenu(o);

			this.menuCount++;

			return this.add(o);
		},

		/**
		 * Returns true/false if the menu has sub menus or not.
		 *
		 * @method hasMenus
		 * @return {Boolean} True/false state if the menu has sub menues or not.
		 */
		hasMenus : function() {
			return this.menuCount !== 0;
		},

		/**
		 * Removes a specific sub menu or menu item from the menu.
		 *
		 * @method remove
		 * @param {tinymce.ui.Control} o Menu item or menu to remove from menu.
		 * @return {tinymce.ui.Control} Control instance or null if it wasn't found.
		 */
		remove : function(o) {
			delete this.items[o.id];
		},

		/**
		 * Removes all menu items and sub menu items from the menu.
		 *
		 * @method removeAll
		 */
		removeAll : function() {
			var t = this;

			walk(t, function(o) {
				if (o.removeAll)
					o.removeAll();
				else
					o.remove();

				o.destroy();
			}, 'items', t);

			t.items = {};
		},

		/**
		 * Created a new sub menu for the menu control.
		 *
		 * @method createMenu
		 * @param {Object} s Optional name/value settings object.
		 * @return {tinymce.ui.Menu} New drop menu instance.
		 */
		createMenu : function(o) {
			var m = new tinymce.ui.Menu(o.id || DOM.uniqueId(), o);

			m.onAddItem.add(this.onAddItem.dispatch, this.onAddItem);

			return m;
		}
	});
})(tinymce);/**
 * DropMenu.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var is = tinymce.is, DOM = tinymce.DOM, each = tinymce.each, Event = tinymce.dom.Event, Element = tinymce.dom.Element;

	/**
	 * This class is used to create drop menus, a drop menu can be a
	 * context menu, or a menu for a list box or a menu bar.
	 *
	 * @class tinymce.ui.DropMenu
	 * @extends tinymce.ui.Menu
	 */
	tinymce.create('tinymce.ui.DropMenu:tinymce.ui.Menu', {
		/**
		 * Constructs a new drop menu control instance.
		 *
		 * @constructor
		 * @method DropMenu
		 * @param {String} id Button control id for the button.
		 * @param {Object} s Optional name/value settings object.
		 */
		DropMenu : function(id, s) {
			s = s || {};
			s.container = s.container || DOM.doc.body;
			s.offset_x = s.offset_x || 0;
			s.offset_y = s.offset_y || 0;
			s.vp_offset_x = s.vp_offset_x || 0;
			s.vp_offset_y = s.vp_offset_y || 0;

			if (is(s.icons) && !s.icons)
				s['class'] += ' mceNoIcons';

			this.parent(id, s);
			this.onShowMenu = new tinymce.util.Dispatcher(this);
			this.onHideMenu = new tinymce.util.Dispatcher(this);
			this.classPrefix = 'mceMenu';
		},

		/**
		 * Created a new sub menu for the drop menu control.
		 *
		 * @method createMenu
		 * @param {Object} s Optional name/value settings object.
		 * @return {tinymce.ui.DropMenu} New drop menu instance.
		 */
		createMenu : function(s) {
			var t = this, cs = t.settings, m;

			s.container = s.container || cs.container;
			s.parent = t;
			s.constrain = s.constrain || cs.constrain;
			s['class'] = s['class'] || cs['class'];
			s.vp_offset_x = s.vp_offset_x || cs.vp_offset_x;
			s.vp_offset_y = s.vp_offset_y || cs.vp_offset_y;
			s.keyboard_focus = cs.keyboard_focus;
			m = new tinymce.ui.DropMenu(s.id || DOM.uniqueId(), s);

			m.onAddItem.add(t.onAddItem.dispatch, t.onAddItem);

			return m;
		},

		focus : function() {
			var t = this;
			if (t.keyboardNav) {
				t.keyboardNav.focus();
			}
		},

		/**
		 * Repaints the menu after new items have been added dynamically.
		 *
		 * @method update
		 */
		update : function() {
			var t = this, s = t.settings, tb = DOM.get('menu_' + t.id + '_tbl'), co = DOM.get('menu_' + t.id + '_co'), tw, th;

			tw = s.max_width ? Math.min(tb.clientWidth, s.max_width) : tb.clientWidth;
			th = s.max_height ? Math.min(tb.clientHeight, s.max_height) : tb.clientHeight;


//			if (!DOM.boxModel)
//				t.element.setStyles({width : tw + 2, height : th + 2});
//			else
//				t.element.setStyles({width : tw, height : th});

			if (s.max_width)
				DOM.setStyle(co, 'width', tw);

			if (s.max_height) {
				DOM.setStyle(co, 'height', th);

				if (tb.clientHeight < s.max_height)
					DOM.setStyle(co, 'overflow', 'hidden');
			}
		},

		/**
		 * Displays the menu at the specified cordinate.
		 *
		 * @method showMenu
		 * @param {Number} x Horizontal position of the menu.
		 * @param {Number} y Vertical position of the menu.
		 * @param {Numner} px Optional parent X position used when menus are cascading.
		 */
		showMenu : function(x, y, px) {
			var t = this, s = t.settings, co, vp = DOM.getViewPort(), w, h, mx, my, ot = 2, dm, tb, cp = t.classPrefix;

			t.collapse(1);

			if (t.isMenuVisible)
				return;

			if (!t.rendered) {
				co = DOM.add(t.settings.container, t.renderNode());

				each(t.items, function(o) {
					o.postRender();
				});

				t.element = new Element('menu_' + t.id, {blocker : 1, container : s.container});
			} else
				co = DOM.get('menu_' + t.id);

			// Move layer out of sight unless it's Opera since it scrolls to top of page due to an bug
//			if (!tinymce.isOpera)
//				DOM.setStyles(co, {left : -0xFFFF , top : -0xFFFF});

			DOM.show(co);
			t.update();

			x += s.offset_x || 0;
			y += s.offset_y || 0;
			vp.w -= 4;
			vp.h -= 4;

			// Move inside viewport if not submenu
			if (s.constrain) {
				w = co.clientWidth - ot;
				h = co.clientHeight - ot;
				mx = vp.x + vp.w;
				my = vp.y + vp.h;

				if ((x + s.vp_offset_x + w) > mx)
					x = px ? px - w : Math.max(0, (mx - s.vp_offset_x) - w);

				if ((y + s.vp_offset_y + h) > my)
					y = Math.max(0, (my - s.vp_offset_y) - h);
			}

//			DOM.setStyles(co, {left : x , top : y});
			t.element.update();

			t.isMenuVisible = 1;
			t.mouseClickFunc = Event.add(co, 'click', function(e) {
				var m;

				e = e.target;

				if (e && (e = DOM.getParent(e, 'tr')) && !DOM.hasClass(e, cp + 'ItemSub')) {
					m = t.items[e.id];

					if (m.isDisabled())
						return;

					dm = t;

					while (dm) {
						if (dm.hideMenu)
							dm.hideMenu();

						dm = dm.settings.parent;
					}

					if (m.settings.onclick)
						m.settings.onclick(e);

					return Event.cancel(e); // Cancel to fix onbeforeunload problem
				}
			});

			if (t.hasMenus()) {
				t.mouseOverFunc = Event.add(co, 'mouseover', function(e) {
					var m, r, mi;

					e = e.target;
					if (e && (e = DOM.getParent(e, 'tr'))) {
						m = t.items[e.id];

						if (t.lastMenu)
							t.lastMenu.collapse(1);

						if (m.isDisabled())
							return;

						if (e && DOM.hasClass(e, cp + 'ItemSub')) {
							//p = DOM.getPos(s.container);
							r = DOM.getRect(e);
							m.showMenu((r.x + r.w - ot), r.y - ot, r.x);
							t.lastMenu = m;
							DOM.addClass(DOM.get(m.id).firstChild, cp + 'ItemActive');
						}
					}
				});
			}

			Event.add(co, 'keydown', t._keyHandler, t);

			t.onShowMenu.dispatch(t);

			if (s.keyboard_focus) {
				t._setupKeyboardNav();
			}
		},

		/**
		 * Hides the displayed menu.
		 *
		 * @method hideMenu
		 */
		hideMenu : function(c) {
			var t = this, co = DOM.get('menu_' + t.id), e;

			if (!t.isMenuVisible)
				return;

			if (t.keyboardNav) t.keyboardNav.destroy();
			Event.remove(co, 'mouseover', t.mouseOverFunc);
			Event.remove(co, 'click', t.mouseClickFunc);
			Event.remove(co, 'keydown', t._keyHandler);
			DOM.hide(co);
			t.isMenuVisible = 0;

			if (!c)
				t.collapse(1);

			if (t.element)
				t.element.hide();

			if (e = DOM.get(t.id))
				DOM.removeClass(e.firstChild, t.classPrefix + 'ItemActive');

			t.onHideMenu.dispatch(t);
		},

		/**
		 * Adds a new menu, menu item or sub classes of them to the drop menu.
		 *
		 * @method add
		 * @param {tinymce.ui.Control} o Menu or menu item to add to the drop menu.
		 * @return {tinymce.ui.Control} Same as the input control, the menu or menu item.
		 */
		add : function(o) {
			var t = this, co;

			o = t.parent(o);

			if (t.isRendered && (co = DOM.get('menu_' + t.id)))
				t._add(DOM.select('tbody', co)[0], o);

			return o;
		},

		/**
		 * Collapses the menu, this will hide the menu and all menu items.
		 *
		 * @method collapse
		 * @param {Boolean} d Optional deep state. If this is set to true all children will be collapsed as well.
		 */
		collapse : function(d) {
			this.parent(d);
			this.hideMenu(1);
		},

		/**
		 * Removes a specific sub menu or menu item from the drop menu.
		 *
		 * @method remove
		 * @param {tinymce.ui.Control} o Menu item or menu to remove from drop menu.
		 * @return {tinymce.ui.Control} Control instance or null if it wasn't found.
		 */
		remove : function(o) {
			DOM.remove(o.id);
			this.destroy();

			return this.parent(o);
		},

		/**
		 * Destroys the menu. This will remove the menu from the DOM and any events added to it etc.
		 *
		 * @method destroy
		 */
		destroy : function() {
			var t = this, co = DOM.get('menu_' + t.id);

			if (t.keyboardNav) t.keyboardNav.destroy();
			Event.remove(co, 'mouseover', t.mouseOverFunc);
			Event.remove(DOM.select('a', co), 'focus', t.mouseOverFunc);
			Event.remove(co, 'click', t.mouseClickFunc);
			Event.remove(co, 'keydown', t._keyHandler);

			if (t.element)
				t.element.remove();

			DOM.remove(co);
		},

		/**
		 * Renders the specified menu node to the dom.
		 *
		 * @method renderNode
		 * @return {Element} Container element for the drop menu.
		 */
		renderNode : function() {
			var t = this, s = t.settings, n, tb, co, w;

			w = DOM.create('div', {role: 'listbox', id : 'menu_' + t.id, 'class' : s['class']});
			if (t.settings.parent) {
				DOM.setAttrib(w, 'aria-parent', 'menu_' + t.settings.parent.id);
			}
			co = DOM.add(w, 'div', {role: 'presentation', id : 'menu_' + t.id + '_co', 'class' : t.classPrefix + (s['class'] ? ' ' + s['class'] : '')});
			t.element = new Element('menu_' + t.id, {blocker : 1, container : s.container});

			if (s.menu_line)
				DOM.add(co, 'span', {'class' : t.classPrefix + 'Line'});

//			n = DOM.add(co, 'div', {id : 'menu_' + t.id + '_co', 'class' : 'mceMenuContainer'});
			n = DOM.add(co, 'table', {role: 'presentation', id : 'menu_' + t.id + '_tbl', border : 0, cellPadding : 0, cellSpacing : 0});
			tb = DOM.add(n, 'tbody');

			each(t.items, function(o) {
				t._add(tb, o);
			});

			t.rendered = true;

			return w;
		},

		// Internal functions
		_setupKeyboardNav : function(){
			var contextMenu, menuItems, t=this;
			contextMenu = DOM.select('#menu_' + t.id)[0];
			menuItems = DOM.select('a[role=option]', 'menu_' + t.id);
			menuItems.splice(0,0,contextMenu);
			t.keyboardNav = new tinymce.ui.KeyboardNavigation({
				root: 'menu_' + t.id,
				items: menuItems,
				onCancel: function() {
					t.hideMenu();
				},
				enableUpDown: true
			});
			contextMenu.focus();
		},

		_keyHandler : function(evt) {
			var t = this, e;
			switch (evt.keyCode) {
				case 37: // Left
					if (t.settings.parent) {
						t.hideMenu();
						t.settings.parent.focus();
						Event.cancel(evt);
					}
					break;
				case 39: // Right
					if (t.mouseOverFunc)
						t.mouseOverFunc(evt);
					break;
			}
		},

		_add : function(tb, o) {
			var n, s = o.settings, a, ro, it, cp = this.classPrefix, ic;

			if (s.separator) {
				ro = DOM.add(tb, 'tr', {id : o.id, 'class' : cp + 'ItemSeparator'});
				DOM.add(ro, 'td', {'class' : cp + 'ItemSeparator'});

				if (n = ro.previousSibling)
					DOM.addClass(n, 'mceLast');

				return;
			}

			n = ro = DOM.add(tb, 'tr', {id : o.id, 'class' : cp + 'Item ' + cp + 'ItemEnabled'});
			n = it = DOM.add(n, s.titleItem ? 'th' : 'td');
			n = a = DOM.add(n, 'a', {id: o.id + '_aria', 'class': 'mceSplitButtonItemLink', role: s.titleItem ? 'presentation' : 'option', href : 'javascript:;', onclick : "return false;", onmousedown : 'return false;'});

			if (s.parent) {
				DOM.setAttrib(a, 'aria-haspopup', 'true');
				DOM.setAttrib(a, 'aria-owns', 'menu_' + o.id);
			}

			DOM.addClass(it, s['class']);
//			n = DOM.add(n, 'span', {'class' : 'item'});

			ic = DOM.add(n, 'span', {'class' : 'mceIcon' + (s.icon ? ' mce_' + s.icon : '')});

			if (s.icon_src)
				DOM.add(ic, 'img', {src : s.icon_src});

			n = DOM.add(n, s.element || 'span', {'class' : 'mceText', title : o.settings.title}, o.settings.title);

			if (o.settings.style)
				DOM.setAttrib(n, 'style', o.settings.style);

			if (tb.childNodes.length == 1)
				DOM.addClass(ro, 'mceFirst');

			if ((n = ro.previousSibling) && DOM.hasClass(n, cp + 'ItemSeparator'))
				DOM.addClass(ro, 'mceFirst');

			if (o.collapse)
				DOM.addClass(ro, cp + 'ItemSub');

			if (n = ro.previousSibling)
				DOM.removeClass(n, 'mceLast');

			DOM.addClass(ro, 'mceLast');
		}
	});
})(tinymce);
/**
 * Button.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM;

	/**
	 * This class is used to create a UI button. A button is basically a link
	 * that is styled to look like a button or icon.
	 *
	 * @class tinymce.ui.Button
	 * @extends tinymce.ui.Control
	 */
	tinymce.create('tinymce.ui.Button:tinymce.ui.Control', {
		/**
		 * Constructs a new button control instance.
		 *
		 * @constructor
		 * @method Button
		 * @param {String} id Control id for the button.
		 * @param {Object} s Optional name/value settings object.
		 * @param {Editor} ed Optional the editor instance this button is for.
		 */
		Button : function(id, s, ed) {
			this.parent(id, s, ed);
			this.classPrefix = 'mceButton';
		},

		/**
		 * Renders the button as a HTML string. This method is much faster than using the DOM and when
		 * creating a whole toolbar with buttons it does make a lot of difference.
		 *
		 * @method renderHTML
		 * @return {String} HTML for the button control element.
		 */
		renderHTML : function() {
			var cp = this.classPrefix, s = this.settings, h, l;

			l = DOM.encode(s.label || '');

			if (s.link) {
				cp = 'mceToolbarLink';
			}

			h = '<a role="button" id="' + this.id + '" href="javascript:;" class="' + cp + ' ' + cp + 'Enabled ' + s['class'] + '" onmousedown="return false;" onclick="return false;" aria-labelledby="' + this.id + '_voice" title="' + DOM.encode(s.title) + '">';

			if (s.image && !(this.editor && this.editor.forcedHighContrastMode) ) {
				h += '<img class="mceIcon" src="' + s.image + '" alt="' + DOM.encode(s.title) + '" />' + l;
			} else if (s.link) {
				var className = ['mceToolbarLinkOpen'];
				if (s.linkAlign) {
					if (s.linkAlign == 'left') {
						className.push('mceToolbarLinkOpenAlignLeft');
					} else {
						className.push('mceToolbarLinkOpenAlignRight');
					}
				}

				h += '<span class="mceTextIcon">';

				if (s.linkPosition) {
					if (s.linkPosition == 'left') {
						className.push('mceToolbarLinkOpenPositionLeft');
						h += DOM.createHTML('span', {'class': className.join(' ')}, '') + DOM.createHTML('span', {'class': 'mceToolbarLinkTitle'}, s.link);
					} else {
						className.push('mceToolbarLinkOpenPositionRight');
						h += DOM.createHTML('span', {'class': 'mceToolbarLinkTitle'}, s.link) + DOM.createHTML('span', {'class': className.join(' ')}, '');
					}
				} else {
					h += DOM.createHTML('span', {'class': 'mceToolbarLinkTitle'}, s.link);
				}

				h += '</span>';

			} else {
				h += '<span class="mceIcon ' + s['class'] + '"></span>' + (l ? '<span class="' + cp + 'Label">' + l + '</span>' : '');
			}

//			h += '<span class="mceVoiceLabel mceIconOnly" style="display: none;" id="' + this.id + '_voice">' + s.title + '</span>';
			h += '</a>';
			return h;
		},

		/**
		 * Post render handler. This function will be called after the UI has been
		 * rendered so that events can be added.
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, s = t.settings;

			tinymce.dom.Event.add(t.id, 'click', function(e) {
				if (!t.isDisabled())
					return s.onclick.call(s.scope, e);
			});
		}
	});
})(tinymce);
/**
 * ListBox.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each, Dispatcher = tinymce.util.Dispatcher;

	/**
	 * This class is used to create list boxes/select list. This one will generate
	 * a non native control. This one has the benefits of having visual items added.
	 *
	 * @class tinymce.ui.ListBox
	 * @extends tinymce.ui.Control
	 * @example
	 * // Creates a new plugin class and a custom listbox
	 * tinymce.create('tinymce.plugins.ExamplePlugin', {
	 *     createControl: function(n, cm) {
	 *         switch (n) {
	 *             case 'mylistbox':
	 *                 var mlb = cm.createListBox('mylistbox', {
	 *                      title : 'My list box',
	 *                      onselect : function(v) {
	 *                          tinyMCE.activeEditor.windowManager.alert('Value selected:' + v);
	 *                      }
	 *                 });
	 *
	 *                 // Add some values to the list box
	 *                 mlb.add('Some item 1', 'val1');
	 *                 mlb.add('some item 2', 'val2');
	 *                 mlb.add('some item 3', 'val3');
	 *
	 *                 // Return the new listbox instance
	 *                 return mlb;
	 *         }
	 *
	 *         return null;
	 *     }
	 * });
	 *
	 * // Register plugin with a short name
	 * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);
	 *
	 * // Initialize TinyMCE with the new plugin and button
	 * tinyMCE.init({
	 *    ...
	 *    plugins : '-example', // - means TinyMCE will not try to load it
	 *    theme_advanced_buttons1 : 'mylistbox' // Add the new example listbox to the toolbar
	 * });
	 */
	tinymce.create('tinymce.ui.ListBox:tinymce.ui.Control', {
		/**
		 * Constructs a new listbox control instance.
		 *
		 * @constructor
		 * @method ListBox
		 * @param {String} id Control id for the list box.
		 * @param {Object} s Optional name/value settings object.
		 * @param {Editor} ed Optional the editor instance this button is for.
		 */
		ListBox : function(id, s, ed) {
			var t = this;

			t.parent(id, s, ed);

			/**
			 * Array of ListBox items.
			 *
			 * @property items
			 * @type Array
			 */
			t.items = [];

			/**
			 * Fires when the selection has been changed.
			 *
			 * @event onChange
			 */
			t.onChange = new Dispatcher(t);

			/**
			 * Fires after the element has been rendered to DOM.
			 *
			 * @event onPostRender
			 */
			t.onPostRender = new Dispatcher(t);

			/**
			 * Fires when a new item is added.
			 *
			 * @event onAdd
			 */
			t.onAdd = new Dispatcher(t);

			/**
			 * Fires when the menu gets rendered.
			 *
			 * @event onRenderMenu
			 */
			t.onRenderMenu = new tinymce.util.Dispatcher(this);

			t.classPrefix = 'mceListBox';
		},

		/**
		 * Selects a item/option by value. This will both add a visual selection to the
		 * item and change the title of the control to the title of the option.
		 *
		 * @method select
		 * @param {String/function} va Value to look for inside the list box or a function selector.
		 */
		select : function(va) {
			var t = this, fv, f;

			if (va == undefined)
				return t.selectByIndex(-1);

			// Is string or number make function selector
			if (va && va.call)
				f = va;
			else {
				f = function(v) {
					return v == va;
				};
			}

			// Do we need to do something?
			if (va != t.selectedValue) {
				// Find item
				each(t.items, function(o, i) {
					if (f(o.value)) {
						fv = 1;
						t.selectByIndex(i);
						return false;
					}
				});

				if (!fv)
					t.selectByIndex(-1);
			}
		},

		/**
		 * Selects a item/option by index. This will both add a visual selection to the
		 * item and change the title of the control to the title of the option.
		 *
		 * @method selectByIndex
		 * @param {String} idx Index to select, pass -1 to select menu/title of select box.
		 */
		selectByIndex : function(idx) {
			var t = this, e, o, label;

			if (idx != t.selectedIndex) {
				e = DOM.get(t.id + '_text');
				label = DOM.get(t.id + '_voiceDesc');
				o = t.items[idx];

				if (o) {
					t.selectedValue = o.value;
					t.selectedIndex = idx;
					DOM.setHTML(e, DOM.encode(o.title));
					DOM.setHTML(label, t.settings.title + " - " + o.title);
					DOM.removeClass(e, 'mceTitle');
					DOM.setAttrib(t.id, 'aria-valuenow', o.title);
				} else {
					DOM.setHTML(e, DOM.encode(t.settings.title));
					DOM.setHTML(label, DOM.encode(t.settings.title));
					DOM.addClass(e, 'mceTitle');
					t.selectedValue = t.selectedIndex = null;
					DOM.setAttrib(t.id, 'aria-valuenow', t.settings.title);
				}
				e = 0;
			}
		},

		/**
		 * Adds a option item to the list box.
		 *
		 * @method add
		 * @param {String} n Title for the new option.
		 * @param {String} v Value for the new option.
		 * @param {Object} o Optional object with settings like for example class.
		 */
		add : function(n, v, o) {
			var t = this;

			o = o || {};
			o = tinymce.extend(o, {
				title : n,
				value : v
			});

			t.items.push(o);
			t.onAdd.dispatch(t, o);
		},

		/**
		 * Returns the number of items inside the list box.
		 *
		 * @method getLength
		 * @param {Number} Number of items inside the list box.
		 */
		getLength : function() {
			return this.items.length;
		},

		/**
		 * Renders the list box as a HTML string. This method is much faster than using the DOM and when
		 * creating a whole toolbar with buttons it does make a lot of difference.
		 *
		 * @method renderHTML
		 * @return {String} HTML for the list box control element.
		 */
		renderHTML : function() {
			var h = '', t = this, s = t.settings, cp = t.classPrefix;

			h = '<span role="listbox" aria-haspopup="true" aria-labelledby="' + t.id +'_voiceDesc" aria-describedby="' + t.id + '_voiceDesc"><table role="presentation" tabindex="0" id="' + t.id + '" cellpadding="0" cellspacing="0" class="' + cp + ' ' + cp + 'Enabled' + (s['class'] ? (' ' + s['class']) : '') + '"><tbody><tr>';
			h += '<td>' + DOM.createHTML('span', {id: t.id + '_voiceDesc', 'class': 'voiceLabel', style:'display:none;'}, t.settings.title);
			h += DOM.createHTML('a', {id : t.id + '_text', tabindex : -1, href : 'javascript:;', 'class' : 'mceText', onclick : "return false;", onmousedown : 'return false;'}, DOM.encode(t.settings.title)) + '</td>';
			h += '<td>' + DOM.createHTML('a', {id : t.id + '_open', tabindex : -1, href : 'javascript:;', 'class' : 'mceOpen', onclick : "return false;", onmousedown : 'return false;'}, '<span><span style="display:none;" class="mceIconOnly" aria-hidden="true">\u25BC</span></span>') + '</td>';
			h += '</tr></tbody></table></span>';

			return h;
		},

		/**
		 * Displays the drop menu with all items.
		 *
		 * @method showMenu
		 */
		showMenu : function() {
			var t = this, p2, e = DOM.get(this.id), m;

			if (t.isDisabled() || t.items.length == 0)
				return;

			if (t.menu && t.menu.isMenuVisible)
				return t.hideMenu();

			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			p2 = DOM.getPos(e);

			m = t.menu;
			m.settings.offset_x = p2.x;
			m.settings.offset_y = p2.y;
			m.settings.keyboard_focus = !tinymce.isOpera; // Opera is buggy when it comes to auto focus

			// Select in menu
			if (t.oldID)
				m.items[t.oldID].setSelected(0);

			each(t.items, function(o) {
				if (o.value === t.selectedValue) {
					m.items[o.id].setSelected(1);
					t.oldID = o.id;
				}
			});

			m.showMenu(0, e.clientHeight);

			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			DOM.addClass(t.id, t.classPrefix + 'Selected');

			//DOM.get(t.id + '_text').focus();
		},

		/**
		 * Hides the drop menu.
		 *
		 * @method hideMenu
		 */
		hideMenu : function(e) {
			var t = this;

			if (t.menu && t.menu.isMenuVisible) {
				DOM.removeClass(t.id, t.classPrefix + 'Selected');

				// Prevent double toogles by canceling the mouse click event to the button
				if (e && e.type == "mousedown" && (e.target.id == t.id + '_text' || e.target.id == t.id + '_open'))
					return;

				if (!e || !DOM.getParent(e.target, '.mceMenu')) {
					DOM.removeClass(t.id, t.classPrefix + 'Selected');
					Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
					t.menu.hideMenu();
				}
			}
		},

		/**
		 * Renders the menu to the DOM.
		 *
		 * @method renderMenu
		 */
		renderMenu : function() {
			var t = this, m;

			m = t.settings.control_manager.createDropMenu(t.id + '_menu', {
				menu_line : 1,
				'class' : t.classPrefix + 'Menu mceNoIcons',
				max_width : 150,
				max_height : 150
			});

			m.onHideMenu.add(function() {
				t.hideMenu();
				t.focus();
			});

			m.add({
				title : t.settings.title,
				'class' : 'mceMenuItemTitle',
				onclick : function() {
					if (t.settings.onselect('') !== false)
						t.select(''); // Must be runned after
				}
			});

			each(t.items, function(o) {
				// No value then treat it as a title
				if (o.value === undefined) {
					m.add({
						title : o.title,
						role : "option",
						'class' : 'mceMenuItemTitle',
						onclick : function() {
							if (t.settings.onselect('') !== false)
								t.select(''); // Must be runned after
						}
					});
				} else {
					o.id = DOM.uniqueId();
					o.role= "option";
					o.onclick = function() {
						if (t.settings.onselect(o.value) !== false)
							t.select(o.value); // Must be runned after
					};

					m.add(o);
				}
			});

			t.onRenderMenu.dispatch(t, m);
			t.menu = m;
		},

		/**
		 * Post render event. This will be executed after the control has been rendered and can be used to
		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, cp = t.classPrefix;

			Event.add(t.id, 'click', t.showMenu, t);
			Event.add(t.id, 'keydown', function(evt) {
				if (evt.keyCode == 32) { // Space
					t.showMenu(evt);
					Event.cancel(evt);
				}
			});
			Event.add(t.id, 'focus', function() {
				if (!t._focused) {
					t.keyDownHandler = Event.add(t.id, 'keydown', function(e) {
						if (e.keyCode == 40) {
							t.showMenu();
							Event.cancel(e);
						}
					});
					t.keyPressHandler = Event.add(t.id, 'keypress', function(e) {
						var v;
						if (e.keyCode == 13) {
							// Fake select on enter
							v = t.selectedValue;
							t.selectedValue = null; // Needs to be null to fake change
							Event.cancel(e);
							t.settings.onselect(v);
						}
					});
				}

				t._focused = 1;
			});
			Event.add(t.id, 'blur', function() {
				Event.remove(t.id, 'keydown', t.keyDownHandler);
				Event.remove(t.id, 'keypress', t.keyPressHandler);
				t._focused = 0;
			});

			// Old IE doesn't have hover on all elements
			if (tinymce.isIE6 || !DOM.boxModel) {
				Event.add(t.id, 'mouseover', function() {
					if (!DOM.hasClass(t.id, cp + 'Disabled'))
						DOM.addClass(t.id, cp + 'Hover');
				});

				Event.add(t.id, 'mouseout', function() {
					if (!DOM.hasClass(t.id, cp + 'Disabled'))
						DOM.removeClass(t.id, cp + 'Hover');
				});
			}

			t.onPostRender.dispatch(t, DOM.get(t.id));
		},

		/**
		 * Destroys the ListBox i.e. clear memory and events.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.parent();

			Event.clear(this.id + '_text');
			Event.clear(this.id + '_open');
		}
	});
})(tinymce);
/**
 * NativeListBox.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each, Dispatcher = tinymce.util.Dispatcher;

	/**
	 * This class is used to create list boxes/select list. This one will generate
	 * a native control the way that the browser produces them by default.
	 *
	 * @class tinymce.ui.NativeListBox
	 * @extends tinymce.ui.ListBox
	 */
	tinymce.create('tinymce.ui.NativeListBox:tinymce.ui.ListBox', {
		/**
		 * Constructs a new button control instance.
		 *
		 * @constructor
		 * @method NativeListBox
		 * @param {String} id Button control id for the button.
		 * @param {Object} s Optional name/value settings object.
		 */
		NativeListBox : function(id, s) {
			this.parent(id, s);
			this.classPrefix = 'mceNativeListBox';
		},

		/**
		 * Sets the disabled state for the control. This will add CSS classes to the
		 * element that contains the control. So that it can be disabled visually.
		 *
		 * @method setDisabled
		 * @param {Boolean} s Boolean state if the control should be disabled or not.
		 */
		setDisabled : function(s) {
			DOM.get(this.id).disabled = s;
			this.setAriaProperty('disabled', s);
		},

		/**
		 * Returns true/false if the control is disabled or not. This is a method since you can then
		 * choose to check some class or some internal bool state in subclasses.
		 *
		 * @method isDisabled
		 * @return {Boolean} true/false if the control is disabled or not.
		 */
		isDisabled : function() {
			return DOM.get(this.id).disabled;
		},

		/**
		 * Selects a item/option by value. This will both add a visual selection to the
		 * item and change the title of the control to the title of the option.
		 *
		 * @method select
		 * @param {String/function} va Value to look for inside the list box or a function selector.
		 */
		select : function(va) {
			var t = this, fv, f;

			if (va == undefined)
				return t.selectByIndex(-1);

			// Is string or number make function selector
			if (va && va.call)
				f = va;
			else {
				f = function(v) {
					return v == va;
				};
			}

			// Do we need to do something?
			if (va != t.selectedValue) {
				// Find item
				each(t.items, function(o, i) {
					if (f(o.value)) {
						fv = 1;
						t.selectByIndex(i);
						return false;
					}
				});

				if (!fv)
					t.selectByIndex(-1);
			}
		},

		/**
		 * Selects a item/option by index. This will both add a visual selection to the
		 * item and change the title of the control to the title of the option.
		 *
		 * @method selectByIndex
		 * @param {String} idx Index to select, pass -1 to select menu/title of select box.
		 */
		selectByIndex : function(idx) {
			DOM.get(this.id).selectedIndex = idx + 1;
			this.selectedValue = this.items[idx] ? this.items[idx].value : null;
		},

		/**
		 * Adds a option item to the list box.
		 *
		 * @method add
		 * @param {String} n Title for the new option.
		 * @param {String} v Value for the new option.
		 * @param {Object} o Optional object with settings like for example class.
		 */
		add : function(n, v, a) {
			var o, t = this;

			a = a || {};
			a.value = v;

			if (t.isRendered())
				DOM.add(DOM.get(this.id), 'option', a, n);

			o = {
				title : n,
				value : v,
				attribs : a
			};

			t.items.push(o);
			t.onAdd.dispatch(t, o);
		},

		/**
		 * Executes the specified callback function for the menu item. In this case when the user clicks the menu item.
		 *
		 * @method getLength
		 */
		getLength : function() {
			return this.items.length;
		},

		/**
		 * Renders the list box as a HTML string. This method is much faster than using the DOM and when
		 * creating a whole toolbar with buttons it does make a lot of difference.
		 *
		 * @method renderHTML
		 * @return {String} HTML for the list box control element.
		 */
		renderHTML : function() {
			var h, t = this;

			h = DOM.createHTML('option', {value : ''}, '-- ' + t.settings.title + ' --');

			each(t.items, function(it) {
				h += DOM.createHTML('option', {value : it.value}, it.title);
			});

			h = DOM.createHTML('select', {id : t.id, 'class' : 'mceNativeListBox', 'aria-labelledby': t.id + '_aria'}, h);
			h += DOM.createHTML('span', {id : t.id + '_aria', 'style': 'display: none'}, t.settings.title);
			return h;
		},

		/**
		 * Post render handler. This function will be called after the UI has been
		 * rendered so that events can be added.
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, ch, changeListenerAdded = true;

			t.rendered = true;

			function onChange(e) {
				var v = t.items[e.target.selectedIndex - 1];

				if (v && (v = v.value)) {
					t.onChange.dispatch(t, v);

					if (t.settings.onselect)
						t.settings.onselect(v);
				}
			};

			Event.add(t.id, 'change', onChange);

			// Accessibility keyhandler
			Event.add(t.id, 'keydown', function(e) {
				var bf;

				Event.remove(t.id, 'change', ch);
				changeListenerAdded = false;

				bf = Event.add(t.id, 'blur', function() {
					if (changeListenerAdded) return;
					changeListenerAdded = true;
					Event.add(t.id, 'change', onChange);
					Event.remove(t.id, 'blur', bf);
				});

				//prevent default left and right keys on chrome - so that the keyboard navigation is used.
				if (tinymce.isWebKit && (e.keyCode==37 ||e.keyCode==39)) {
					return Event.prevent(e);
				}

				if (e.keyCode == 13 || e.keyCode == 32) {
					onChange(e);
					return Event.cancel(e);
				}
			});

			t.onPostRender.dispatch(t, DOM.get(t.id));
		}
	});
})(tinymce);
/**
 * MenuButton.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each;

	/**
	 * This class is used to create a UI button. A button is basically a link
	 * that is styled to look like a button or icon.
	 *
	 * @class tinymce.ui.MenuButton
	 * @extends tinymce.ui.Control
	 * @example
	 * // Creates a new plugin class and a custom menu button
	 * tinymce.create('tinymce.plugins.ExamplePlugin', {
	 *     createControl: function(n, cm) {
	 *         switch (n) {
	 *             case 'mymenubutton':
	 *                 var c = cm.createSplitButton('mysplitbutton', {
	 *                     title : 'My menu button',
	 *                     image : 'some.gif'
	 *                 });
	 *
	 *                 c.onRenderMenu.add(function(c, m) {
	 *                     m.add({title : 'Some title', 'class' : 'mceMenuItemTitle'}).setDisabled(1);
	 *
	 *                     m.add({title : 'Some item 1', onclick : function() {
	 *                         alert('Some item 1 was clicked.');
	 *                     }});
	 *
	 *                     m.add({title : 'Some item 2', onclick : function() {
	 *                         alert('Some item 2 was clicked.');
	 *                     }});
	 *               });
	 *
	 *               // Return the new menubutton instance
	 *               return c;
	 *         }
	 *
	 *         return null;
	 *     }
	 * });
	 */
	tinymce.create('tinymce.ui.MenuButton:tinymce.ui.Button', {
		/**
		 * Constructs a new split button control instance.
		 *
		 * @constructor
		 * @method MenuButton
		 * @param {String} id Control id for the split button.
		 * @param {Object} s Optional name/value settings object.
		 * @param {Editor} ed Optional the editor instance this button is for.
		 */
		MenuButton : function(id, s, ed) {
			this.parent(id, s, ed);

			/**
			 * Fires when the menu is rendered.
			 *
			 * @event onRenderMenu
			 */
			this.onRenderMenu = new tinymce.util.Dispatcher(this);

			s.menu_container = s.menu_container || DOM.doc.body;
		},

		/**
		 * Shows the menu.
		 *
		 * @method showMenu
		 */
		showMenu : function() {
			var t = this, p1, p2, e = DOM.get(t.id), m;

			if (t.isDisabled())
				return;

			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			if (t.isMenuVisible)
				return t.hideMenu();

			p1 = DOM.getPos(t.settings.menu_container);
			p2 = DOM.getPos(e);

			m = t.menu;
			m.settings.offset_x = p2.x;
			m.settings.offset_y = p2.y;
			m.settings.vp_offset_x = p2.x;
			m.settings.vp_offset_y = p2.y;
			m.settings.keyboard_focus = t._focused;
			m.showMenu(0, e.clientHeight);

			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			t.setState('Selected', 1);

			t.isMenuVisible = 1;
		},

		/**
		 * Renders the menu to the DOM.
		 *
		 * @method renderMenu
		 */
		renderMenu : function() {
			var t = this, m;

			m = t.settings.control_manager.createDropMenu(t.id + '_menu', {
				menu_line : 1,
				'class' : this.classPrefix + 'Menu',
				icons : t.settings.icons
			});

			m.onHideMenu.add(function() {
				t.hideMenu();
				t.focus();
			});

			t.onRenderMenu.dispatch(t, m);
			t.menu = m;
		},

		/**
		 * Hides the menu. The optional event parameter is used to check where the event occured so it
		 * doesn't close them menu if it was a event inside the menu.
		 *
		 * @method hideMenu
		 * @param {Event} e Optional event object.
		 */
		hideMenu : function(e) {
			var t = this;

			// Prevent double toogles by canceling the mouse click event to the button
			if (e && e.type == "mousedown" && DOM.getParent(e.target, function(e) {return e.id === t.id || e.id === t.id + '_open';}))
				return;

			if (!e || !DOM.getParent(e.target, '.mceMenu')) {
				t.setState('Selected', 0);
				Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
				if (t.menu)
					t.menu.hideMenu();
			}

			t.isMenuVisible = 0;
		},

		/**
		 * Post render handler. This function will be called after the UI has been
		 * rendered so that events can be added.
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, s = t.settings;

			Event.add(t.id, 'click', function() {
				if (!t.isDisabled()) {
					if (s.onclick)
						s.onclick(t.value);

					t.showMenu();
				}
			});
		}
	});
})(tinymce);
/**
 * SplitButton.js
 *
 * Copyright, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each;

	/**
	 * This class is used to create a split button. A button with a menu attached to it.
	 *
	 * @class tinymce.ui.SplitButton
	 * @extends tinymce.ui.Button
	 * @example
	 * // Creates a new plugin class and a custom split button
	 * tinymce.create('tinymce.plugins.ExamplePlugin', {
	 *     createControl: function(n, cm) {
	 *         switch (n) {
	 *             case 'mysplitbutton':
	 *                 var c = cm.createSplitButton('mysplitbutton', {
	 *                     title : 'My split button',
	 *                     image : 'some.gif',
	 *                     onclick : function() {
	 *                         alert('Button was clicked.');
	 *                     }
	 *                 });
	 *
	 *                 c.onRenderMenu.add(function(c, m) {
	 *                     m.add({title : 'Some title', 'class' : 'mceMenuItemTitle'}).setDisabled(1);
	 *
	 *                     m.add({title : 'Some item 1', onclick : function() {
	 *                         alert('Some item 1 was clicked.');
	 *                     }});
	 *
	 *                     m.add({title : 'Some item 2', onclick : function() {
	 *                         alert('Some item 2 was clicked.');
	 *                     }});
	 *                 });
	 *
	 *               // Return the new splitbutton instance
	 *               return c;
	 *         }
	 *
	 *         return null;
	 *     }
	 * });
	 */
	tinymce.create('tinymce.ui.SplitButton:tinymce.ui.MenuButton', {
		/**
		 * Constructs a new split button control instance.
		 *
		 * @constructor
		 * @method SplitButton
		 * @param {String} id Control id for the split button.
		 * @param {Object} s Optional name/value settings object.
		 * @param {Editor} ed Optional the editor instance this button is for.
		 */
		SplitButton : function(id, s, ed) {
			this.parent(id, s, ed);
			this.classPrefix = 'mceSplitButton';
		},

		/**
		 * Renders the split button as a HTML string. This method is much faster than using the DOM and when
		 * creating a whole toolbar with buttons it does make a lot of difference.
		 *
		 * @method renderHTML
		 * @return {String} HTML for the split button control element.
		 */
		renderHTML : function() {
			var h = '', t = this, s = t.settings, h1;

			if (s.link) {

				var className = ['mceToolbarLinkOpen'];
				if (s.linkAlign) {
					if (s.linkAlign == 'left') {
						className.push('mceToolbarLinkOpenAlignLeft');
					} else {
						className.push('mceToolbarLinkOpenAlignRight');
					}
				}

				h += '<span class="mceTextIcon">';

				if (s.linkPosition) {
					if (s.linkPosition == 'left') {
						className.push('mceToolbarLinkOpenPositionLeft');
						h += DOM.createHTML('span', {'class': className.join(' ')}, '') + DOM.createHTML('span', {'class': 'mceToolbarLinkTitle'}, s.link);
					} else {
						className.push('mceToolbarLinkOpenPositionRight');
						h += DOM.createHTML('span', {'class': 'mceToolbarLinkTitle'}, s.link) + DOM.createHTML('span', {'class': className.join(' ')}, '');
					}
				} else {
					h += DOM.createHTML('span', {'class': 'mceToolbarLinkTitle'}, s.link);
				}

				h += '</span>';

				h = DOM.createHTML('a', {role: 'button', id : t.id + '_action', tabindex: '-1', href : 'javascript:;', 'class' : 'mceToolbarLink ' + s['class'], onclick : "return false;", onmousedown : 'return false;', title : s.title}, h);
				h = DOM.createHTML('div', {id: t.id, 'class': 'mceSplitButtonContainer'}, h);

			} else {

				h = '<tbody><tr>';

				if (s.image)
					h1 = DOM.createHTML('img ', {src : s.image, role: 'presentation', 'class' : 'mceAction ' + s['class']});
				else
					h1 = DOM.createHTML('span', {'class' : 'mceAction ' + s['class']}, '');

//				h1 += DOM.createHTML('span', {'class': 'mceVoiceLabel mceIconOnly', id: t.id + '_voice', style: 'display:none;'}, s.title);
				h += '<td >' + DOM.createHTML('a', {role: 'button', id : t.id + '_action', tabindex: '-1', href : 'javascript:;', 'class' : 'mceAction ' + s['class'], onclick : "return false;", onmousedown : 'return false;', title : s.title}, h1) + '</td>';

//				h1 = DOM.createHTML('span', {'class' : 'mceOpen ' + s['class']}, '<span style="display:none;" class="mceIconOnly" aria-hidden="true">\u25BC</span>');
//				h += '<td >' + DOM.createHTML('a', {role: 'button', id : t.id + '_open', tabindex: '-1', href : 'javascript:;', 'class' : 'mceOpen ' + s['class'], onclick : "return false;", onmousedown : 'return false;', title : s.title}, h1) + '</td>';

				h += '</tr></tbody>';
				h = DOM.createHTML('table', { role: 'presentation',   'class' : 'mceSplitButton mceSplitButtonEnabled ' + s['class'], cellpadding : '0', cellspacing : '0', title : s.title}, h);
				h = DOM.createHTML('div', {id : t.id, role: 'button', tabindex: '0', 'aria-labelledby': t.id + '_voice', 'aria-haspopup': 'true'}, h);
			}

			return h;
		},

		/**
		 * Post render handler. This function will be called after the UI has been
		 * rendered so that events can be added.
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, s = t.settings, activate;

//			if (s.onclick) {
//				activate = function(evt) {
//					if (!t.isDisabled()) {
//						s.onclick(t.value);
//						Event.cancel(evt);
//					}
//				};
//				Event.add(t.id + '_action', 'click', activate);
//				Event.add(t.id, ['click', 'keydown'], function(evt) {
//					var DOM_VK_SPACE = 32, DOM_VK_ENTER = 14, DOM_VK_RETURN = 13, DOM_VK_UP = 38, DOM_VK_DOWN = 40;
//					if ((evt.keyCode === 32 || evt.keyCode === 13 || evt.keyCode === 14) && !evt.altKey && !evt.ctrlKey && !evt.metaKey) {
//						activate();
//						Event.cancel(evt);
//					} else if (evt.type === 'click' || evt.keyCode === DOM_VK_DOWN) {
//						t.showMenu();
//						Event.cancel(evt);
//					}
//				});
//			}

			Event.add(t.id + '_action', 'click', function (evt) {
				t.showMenu();
				Event.cancel(evt);
			});
			Event.add([t.id, t.id + '_action'], 'focus', function() {t._focused = 1;});
			Event.add([t.id, t.id + '_action'], 'blur', function() {t._focused = 0;});

			// Old IE doesn't have hover on all elements
			if (tinymce.isIE6 || !DOM.boxModel) {
				Event.add(t.id, 'mouseover', function() {
					if (!DOM.hasClass(t.id, 'mceSplitButtonDisabled'))
						DOM.addClass(t.id, 'mceSplitButtonHover');
				});

				Event.add(t.id, 'mouseout', function() {
					if (!DOM.hasClass(t.id, 'mceSplitButtonDisabled'))
						DOM.removeClass(t.id, 'mceSplitButtonHover');
				});
			}
		},

		destroy : function() {
			this.parent();

			Event.clear(this.id + '_action');
			Event.clear(this.id + '_open');
			Event.clear(this.id);
		}
	});
})(tinymce);
/**
 * ColorSplitButton.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;

	/**
	 * This class is used to create UI color split button. A color split button will present show a small color picker
	 * when you press the open menu.
	 *
	 * @class tinymce.ui.ColorSplitButton
	 * @extends tinymce.ui.SplitButton
	 */
	tinymce.create('tinymce.ui.ColorSplitButton:tinymce.ui.SplitButton', {
		/**
		 * Constructs a new color split button control instance.
		 *
		 * @constructor
		 * @method ColorSplitButton
		 * @param {String} id Control id for the color split button.
		 * @param {Object} s Optional name/value settings object.
		 * @param {Editor} ed The editor instance this button is for.
		 */
		ColorSplitButton : function(id, s, ed) {
			var t = this;

			t.parent(id, s, ed);

			/**
			 * Settings object.
			 *
			 * @property settings
			 * @type Object
			 */
			t.settings = s = tinymce.extend({
				colors : ',ffffff,bcbcbc,6c6c6c,454545,2c2c2c,000000,fcc9c9,fe8c8c,fe5e5e,fd5b36,f82e00,fb2c2c,bf0000,ffe1c6,ffc998,fcad66,ff9331,ff810f,ff9c00,ff6000,d8ffe0,92f9a7,34ff5d,b2fb82,89f641,5cd809,05840b,b7e9ec,56e5ed,21cad3,03939b,039b80,006d5a,00484c,cac8e9,9690ea,6a60ec,4866e7,173bd3,001c91,001055,f3cafb,e287f4,c238dd,a476af,b53dd2,7a00c7,520384',
				grid_width : 7,
				default_color : '#000000'
			}, t.settings);

			/**
			 * Fires when the menu is shown.
			 *
			 * @event onShowMenu
			 */
			t.onShowMenu = new tinymce.util.Dispatcher(t);

			/**
			 * Fires when the menu is hidden.
			 *
			 * @event onHideMenu
			 */
			t.onHideMenu = new tinymce.util.Dispatcher(t);

			/**
			 * Current color value.
			 *
			 * @property value
			 * @type String
			 */
			t.value = s.default_color;
		},


		/**
		 * Shows the color menu. The color menu is a layer places under the button
		 * and displays a table of colors for the user to pick from.
		 *
		 * @method showMenu
		 */
		showMenu : function() {
			var t = this, r, p, e, p2;

			if (t.isDisabled())
				return;

			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			if (t.isMenuVisible)
				return t.hideMenu();

			e = DOM.get(t.id);
			DOM.show(t.id + '_menu');
			DOM.addClass(e, 'mceSplitButtonSelected');
			e = 0;

			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			t.onShowMenu.dispatch(t);

			if (t._focused) {
				t._keyHandler = Event.add(t.id + '_menu', 'keydown', function(e) {
					if (e.keyCode == 27)
						t.hideMenu();
				});

				DOM.select('a', t.id + '_menu')[0].focus(); // Select first link
			}

			t.isMenuVisible = 1;
		},

		/**
		 * Hides the color menu. The optional event parameter is used to check where the event occured so it
		 * doesn't close them menu if it was a event inside the menu.
		 *
		 * @method hideMenu
		 * @param {Event} e Optional event object.
		 */
		hideMenu : function(e) {
			var t = this;

			if (t.isMenuVisible) {
				// Prevent double toogles by canceling the mouse click event to the button
				if (e && e.type == "mousedown" && DOM.getParent(e.target, function(e) {return e.id === t.id + '_action';})) {
					return;
				}

				if (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {
					DOM.removeClass(t.id, 'mceSplitButtonSelected');
					Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
					Event.remove(t.id + '_menu', 'keydown', t._keyHandler);
					DOM.hide(t.id + '_menu');
				}

				t.isMenuVisible = 0;
			}
		},

		/**
		 * Renders the menu to the DOM.
		 *
		 * @method renderMenu
		 */
		renderMenu : function() {
			var t = this, m, i = 0, s = t.settings, n, tb, tr, w;

			w = DOM.add(DOM.get(t.id + '_action').parentNode, 'div', {id : t.id + '_menu', 'class' : s['menu_class'] + ' ' + s['class'], style : 'position:absolute;'});
			m = DOM.add(w, 'div', {'class' : s['class'] + ' mceSplitButtonMenu'});

			n = DOM.add(m, 'table', {'class' : 'mceColorSplitMenu'});
			tb = DOM.add(n, 'tbody');

			// Generate color grid
			i = 0;
			each(is(s.colors, 'array') ? s.colors : s.colors.split(','), function(c) {

				if (!i--) {
					tr = DOM.add(tb, 'tr');
					i = s.grid_width - 1;
				}

				n = DOM.add(tr, 'td');

				var vars = {
					href : 'javascript:;',
					style : {}
				};

				if (c)
				{
					vars.style.backgroundColor = '#' + c;
					vars['_mce_color'] = '#' + c;
				}
				else
				{
					vars['class'] = 'color_inherit';
					vars['_mce_color'] = 'transparent';
				}

				n = DOM.add(n, 'a', vars);
			});

			DOM.addClass(m, 'mceColorSplitMenu');

			Event.add(t.id + '_menu', 'mousedown', function (e) {
				return Event.cancel(e);
			});

			Event.add(t.id + '_menu', 'click', function(e) {
				var c;

				e = e.target;

				if (e.nodeName == 'A' && (c = e.getAttribute('_mce_color')))
					t.setColor(c);

				return Event.cancel(e); // Prevent IE auto save warning
			});

			return w;
		},

		/**
		 * Sets the current color for the control and hides the menu if it should be visible.
		 *
		 * @method setColor
		 * @param {String} c Color code value in hex for example: #FF00FF
		 */
		setColor : function(c) {
			this.displayColor(c);
			this.hideMenu();
			this.settings.onselect(c);
		},

		/**
		 * Change the currently selected color for the control.
		 *
		 * @method displayColor
		 * @param {String} c Color code value in hex for example: #FF00FF
		 */
		displayColor : function(c) {
			var t = this;

			DOM.setStyle(t.id + '_preview', 'backgroundColor', c);

			t.value = c;
		},

		/**
		 * Post render event. This will be executed after the control has been rendered and can be used to
		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, id = t.id;

			t.parent();
//			DOM.add(id + '_action', 'div', {id : id + '_preview', 'class' : 'mceColorPreview'});
//			DOM.setStyle(t.id + '_preview', 'backgroundColor', t.value);
		},

		/**
		 * Destroys the control. This means it will be removed from the DOM and any
		 * events tied to it will also be removed.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.parent();

			Event.clear(this.id + '_menu');
			Event.clear(this.id + '_more');
			DOM.remove(this.id + '_menu');
		}
	});
})(tinymce);/**
 * ToolbarGroup.js
 *
 * Copyright 2010, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
// Shorten class names
var dom = tinymce.DOM, each = tinymce.each, Event = tinymce.dom.Event;
/**
 * This class is used to group a set of toolbars together and control the keyboard navigation and focus.
 *
 * @class tinymce.ui.ToolbarGroup
 * @extends tinymce.ui.Container
 */
tinymce.create('tinymce.ui.ToolbarGroup:tinymce.ui.Container', {
	/**
	 * Renders the toolbar group as a HTML string.
	 *
	 * @method renderHTML
	 * @return {String} HTML for the toolbar control.
	 */
	renderHTML : function() {
		var t = this, h = [], controls = t.controls, each = tinymce.each, settings = t.settings;

		h.push('<div id="' + t.id + '" role="group" aria-labelledby="' + t.id + '_voice">');
		//TODO: ACC test this out - adding a role = application for getting the landmarks working well.
		h.push("<span role='application'>");
		h.push('<span id="' + t.id + '_voice" class="mceVoiceLabel" style="display:none;">' + dom.encode(settings.name) + '</span>');
		each(controls, function(toolbar) {
			h.push(toolbar.renderHTML());
		});
		h.push("</span>");
		h.push('</div>');

		return h.join('');
	},

	focus : function() {
		var t = this;
		dom.get(t.id).focus();
	},

	postRender : function() {
		var t = this, items = [];

		each(t.controls, function(toolbar) {
			each (toolbar.controls, function(control) {
				if (control.id) {
					items.push(control);
				}
			});
		});

		t.keyNav = new tinymce.ui.KeyboardNavigation({
			root: t.id,
			items: items,
			onCancel: function() {
				//Move focus if webkit so that navigation back will read the item.
				if (tinymce.isWebKit) {
					dom.get(t.editor.id+"_ifr").focus();
				}
				t.editor.focus();
			},
			excludeFromTabOrder: !t.settings.tab_focus_toolbar
		});
	},

	destroy : function() {
		var self = this;

		self.parent();
		self.keyNav.destroy();
		Event.clear(self.id);
	}
});
})(tinymce);
/**
 * Toolbar.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
// Shorten class names
var dom = tinymce.DOM, each = tinymce.each;
/**
 * This class is used to create toolbars a toolbar is a container for other controls like buttons etc.
 *
 * @class tinymce.ui.Toolbar
 * @extends tinymce.ui.Container
 */
tinymce.create('tinymce.ui.Toolbar:tinymce.ui.Container', {
	/**
	 * Renders the toolbar as a HTML string. This method is much faster than using the DOM and when
	 * creating a whole toolbar with buttons it does make a lot of difference.
	 *
	 * @method renderHTML
	 * @return {String} HTML for the toolbar control.
	 */
	renderHTML : function() {
		var t = this, h = '', c, co, s = t.settings, i, pr, nx, cl;

		cl = t.controls;
		for (i=0; i<cl.length; i++) {
			// Get current control, prev control, next control and if the control is a list box or not
			co = cl[i];
			pr = cl[i - 1];
			nx = cl[i + 1];

			// Add toolbar start
			if (i === 0) {
				c = 'mceToolbarStart';

				if (co.Button)
					c += ' mceToolbarStartButton';
				else if (co.SplitButton)
					c += ' mceToolbarStartSplitButton';
				else if (co.ListBox)
					c += ' mceToolbarStartListBox';

				h += dom.createHTML('td', {'class' : c}, dom.createHTML('span', null, '<!-- IE -->'));

				if (s.title)
					h += dom.createHTML('td', {'class' : 'mceToolbarTitle'}, dom.createHTML('span', null, s.title));
			}

			// Add toolbar end before list box and after the previous button
			// This is to fix the o2k7 editor skins
			if (pr && co.ListBox) {
				if (pr.Button || pr.SplitButton)
					h += dom.createHTML('td', {'class' : 'mceToolbarEnd'}, dom.createHTML('span', null, '<!-- IE -->'));
			}

			// Render control HTML

			// IE 8 quick fix, needed to propertly generate a hit area for anchors
			if (dom.stdMode)
				h += '<td style="position: relative">' + co.renderHTML() + '</td>';
			else
				h += '<td>' + co.renderHTML() + '</td>';

			// Add toolbar start after list box and before the next button
			// This is to fix the o2k7 editor skins
			if (nx && co.ListBox) {
				if (nx.Button || nx.SplitButton)
					h += dom.createHTML('td', {'class' : 'mceToolbarStart'}, dom.createHTML('span', null, '<!-- IE -->'));
			}
		}

		c = 'mceToolbarEnd';

		if (co.Button)
			c += ' mceToolbarEndButton';
		else if (co.SplitButton)
			c += ' mceToolbarEndSplitButton';
		else if (co.ListBox)
			c += ' mceToolbarEndListBox';

		h += dom.createHTML('td', {'class' : c}, dom.createHTML('span', null, '<!-- IE -->'));

		return dom.createHTML('table', {id : t.id, 'class' : 'mceToolbar' + (s['class'] ? ' ' + s['class'] : ''), cellpadding : '0', cellspacing : '0', align : t.settings.align || '', role: 'presentation'}, '<tbody><tr>' + h + '</tr></tbody>');
	}
});
})(tinymce);
(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;

	tinymce.create('tinymce.ui.AddLinkMenu', {

		AddLinkMenu: function(ed)
		{
			var t = this;

			t.onShowMenu = new tinymce.util.Dispatcher(t);
			t.onHideMenu = new tinymce.util.Dispatcher(t);

			t.formId = DOM.uniqueId();
			t.id = DOM.uniqueId();
			t.ed = ed;
		},

		showMenu: function()
		{
			var t = this, r, p, p2, ed = t.ed;
			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			if (t.isMenuVisible)
				return t.hideMenu();

			var form = DOM.get(t.formId);

			var e = DOM.getParent(ed.selection.getNode(), 'A');
			if (e)
			{
				form.elements['href'].value = e.href;
				form.elements['title'].value = e.innerHTML;
			}
			else
			{
				var selectionText = ed.selection.getContent({'format': 'text'});
				form.elements['href'].value = 'http://';
				form.elements['title'].value = selectionText;
			}

			DOM.show(t.id + '_menu');

			ed.onMouseDown.add(t.hideMenu, t);
			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			t.onShowMenu.dispatch(t);

			t.isMenuVisible = 1;
		},

		hideMenu : function(e) {
			var t = this, ed = t.ed;

			// Prevent double toogles by canceling the mouse click event to the button
			if (e && e.type == "mousedown" && DOM.getParent(e.target, function(e) {return e.id === t.id + '_action';}))
				return;

			if (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {
				DOM.removeClass(t.id, 'mceSplitButtonSelected');
				Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
				Event.remove(t.id + '_menu', 'keydown', t._keyHandler);
				DOM.hide(t.id + '_menu');
				ed.onMouseDown.remove(t.hideMenu, t);
			}

			t.onHideMenu.dispatch(t);

			t.isMenuVisible = 0;
		},

		renderMenu: function()
		{
			var t = this, m, i = 0, s = t.settings, n, tb, tr, w, ed = t.ed;

			var cancelId = DOM.uniqueId();
			var addId = DOM.uniqueId();
			var html = '';

			html += '<form id="' + t.formId + '">';
				html += '<div class="mceLabel">' + ed.getLang('compose.add_link_form_href_label') + '</div>';
				html += '<div class="mceField"><input type="text" name="href" value=""/></div>';
				html += '<div class="mceLabel">' + ed.getLang('compose.add_link_form_title_label') + '</div>';
				html += '<div class="mceField"><input type="text" name="title"/></div>';
				html += '<div class="mceControls"><input type="submit" value="' + ed.getLang('compose.add_link_form_add') + '" id="' + addId + '"/><input type="button" value="' + ed.getLang('compose.add_link_form_cancel') + '" id="' + cancelId + '"/></div>';
			html += '</form>';

			var menu = DOM.add(DOM.get(ed.id + '_external'), 'div', {'id' : t.id + '_menu', 'class': 'defaultSkin mceSplitButtonMenu mceLinkMenu'}, html);
			DOM.setStyles(menu, {
				'display': 'none',
				'position': 'absolute',
				'left': '50%'
			});

			Event.add(addId, 'click', this._submit, this);
			Event.add(cancelId, 'click', this._cancel, this);
			Event.add(menu, 'click', Event.stop);
		},

		_submit: function(evt)
		{
			var t = this, form = DOM.get(t.formId), ed = t.ed;

			t.hideMenu();

			ed.selection.moveToBookmark(t.bm);

			var linkHref = form.elements['href'].value;
			var linkTitle = form.elements['title'].value;

			var e = DOM.getParent(ed.selection.getNode(), 'A');
			if (e)
			{
				e.href = linkHref;
				e.innerHTML = linkTitle;
			}
			else
			{
				var selectionText = ed.selection.getContent({'format': 'text'});
				var linkHTML = '';

				if (linkTitle.length)
				{
					linkHTML = '<a href="' + linkHref + '">' + linkTitle + '</a>';
				}
				else if (selectionText.length)
				{
					linkHTML = '<a href="' + linkHref + '">' + selectionText + '</a>';
				}
				else
				{
					linkHTML = '<a href="' + linkHref + '">' + linkHref + '</a>';
				}

				ed.selection.setContent(linkHTML);
			}

			ed.onChange.dispatch(ed);
			ed.focus();

			return Event.cancel(evt);
		},

		_cancel: function(evt)
		{
			this.hideMenu();
			return Event.cancel(evt);
		}

	});
})(tinymce);
/**
 * ColorSplitButton.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;

	tinymce.create('tinymce.ui.AppsButton:tinymce.ui.SplitButton', {

		AppsButton : function(id, s) {
			var t = this;

			t.parent(id, s);

			var ed = t.scope.editor;

			/**
			 * Fires when the menu is shown.
			 *
			 * @event onShowMenu
			 */
			t.onShowMenu = new tinymce.util.Dispatcher(t);

			/**
			 * Fires when the menu is hidden.
			 *
			 * @event onHideMenu
			 */
			t.onHideMenu = new tinymce.util.Dispatcher(t);

			t.controls = [];

			each(s.controls, function(v) {

				var control = new tinymce.ui.Control(ed.editorId + '_' + v, {'cmd': ed.theme.controls[v][1], 'title': ed.getLang('compose.' + ed.theme.controls[v][0]), 'class': ed.theme.controls[v][1]});
				t.controls.push(ed.controlManager.add(control));
			});

			each(s.apps, function(v, k) {

				var control = new tinymce.ui.Control(ed.editorId + '_app' + k, {'cmd': 'mceShowApp', 'title': v, 'class': 'mceApp' + k, 'value': k});
				t.controls.push(ed.controlManager.add(control));
			});
		},

		/**
		 * Shows the color menu. The color menu is a layer places under the button
		 * and displays a table of colors for the user to pick from.
		 *
		 * @method showMenu
		 */
		showMenu : function() {
			var t = this, r, p, e, p2;

			if (t.isDisabled())
				return;

			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			if (t.isMenuVisible)
				return t.hideMenu();

			e = DOM.get(t.id);
			DOM.show(t.id + '_menu');
			DOM.addClass(e, 'mceSplitButtonSelected');
			e = 0;
			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			t.onShowMenu.dispatch(t);

			if (t._focused) {
				t._keyHandler = Event.add(t.id + '_menu', 'keydown', function(e) {
					if (e.keyCode == 27)
						t.hideMenu();
				});

				DOM.select('a', t.id + '_menu')[0].focus(); // Select first link
			}

			t.isMenuVisible = 1;
		},

		/**
		 * Hides the color menu. The optional event parameter is used to check where the event occured so it
		 * doesn't close them menu if it was a event inside the menu.
		 *
		 * @method hideMenu
		 * @param {Event} e Optional event object.
		 */
		hideMenu : function(e) {
			var t = this;

			// Prevent double toogles by canceling the mouse click event to the button
			if (e && e.type == "mousedown" && DOM.getParent(e.target, function(e) {return e.id === t.id + '_action';}))
				return;

			if (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {
				DOM.removeClass(t.id, 'mceSplitButtonSelected');
				Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
				Event.remove(t.id + '_menu', 'keydown', t._keyHandler);
				DOM.hide(t.id + '_menu');
			}

			t.onHideMenu.dispatch(t);

			t.isMenuVisible = 0;
		},

		/**
		 * Renders the menu to the DOM.
		 *
		 * @method renderMenu
		 */
		renderMenu : function() {

			var t = this, m, i = 0, s = t.settings, n, tb, tr, w, ed = t.scope.editor;

			w = DOM.add(DOM.get(t.id + '_action').parentNode, 'div', {id : t.id + '_menu', 'class' : s['menu_class'] + ' ' + s['class'], style : 'position:absolute;'});
			m = DOM.add(w, 'div', {'class' : s['class'] + ' mceSplitButtonMenu'});
            m = DOM.add(m, 'div', {'class' : s['class'] + ' mceControlsButtonMenu'});

			each(t.controls, function(control) {

				var n1 = DOM.add(m, 'div', {'class' : 'mceSplitButtonItem ' + control.settings['class']});
				var n2 = DOM.add(n1, 'a', {'id': control.id, href : 'javascript:;', onclick : "return false;", onmousedown : 'return false;'}, control.settings.title);

				Event.add(n2, 'mouseover', (function(div)
				{
					return function()
					{
						DOM.addClass(div, 'mceSplitButtonItemOver');
					};
				})(n1));

				Event.add(n2, 'mouseout', (function(div)
				{
					return function()
					{
						DOM.removeClass(div, 'mceSplitButtonItemOver');
					};
				})(n1));

				Event.add(n2, 'click', (function(control)
				{
					return function(e) {

						var s = control.settings;

						ed.execCommand(s.cmd, s.ui || false, s.value);
						t.hideMenu();

						return Event.cancel(e); // Prevent IE auto save warning
					};
				})(control));
			});

			return w;
		},

		/**
		 * Post render event. This will be executed after the control has been rendered and can be used to
		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, id = t.id;
			t.parent();
		},

		/**
		 * Destroys the control. This means it will be removed from the DOM and any
		 * events tied to it will also be removed.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.parent();

			Event.clear(this.id + '_menu');
			Event.clear(this.id + '_more');
			DOM.remove(this.id + '_menu');
		}
	});
})(tinymce);
/**
 * ColorSplitButton.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;

	tinymce.create('tinymce.ui.ControlsButton:tinymce.ui.SplitButton', {

		ControlsButton : function(id, s) {
			var t = this;

			t.parent(id, s);

			var ed = t.scope.editor;

			/**
			 * Fires when the menu is shown.
			 *
			 * @event onShowMenu
			 */
			t.onShowMenu = new tinymce.util.Dispatcher(t);

			/**
			 * Fires when the menu is hidden.
			 *
			 * @event onHideMenu
			 */
			t.onHideMenu = new tinymce.util.Dispatcher(t);

			s.expandControls = s.expandControls || [];

			t.controlsData = {};

			each(s.controls, function(v) {
				var control = new tinymce.ui.Control(ed.editorId + '_' + v, {
					'cmd': ed.theme.controls[v][1],
					'title': ed.getLang('compose.' + ed.theme.controls[v][0])
				});
				ed.controlManager.add(control);
			});

			ed.onInit.add(function(){

				t.parentTd = DOM.getParent(t.id + '_action', 'td');
				t.toolbar = DOM.getParent(t.id + '_action', '.mceToolbar');
				t.nextToolbar = DOM.getNext(t.toolbar, '.mceToolbar');
				t.parentTd.style.display = '';

				each(s.expandControls, function (v) {
					var cId = ed.editorId + '_' + v;
					var td = DOM.getParent(cId, 'td');
					var separator;
					var prevTd = DOM.getPrev(td, 'td');
					if (prevTd) {
						var nodes = DOM.select('.mceSeparator', prevTd);
						if (nodes[0]) {
							separator = nodes[0];
							separator.style.display = '';
						}
					}
					td.style.display = '';
					t.controlsData[cId] = {
						parent: td,
						separator: separator
					};
				});

				each(s.expandControls, function (v) {
					var cId = ed.editorId + '_' + v;
					var data = t.controlsData[cId];
					data['width'] = data.parent.offsetWidth;
					if (data.separator) {
						data['width'] += data.separator.offsetWidth;
					}
				});

				t.resize();
			});

			tinymce.$(window).resize(function() {
				t.resize();
				if (tinymce.isIE && parseInt(tinymce.$.browser.version) < 8) {
					setTimeout(function() {
						t.resize();
					}, 0);
				}
			});
		},

		/**
		 * Shows the color menu. The color menu is a layer places under the button
		 * and displays a table of colors for the user to pick from.
		 *
		 * @method showMenu
		 */
		showMenu : function() {
			var t = this, r, p, e, p2;

			if (t.isDisabled())
				return;

			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			if (t.isMenuVisible)
				return t.hideMenu();

			e = DOM.get(t.id);
			DOM.show(t.id + '_menu');
			DOM.addClass(e, 'mceSplitButtonSelected');
/*			p2 = DOM.getPos(e);
			DOM.setStyles(t.id + '_menu', {
				left : p2.x,
				top : p2.y + e.clientHeight,
				zIndex : 200000
			});*/
			e = 0;
			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			t.onShowMenu.dispatch(t);

			if (t._focused) {
				t._keyHandler = Event.add(t.id + '_menu', 'keydown', function(e) {
					if (e.keyCode == 27)
						t.hideMenu();
				});

				DOM.select('a', t.id + '_menu')[0].focus(); // Select first link
			}

			t.isMenuVisible = 1;
		},

		/**
		 * Hides the color menu. The optional event parameter is used to check where the event occured so it
		 * doesn't close them menu if it was a event inside the menu.
		 *
		 * @method hideMenu
		 * @param {Event} e Optional event object.
		 */
		hideMenu : function(e) {
			var t = this;

			// Prevent double toogles by canceling the mouse click event to the button
			if (e && e.type == "mousedown" && DOM.getParent(e.target, function(e) {return e.id === t.id + '_action';}))
				return;

			if (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {
				DOM.removeClass(t.id, 'mceSplitButtonSelected');
				Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
				Event.remove(t.id + '_menu', 'keydown', t._keyHandler);
				DOM.hide(t.id + '_menu');
			}

			t.onHideMenu.dispatch(t);

			t.isMenuVisible = 0;
		},

		/**
		 * Renders the menu to the DOM.
		 *
		 * @method renderMenu
		 */
		renderMenu : function() {

			var t = this, m, i = 0, s = t.settings, n, tb, tr, w, ed = t.scope.editor;

			w = DOM.add(DOM.get(t.id + '_action').parentNode, 'div', {id : t.id + '_menu', 'class': s['menu_class'] + ' ' + s['class'], style : 'position:absolute;'});
			m = DOM.add(w, 'div', {'class' : s['class'] + ' mceSplitButtonMenu'});
            m = DOM.add(m, 'div', {'class' : s['class'] + ' mceControlsButtonMenu'});

			each(s.controls.concat(s.expandControls), function(v) {

				var control = ed.controlManager.get(ed.editorId + '_' + v);
				var n1 = DOM.add(m, 'div', {'class': 'mceSplitButtonItem ' + control.settings.cmd, 'id': control.id + '_2'});

				var n2 = DOM.add(n1, 'a', {'id': control.id, 'class': 'mceSplitButtonItemLink', href : 'javascript:;', onclick : "return false;", onmousedown : 'return false;'}, '');

				DOM.add(n2, 'span', {'class': 'mceIcon mce_' + v}, '');
				DOM.add(n2, 'span', {'class': 'mceSplitButtonItemLinkTitle'}, control.settings.title);

				Event.add(n2, 'click', (function(control) {
					return function(e) {
						var s = control.settings;
						ed.execCommand(s.cmd, s.ui || false, s.value);
						t.hideMenu();
						return Event.cancel(e); // Prevent IE auto save warning
					};
				})(control));
			});

			t.resize();

			return w;
		},

		resize: function() {

			var t = this, s = t.settings, ed = t.scope.editor;

			if (!(t.parentTd && t.toolbar && t.nextToolbar)) {
				return;
			}

			t.hideMenu();

			var hasHidden = false;

			each(s.expandControls, function(v){
				var cId = ed.editorId + '_' + v;
				var link = DOM.get(cId + '_2');
				var data = t.controlsData[cId];
				DOM.hide(data.parent);
				DOM.hide(data.separator);
				DOM.show(link);
			});

			each(s.expandControls, function(v, k){
				var cId = ed.editorId + '_' + v;
				var link = DOM.get(cId + '_2');
				var data = t.controlsData[cId];

				if (t.toolbar.offsetWidth + data.width > t.nextToolbar.offsetLeft) {
					hasHidden = true;
				} else {
					data.parent.style.display = '';
					if (data.separator) {
						data.separator.style.display = '';
					}
					DOM.hide(link);
				}
			});

//			if (hasHidden) {
//				t.parentTd.style.display = '';
//			} else {
//				DOM.hide(t.parentTd);
//			}
		},

		/**
		 * Post render event. This will be executed after the control has been rendered and can be used to
		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, id = t.id;
			t.parent();
		},

		/**
		 * Destroys the control. This means it will be removed from the DOM and any
		 * events tied to it will also be removed.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.parent();

			Event.clear(this.id + '_menu');
			Event.clear(this.id + '_more');
			DOM.remove(this.id + '_menu');
		}
	});
})(tinymce);
/**
 * ColorSplitButton.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;

	/**
	 * This class is used to create UI color split button. A color split button will present show a small color picker
	 * when you press the open menu.
	 *
	 * @class tinymce.ui.EmotionsSplitButton
	 * @extends tinymce.ui.SplitButton
	 */
	tinymce.create('tinymce.ui.EmotionsSplitButton:tinymce.ui.SplitButton', {
		/**
		 * Constructs a new color split button control instance.
		 *
		 * @constructor
		 * @method EmotionsSplitButton
		 * @param {String} id Control id for the color split button.
		 * @param {Object} s Optional name/value settings object.
		 */
		EmotionsSplitButton : function(id, s) {

			var t = this;

			t.parent(id, s);

			/**
			 * Fires when the menu is shown.
			 *
			 * @event onShowMenu
			 */
			t.onShowMenu = new tinymce.util.Dispatcher(t);
			t.onChangeTab = new tinymce.util.Dispatcher(t);

			/**
			 * Fires when the menu is hidden.
			 *
			 * @event onHideMenu
			 */
			t.onHideMenu = new tinymce.util.Dispatcher(t);

			var smiles = t.scope.editor.getLang('compose.smiles');

			t.smiles = [
				{
					'title': smiles[0].title,
					'imgPrefix': '//img.mail.ru/ru/btn/kolobki/',
					'list': smiles[0].list
				},
				{
					'title': smiles[1].title,
					'isStatic': true,
					'imgPrefix': '//img.mail.ru/ru/btn/',
					'list': smiles[1].list
				},
				{
					'title': smiles[2].title,
					'imgPrefix': '//img.mail.ru/ru/btn/anim/',
					'list': smiles[2].list
				},
				{
					'title': smiles[3].title,
					'isStatic': true,
					'imgPrefix': '//img.mail.ru/ru/btn/adv/',
					'list': smiles[3].list
				},
				{
					'title': smiles[4].title,
					'imgPrefix': '//img.mail.ru/ru/btn/set04/',
					'list': smiles[4].list
				},
				{
					'title': smiles[5].title,
					'imgPrefix': '//img.mail.ru/ru/btn/set05/',
					'list': smiles[5].list
				},
				{
					'title': smiles[6].title,
					'imgPrefix': '//img.mail.ru/ru/btn/set06/',
					'list': smiles[6].list
				},
				{
					'title': smiles[7].title,
					'isStatic': true,
					'imgPrefix': '//img.' + mailru.staticDomainName + '/mail/ru/images/wysiwyg/hny_icons/',
					'list': smiles[7].list
				}
			];
		},

		/**
		 * Shows the color menu. The color menu is a layer places under the button
		 * and displays a table of colors for the user to pick from.
		 *
		 * @method showMenu
		 */
		showMenu : function() {
			var t = this, r, p, e, p2;

			if (t.isDisabled())
				return;

			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			if (t.isMenuVisible)
				return t.hideMenu();

			e = DOM.get(t.id);
			DOM.show(t.id + '_menu');
			DOM.addClass(e, 'mceSplitButtonSelected');
/*			p2 = DOM.getPos(e);
			DOM.setStyles(t.id + '_menu', {
				left : p2.x,
				top : p2.y + e.clientHeight,
				zIndex : 200000
			});*/
			e = 0;

			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			t.onShowMenu.dispatch(t);

			if (t._focused) {
				t._keyHandler = Event.add(t.id + '_menu', 'keydown', function(e) {
					if (e.keyCode == 27)
						t.hideMenu();
				});

				DOM.select('a', t.id + '_menu')[0].focus(); // Select first link
			}

			t.isMenuVisible = 1;
		},

		/**
		 * Hides the color menu. The optional event parameter is used to check where the event occured so it
		 * doesn't close them menu if it was a event inside the menu.
		 *
		 * @method hideMenu
		 * @param {Event} e Optional event object.
		 */
		hideMenu : function(e) {
			var t = this;

			// Prevent double toogles by canceling the mouse click event to the button
			if (e && e.type == "mousedown" && DOM.getParent(e.target, function(e) {return e.id === t.id + '_action';}))
				return;

			if (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {
				DOM.removeClass(t.id, 'mceSplitButtonSelected');
				Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
				Event.remove(t.id + '_menu', 'keydown', t._keyHandler);
				DOM.hide(t.id + '_menu');
			}

			t.onHideMenu.dispatch(t);

			t.isMenuVisible = 0;
		},

		/**
		 * Renders the menu to the DOM.
		 *
		 * @method renderMenu
		 */
		renderMenu : function() {
			var t = this, m, s = t.settings, n, tb, tr, ed = t.scope.editor;

			var f = null;

			var mainContainer = DOM.add(DOM.get(t.id + '_action').parentNode, 'div', {id : t.id + '_menu', 'class' : s['menu_class'] + ' ' + s['class'], style : 'position:absolute;'});
			var emotionsContainer = DOM.add(mainContainer, 'div', {'class' : 'mceEmotionsContainers'});
			var tabsContainer = DOM.add(mainContainer, 'div', {'class' : 'mceEmotionsTabs'});
			tabsContainer = DOM.add(tabsContainer, 'div', {'class' : 'clearfix'});
			var prevContainer = null;

			for (var i=0, l=t.smiles.length; i<l; i++)
			{
				var data = t.smiles[i];
				var emotionContainer = DOM.add(emotionsContainer, 'div', {'class' : 'mceEmotionsContainer'});
				if (i==0)
					prevContainer = emotionContainer;
				var emotionFrame = DOM.add(emotionContainer, 'div', {'class' : 'mceEmotionsFrame'}, this.getEmotionsHTML(i));
				var cl = DOM.add(emotionContainer, 'div', {'class' : 'clearfix'});
				DOM.add(cl, 'div', {'class' : 'mceEmotionsTab mceEmotionsTab' + i, 'title': data.title});
				var tab = DOM.add(tabsContainer, 'div', {'class' : 'mceEmotionsTab mceEmotionsTab' + i, 'title': data.title});

				if (data.isStatic)
				{
					f = (function(data)
					{
						return function(e)
						{
							var src = '';
							if (e.target.nodeName == 'A')
							{
								var name = e.target.className;

								if (data.imgPrefix == '//img.mail.ru/ru/btn/adv/')
									name = name.replace(/^c([0-9]+)/, '$1');

								src = data.imgPrefix + name + '.gif';
							}

							if (this.insertImage(src))
								this.hideMenu();
						};
					})(data);
				}
				else
				{
					f = function(e)
					{
						var src = '';
						if (e.target.nodeName == 'IMG')
							src = e.target.src;

						if (this.insertImage(src))
							this.hideMenu();
					};
				}

				Event.add(emotionFrame, 'click', f, this);

				Event.add(tab, 'click', (function(container){

					return function(e){

						DOM.addClass(container, 'mceEmotionsContainerActive');
						DOM.removeClass(prevContainer, 'mceEmotionsContainerActive');
						prevContainer = container;

						this.onChangeTab.dispatch(t);

						return Event.cancel(e);
					};
				})(emotionContainer), this);

				Event.add(tab, 'mousedown', function(e) {
					return Event.cancel(e);
				});
			}

			DOM.addClass(prevContainer, 'mceEmotionsContainerActive');

			Event.add(mainContainer, 'mousedown', function(e) {
				return Event.cancel(e);
			});

			Event.add(t.id + '_menu', 'click', function(e) {
				return Event.cancel(e);
			});

			return mainContainer;
		},

		insertImage: function(src)
		{
			var t = this, ed = t.scope.editor;
			if (src)
			{
				ed.execCommand('mceInsertContent', false, DOM.createHTML('img', {
					src : src,
					alt : '',
					title : '',
					border : 0
				}));
				return true;
			}
			return false;
		},

		getEmotionsHTML: function(index)
		{
			var html = '';
			var data = this.smiles[index];

			html += '<div class="s' + index + '">';

			each(data.list, function(title, key){

				if (data.isStatic)
				{
					html += '<a title="' + title + '" class="' + key + '" href="javascript:;" onclick="return false;" onmousedown="return false;"></a>';
				}
				else
				{
					html += '<img title="' + title + '" class="' + key + '" src="' + data.imgPrefix + key + '.gif" alt="" onclick="return false;" onmousedown="return false;"/>';
				}
			});

			html += '</div>';

			return html;
		},

		/**
		 * Post render event. This will be executed after the control has been rendered and can be used to
		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, id = t.id;

			t.parent();
//			DOM.add(id + '_action', 'div', {id : id + '_preview', 'class' : 'mceColorPreview'});
//			DOM.setStyle(t.id + '_preview', 'backgroundColor', t.value);
		},

		/**
		 * Destroys the control. This means it will be removed from the DOM and any
		 * events tied to it will also be removed.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.parent();

			Event.clear(this.id + '_menu');
			Event.clear(this.id + '_more');
			DOM.remove(this.id + '_menu');
		}
	});
})(tinymce);
/**
 * ColorSplitButton.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;

	tinymce.create('tinymce.ui.FontActionButton:tinymce.ui.SplitButton', {

		FontActionButton : function(id, s) {
			var t = this;

			t.parent(id, s);

			/**
			 * Fires when the menu is shown.
			 *
			 * @event onShowMenu
			 */
			t.onShowMenu = new tinymce.util.Dispatcher(t);

			/**
			 * Fires when the menu is hidden.
			 *
			 * @event onHideMenu
			 */
			t.onHideMenu = new tinymce.util.Dispatcher(t);

			each(s.controls, function(control, i) {

				control.onHideMenu.add(function () {
					t.hideMenu();
				});

				control.onShowMenu.add(function(control) {

					var menuContainer = DOM.get('mce_' + control.settings.id + '_container');
					var menu = DOM.get('menu_' + control.id);
					var n = DOM.get('menu_' + control.id + '_co');

					DOM.addClass(menu, 'mce_' + control.settings.id + '_menu');

					var head = DOM.create('div', {'class': 'mceListBoxMenuTitle'}, control.settings.title);
					n.insertBefore(head, n.firstChild);

					DOM.add(menuContainer, menu);

					DOM.addClass(n, 'mceListBoxMenu');

					control.onShowMenu.remove(arguments.callee);
				});
			});

			t.onHideMenu.add(function() {
				each(s.controls, function(control, i) {
					control.hideMenu();
				});
			});

			t.onShowMenu.add(function() {
				each(s.controls, function(control, i) {
					control.showMenu(0, 0);
				});
			});

/*			t.onShowMenu.add(function()
			{
				var mLeft = 0;
				each(s.controls, function(control, i) {
					var menu = DOM.get('menu_' + control.id);
					var co = DOM.get('menu_' + control.id + '_co');
					DOM.setStyle(menu, 'marginLeft', mLeft + 'px');
					mLeft += co.offsetWidth - 1;
				});

				t.onShowMenu.remove(arguments.callee);
			});*/
		},

		/**
		 * Shows the color menu. The color menu is a layer places under the button
		 * and displays a table of colors for the user to pick from.
		 *
		 * @method showMenu
		 */
		showMenu : function() {
			var t = this, s = t.settings, r, p, e, p2;

			if (t.isDisabled())
				return;

			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			if (t.isMenuVisible)
				return t.hideMenu();

			e = DOM.get(t.id);
			DOM.show(t.id + '_menu');



			DOM.addClass(e, 'mceSplitButtonSelected');
/*			p2 = DOM.getPos(e);
			DOM.setStyles(t.id + '_menu', {
				left : p2.x,
				top : p2.y + e.clientHeight,
				zIndex : 200000
			});*/
			e = 0;
			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			t.onShowMenu.dispatch(t);

			if (t._focused) {
				t._keyHandler = Event.add(t.id + '_menu', 'keydown', function(e) {
					if (e.keyCode == 27)
						t.hideMenu();
				});

				DOM.select('a', t.id + '_menu')[0].focus();
			}

			t.isMenuVisible = 1;
		},

		/**
		 * Hides the color menu. The optional event parameter is used to check where the event occured so it
		 * doesn't close them menu if it was a event inside the menu.
		 *
		 * @method hideMenu
		 * @param {Event} e Optional event object.
		 */
		hideMenu : function(e) {
			var t = this, s = t.settings;

			// Prevent double toogles by canceling the mouse click event to the button
			if (e && e.type == "mousedown" && DOM.getParent(e.target, function(e) {return e.id === t.id + '_action';}))
				return;

			if (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {
				DOM.removeClass(t.id, 'mceSplitButtonSelected');
				Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
				Event.remove(t.id + '_menu', 'keydown', t._keyHandler);
				DOM.hide(t.id + '_menu');
			}

			t.onHideMenu.dispatch(t);

			t.isMenuVisible = 0;
		},

		/**
		 * Renders the menu to the DOM.
		 *
		 * @method renderMenu
		 */
		renderMenu : function() {
			var t = this, m, i = 0, s = t.settings, n, tb, tr, w;
			w = DOM.add(DOM.get(t.id + '_action').parentNode, 'div', {id : t.id + '_menu', 'class' : s['menu_class'] + ' ' + s['class'] + '_menu mceSplitButtonMenu', style : 'position:absolute;'}, '<table cellpadding="0" cellspacing="0"><tbody><tr><td id="mce_fontsizeselect_container"></td><td id="mce_fontselect_container"></td></tr></tbody></table>');
			Event.add(w, 'mousedown', Event.stop);
			return w;
		},

		/**
		 * Post render event. This will be executed after the control has been rendered and can be used to
		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, id = t.id;

			t.parent();
		},

		/**
		 * Destroys the control. This means it will be removed from the DOM and any
		 * events tied to it will also be removed.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.parent();

			Event.clear(this.id + '_menu');
			Event.clear(this.id + '_more');
			DOM.remove(this.id + '_menu');
		}
	});
})(tinymce);
/**
 * ColorSplitButton.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;

	tinymce.create('tinymce.ui.CardsButton:tinymce.ui.SplitButton', {

		CardsButton : function(id, s) {
			var t = this;

			t.parent(id, s);

			var ed = t.scope.editor;

			/**
			 * Fires when the menu is shown.
			 *
			 * @event onShowMenu
			 */
			t.onShowMenu = new tinymce.util.Dispatcher(t);

			/**
			 * Fires when the menu is hidden.
			 *
			 * @event onHideMenu
			 */
			t.onHideMenu = new tinymce.util.Dispatcher(t);
		},

		/**
		 * Shows the color menu. The color menu is a layer places under the button
		 * and displays a table of colors for the user to pick from.
		 *
		 * @method showMenu
		 */
		showMenu : function() {
			var t = this, r, p, e, p2;

			if (t.isDisabled())
				return;

			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			if (t.isMenuVisible)
				return t.hideMenu();

			e = DOM.get(t.id);
			DOM.show(t.id + '_menu');
			DOM.addClass(e, 'mceSplitButtonSelected');
			e = 0;
			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			t.onShowMenu.dispatch(t);

			if (t._focused) {
				t._keyHandler = Event.add(t.id + '_menu', 'keydown', function(e) {
					if (e.keyCode == 27)
						t.hideMenu();
				});

				DOM.select('a', t.id + '_menu')[0].focus(); // Select first link
			}

			t.isMenuVisible = 1;
		},

		/**
		 * Hides the color menu. The optional event parameter is used to check where the event occured so it
		 * doesn't close them menu if it was a event inside the menu.
		 *
		 * @method hideMenu
		 * @param {Event} e Optional event object.
		 */
		hideMenu : function(e) {
			var t = this;

			// Prevent double toogles by canceling the mouse click event to the button
			if (e && e.type == "mousedown" && DOM.getParent(e.target, function(e) {return e.id === t.id + '_action';}))
				return;

			if (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {
				DOM.removeClass(t.id, 'mceSplitButtonSelected');
				Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
				Event.remove(t.id + '_menu', 'keydown', t._keyHandler);
				DOM.hide(t.id + '_menu');
			}

			t.onHideMenu.dispatch(t);

			t.isMenuVisible = 0;
		},

		/**
		 * Renders the menu to the DOM.
		 *
		 * @method renderMenu
		 */
		renderMenu : function() {

			var t = this, m, i = 0, s = t.settings, n, tb, tr, w, ed = t.scope.editor;

			w = DOM.add(DOM.get(t.id + '_action').parentNode, 'div', {id : t.id + '_menu', 'class' : 'mceCardsMenu', style : 'position:absolute;'});
			m = DOM.add(w, 'div', {'class' : 'mceSplitButtonMenu'});

			each(mailru.lang['compose_cards'].categories, function(category, k) {
				var item = DOM.add(m, 'div', {'class' : ' mceSplitButtonItem'});
				var link = DOM.add(item, 'a', {'id': 'mce_cards_category' + k, 'class': 'mceSplitButtonItemLink', href : 'javascript:;', onclick : "return false;", onmousedown : 'return false;'}, '');
				DOM.add(link, 'span', {'class': 'mceSplitButtonItemLinkTitle'}, category.title);
			});

			DOM.add(m, 'div', {'class': 'mceSplitButtonItemSeparator'});

			var item = DOM.add(m, 'div', {'class': 'mceSplitButtonItem'});
			var link = DOM.add(item, 'a', {'class': 'mceSplitButtonItemLink mceSplitButtonItemLinkClear', href : 'javascript:;', onclick : "return false;", onmousedown : 'return false;'}, '');
			DOM.add(link, 'span', {'class': 'mceSplitButtonItemLinkTitle'}, ed.getLang('compose.cards_without'));

			Event.add(m, 'click', function(e) {

				var item;
				if (DOM.hasClass(e.target, 'mceSplitButtonItemLink')) {
					item = e.target;
				} else {
					item = DOM.getParent(e.target, function(e) {return DOM.hasClass(e, 'mceSplitButtonItemLink');}, m);
				}

				if (item) {
					if (DOM.hasClass(item, 'mceSplitButtonItemLinkClear')) {
						ed.execCommand('mceClearCards', false);
					} else {
						ed.execCommand('mceSetCardsCategory', false, item.id.replace(/^mce_cards_category/, ''));
					}
				}

				t.hideMenu();
				return Event.cancel(e); // Prevent IE auto save warning
			});

			return w;
		},

		/**
		 * Post render event. This will be executed after the control has been rendered and can be used to
		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, id = t.id;
			t.parent();
		},

		/**
		 * Destroys the control. This means it will be removed from the DOM and any
		 * events tied to it will also be removed.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.parent();

			Event.clear(this.id + '_menu');
			Event.clear(this.id + '_more');
			DOM.remove(this.id + '_menu');
		}
	});
})(tinymce);
/**
 * ColorSplitButton.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;

	tinymce.create('tinymce.ui.DesignButton:tinymce.ui.SplitButton', {

		DesignButton : function(id, s) {
			var t = this;

			t.parent(id, s);

			var ed = t.scope.editor;

			/**
			 * Fires when the menu is shown.
			 *
			 * @event onShowMenu
			 */
			t.onShowMenu = new tinymce.util.Dispatcher(t);

			/**
			 * Fires when the menu is hidden.
			 *
			 * @event onHideMenu
			 */
			t.onHideMenu = new tinymce.util.Dispatcher(t);
		},

		/**
		 * Shows the color menu. The color menu is a layer places under the button
		 * and displays a table of colors for the user to pick from.
		 *
		 * @method showMenu
		 */
		showMenu : function() {
			var t = this, r, p, e, p2;

			if (t.isDisabled())
				return;

			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			if (t.isMenuVisible)
				return t.hideMenu();

			e = DOM.get(t.id);
			DOM.show(t.id + '_menu');
			DOM.addClass(e, 'mceSplitButtonSelected');
			e = 0;
			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			t.onShowMenu.dispatch(t);

			if (t._focused) {
				t._keyHandler = Event.add(t.id + '_menu', 'keydown', function(e) {
					if (e.keyCode == 27)
						t.hideMenu();
				});

				DOM.select('a', t.id + '_menu')[0].focus(); // Select first link
			}

			t.isMenuVisible = 1;
		},

		/**
		 * Hides the color menu. The optional event parameter is used to check where the event occured so it
		 * doesn't close them menu if it was a event inside the menu.
		 *
		 * @method hideMenu
		 * @param {Event} e Optional event object.
		 */
		hideMenu : function(e) {
			var t = this;

			// Prevent double toogles by canceling the mouse click event to the button
			if (e && e.type == "mousedown" && DOM.getParent(e.target, function(e) {return e.id === t.id + '_action';}))
				return;

			if (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {
				DOM.removeClass(t.id, 'mceSplitButtonSelected');
				Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
				Event.remove(t.id + '_menu', 'keydown', t._keyHandler);
				DOM.hide(t.id + '_menu');
			}

			t.onHideMenu.dispatch(t);

			t.isMenuVisible = 0;
		},

		/**
		 * Renders the menu to the DOM.
		 *
		 * @method renderMenu
		 */
		renderMenu : function() {

			var t = this, m, i = 0, s = t.settings, n, tb, tr, w, ed = t.scope.editor;

			w = DOM.add(DOM.get(t.id + '_action').parentNode, 'div', {id : t.id + '_menu', 'class' : 'mceDesignMenu', style : 'position:absolute;'});
			m = DOM.add(w, 'div', {'class' : 'mceSplitButtonMenu'});

			each(mailru.lang['compose_appearance'].categories, function(category, k) {
				var item = DOM.add(m, 'div', {'class' : ' mceSplitButtonItem'});
				var link = DOM.add(item, 'a', {'id': 'mce_design_category' + k, 'class': 'mceSplitButtonItemLink', href : 'javascript:;', onclick : "return false;", onmousedown : 'return false;'}, '');
				DOM.add(link, 'span', {'class': 'mceSplitButtonItemLinkTitle'}, category.title);
			});

			DOM.add(m, 'div', {'class': 'mceSplitButtonItemSeparator'});

			var item = DOM.add(m, 'div', {'class': 'mceSplitButtonItem'});
			var link = DOM.add(item, 'a', {'class': 'mceSplitButtonItemLink mceSplitButtonItemLinkClear', href : 'javascript:;', onclick : "return false;", onmousedown : 'return false;'}, '');
			DOM.add(link, 'span', {'class': 'mceSplitButtonItemLinkTitle'}, ed.getLang('compose.appearance_without_style'));

			Event.add(m, 'click', function(e) {

				var item;
				if (DOM.hasClass(e.target, 'mceSplitButtonItemLink')) {
					item = e.target;
				} else {
					item = DOM.getParent(e.target, function(e) {return DOM.hasClass(e, 'mceSplitButtonItemLink');}, m);
				}

				if (item) {
					if (DOM.hasClass(item, 'mceSplitButtonItemLinkClear')) {
						ed.execCommand('mceClearDesign', false);
					} else {
						ed.execCommand('mceSetDesignCategory', false, item.id.replace(/^mce_design_category/, ''));
					}
				}

				t.hideMenu();
				return Event.cancel(e); // Prevent IE auto save warning
			});

			return w;
		},

		/**
		 * Post render event. This will be executed after the control has been rendered and can be used to
		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, id = t.id;
			t.parent();
		},

		/**
		 * Destroys the control. This means it will be removed from the DOM and any
		 * events tied to it will also be removed.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.parent();

			Event.clear(this.id + '_menu');
			Event.clear(this.id + '_more');
			DOM.remove(this.id + '_menu');
		}
	});
})(tinymce);
/**
 * ColorSplitButton.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;

	tinymce.create('tinymce.ui.SignatureButton:tinymce.ui.SplitButton', {

		SignatureButton : function(id, s) {
			var t = this;

			t.parent(id, s);

			var ed = t.scope.editor;

			/**
			 * Fires when the menu is shown.
			 *
			 * @event onShowMenu
			 */
			t.onShowMenu = new tinymce.util.Dispatcher(t);

			/**
			 * Fires when the menu is hidden.
			 *
			 * @event onHideMenu
			 */
			t.onHideMenu = new tinymce.util.Dispatcher(t);
		},

		/**
		 * Shows the color menu. The color menu is a layer places under the button
		 * and displays a table of colors for the user to pick from.
		 *
		 * @method showMenu
		 */
		showMenu : function() {
			var t = this, r, p, e, p2, ed = t.scope.editor, s = ed.settings;

			if (t.isDisabled())
				return;

			if (!t.isMenuRendered) {
				t.renderMenu();
				t.isMenuRendered = true;
			}

			if (t.isMenuVisible)
				return t.hideMenu();

			e = DOM.get(t.id);
			var menu = DOM.get(t.id + '_menu');
			var toolbarContainer = DOM.getParent(e, function(e) {return DOM.hasClass(e, 'mceExternalToolbar');}, s.theme_compose_toolbar_external_id);
			var toolbar = DOM.getParent(e, function(e) {return DOM.hasClass(e, 'mceToolbar');}, toolbarContainer);

			var offset = toolbarContainer.offsetWidth - toolbar.offsetLeft - e.offsetWidth;

			DOM.setStyle(menu, 'marginRight', -offset + 'px');

			DOM.show(menu);
			DOM.addClass(e, 'mceSplitButtonSelected');
			e = 0;
			Event.add(DOM.doc, 'mousedown', t.hideMenu, t);
			t.onShowMenu.dispatch(t);

			if (t._focused) {
				t._keyHandler = Event.add(t.id + '_menu', 'keydown', function(e) {
					if (e.keyCode == 27)
						t.hideMenu();
				});

				DOM.select('a', t.id + '_menu')[0].focus(); // Select first link
			}

			t.isMenuVisible = 1;
		},

		/**
		 * Hides the color menu. The optional event parameter is used to check where the event occured so it
		 * doesn't close them menu if it was a event inside the menu.
		 *
		 * @method hideMenu
		 * @param {Event} e Optional event object.
		 */
		hideMenu : function(e) {
			var t = this;

			// Prevent double toogles by canceling the mouse click event to the button
			if (e && e.type == "mousedown" && DOM.getParent(e.target, function(e) {return e.id === t.id + '_action';}))
				return;

			if (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {
				DOM.removeClass(t.id, 'mceSplitButtonSelected');
				Event.remove(DOM.doc, 'mousedown', t.hideMenu, t);
				Event.remove(t.id + '_menu', 'keydown', t._keyHandler);
				DOM.hide(t.id + '_menu');
			}

			t.onHideMenu.dispatch(t);

			t.isMenuVisible = 0;
		},

		/**
		 * Renders the menu to the DOM.
		 *
		 * @method renderMenu
		 */
		renderMenu : function() {

			var t = this, m, i = 0, s = t.settings, n, tb, tr, w, ed = t.scope.editor;

			w = DOM.add(DOM.get(t.id + '_action').parentNode, 'div', {id : t.id + '_menu', 'class' : 'mceSignatureMenu', style : 'position:absolute;'});
			m = DOM.add(w, 'div', {'class' : 'mceSplitButtonMenu'});

			var first = true;

			each(ed.settings.real_names, function(v, k) {

				var item;

				if (first) {
					first = false;
				} else {
					DOM.add(m, 'div', {'class' : 'mceSplitButtonMenuSeparator'});
				}

				if (v.selected) {
					t.prevSelectedItem = item = DOM.add(m, 'div', {'id': 'mce_signature_' + v.id, 'class' : 'mceSplitButtonItem mceSignatureSplitButtonItemSelected'});
				} else {
					item = DOM.add(m, 'div', {'id': 'mce_signature_' + v.id, 'class' : 'mceSplitButtonItem'});
				}

				var signature = v.signature;
				signature = signature.replace(/^[^\w0-9-]+/i, '').replace(/\n/g, '<br/>');

				var link = DOM.add(item, 'a', {'class': 'mceSplitButtonItemLink', href : 'javascript:;', onclick : "return false;", onmousedown : 'return false;'});
				DOM.add(link, 'span', {'class': 'mceSignatureSplitButtonItemWrap'}, signature);
			});

			// mail-11117 add link to settings
			var item, text;
			if (first) {
				first = false;
				text = ed.translate('compose.signature_addsign');
			} else {
				DOM.add(m, 'div', {'class' : 'mceSplitButtonMenuSeparator'});
				text = ed.translate('compose.signature_editsign');
			}
			item = DOM.add(m, 'div', {'class' : 'mceSplitButtonItem'});
			DOM.add(item, 'a', {'class': 'mceSplitButtonItemLink mceSplitButtonItemLinkAway', target : '_blank', href : '/settings/signature'}, text);

			var idRegExp = /^mce_signature_(\d+)/;

			Event.add(m, 'click', function(e) {

				var item, id = null;

				if (DOM.hasClass(e.target, 'mceSplitButtonItem')) {
					item = e.target;
				} else {
					item = DOM.getParent(e.target, function(e) {return DOM.hasClass(e, 'mceSplitButtonItem');}, m);
				}

				if (item && item.id && idRegExp.test(item.id)) {
					id = item.id.match(idRegExp)[1];
				}

				t.hideMenu();

				if (id !== null) {
					t.setActiveRealName(id);
					ed.execCommand('mceSetSignature', false, id);
					return Event.cancel(e); // Prevent IE auto save warning
				}
			});

			return w;
		},

		setActiveRealName: function (id) {
			var t = this;
			var item = DOM.get('mce_signature_' + id);
			if (t.prevSelectedItem) { //mail-11117 there might be id without signature, so item is null but we have to deselect prev item
				DOM.removeClass(t.prevSelectedItem, 'mceSignatureSplitButtonItemSelected');
			}
			if (item) {
				t.prevSelectedItem = item;
				DOM.addClass(item, 'mceSignatureSplitButtonItemSelected');
			}
			else { // menu is not rendered yet, so we must change the initial settings for it
				var ed = t.scope.editor;
				each(ed.settings.real_names, function(v, k) {
					v.selected = (v.id == id);
				});
			}
		},

		/**
		 * Post render event. This will be executed after the control has been rendered and can be used to
		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().
		 *
		 * @method postRender
		 */
		postRender : function() {
			var t = this, id = t.id;
			t.parent();
		},


		/**
		 * Destroys the control. This means it will be removed from the DOM and any
		 * events tied to it will also be removed.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.parent();

			Event.clear(this.id + '_menu');
			Event.clear(this.id + '_more');
			DOM.remove(this.id + '_menu');
		}
	});
})(tinymce);
/**
 * AddOnManager.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var Dispatcher = tinymce.util.Dispatcher, each = tinymce.each;

	/**
	 * This class handles the loading of themes/plugins or other add-ons and their language packs.
	 *
	 * @class tinymce.AddOnManager
	 */
	tinymce.create('tinymce.AddOnManager', {
		AddOnManager : function() {
			var self = this;

			self.items = [];
			self.urls = {};
			self.lookup = {};
			self.onAdd = new Dispatcher(self);
		},

		/**
		 * Fires when a item is added.
		 *
		 * @event onAdd
		 */

		/**
		 * Returns the specified add on by the short name.
		 *
		 * @method get
		 * @param {String} n Add-on to look for.
		 * @return {tinymce.Theme/tinymce.Plugin} Theme or plugin add-on instance or undefined.
		 */
		get : function(n) {
			if (this.lookup[n]) {
				return this.lookup[n].instance;
			} else {
				return undefined;
			}
		},

		dependencies : function(n) {
			var result;
			if (this.lookup[n]) {
				result = this.lookup[n].dependencies;
			}
			return result || [];
		},

		/**
		 * Loads a language pack for the specified add-on.
		 *
		 * @method requireLangPack
		 * @param {String} n Short name of the add-on.
		 */
		requireLangPack : function(n) {
			var s = tinymce.settings;

			if (s && s.language && s.language_load !== false)
				tinymce.ScriptLoader.add(this.urls[n] + '/langs/' + s.language + '.js');
		},

		/**
		 * Adds a instance of the add-on by it's short name.
		 *
		 * @method add
		 * @param {String} id Short name/id for the add-on.
		 * @param {tinymce.Theme/tinymce.Plugin} o Theme or plugin to add.
		 * @return {tinymce.Theme/tinymce.Plugin} The same theme or plugin instance that got passed in.
		 * @example
		 * // Create a simple plugin
		 * tinymce.create('tinymce.plugins.TestPlugin', {
		 *     TestPlugin : function(ed, url) {
		 *         ed.onClick.add(function(ed, e) {
		 *             ed.windowManager.alert('Hello World!');
		 *         });
		 *     }
		 * });
		 *
		 * // Register plugin using the add method
		 * tinymce.PluginManager.add('test', tinymce.plugins.TestPlugin);
		 *
		 * // Initialize TinyMCE
		 * tinyMCE.init({
		 *    ...
		 *    plugins : '-test' // Init the plugin but don't try to load it
		 * });
		 */
		add : function(id, o, dependencies) {
			this.items.push(o);
			this.lookup[id] = {instance:o, dependencies:dependencies};
			this.onAdd.dispatch(this, id, o);

			return o;
		},
		createUrl: function(baseUrl, dep) {
			if (typeof dep === "object") {
				return dep
			} else {
				return {prefix: baseUrl.prefix, resource: dep, suffix: baseUrl.suffix};
			}
		},

		/**
	 	 * Add a set of components that will make up the add-on. Using the url of the add-on name as the base url.
		 * This should be used in development mode.  A new compressor/javascript munger process will ensure that the
		 * components are put together into the editor_plugin.js file and compressed correctly.
		 * @param pluginName {String} name of the plugin to load scripts from (will be used to get the base url for the plugins).
		 * @param scripts {Array} Array containing the names of the scripts to load.
	 	 */
		addComponents: function(pluginName, scripts) {
			var pluginUrl = this.urls[pluginName];
			tinymce.each(scripts, function(script){
				tinymce.ScriptLoader.add(pluginUrl+"/"+script);
			});
		},

		/**
		 * Loads an add-on from a specific url.
		 *
		 * @method load
		 * @param {String} n Short name of the add-on that gets loaded.
		 * @param {String} u URL to the add-on that will get loaded.
		 * @param {function} cb Optional callback to execute ones the add-on is loaded.
		 * @param {Object} s Optional scope to execute the callback in.
		 * @example
		 * // Loads a plugin from an external URL
		 * tinymce.PluginManager.load('myplugin', '/some/dir/someplugin/editor_plugin.js');
		 *
		 * // Initialize TinyMCE
		 * tinyMCE.init({
		 *    ...
		 *    plugins : '-myplugin' // Don't try to load it again
		 * });
		 */
		load : function(n, u, cb, s) {
			var t = this, url = u;

			function loadDependencies() {
				var dependencies = t.dependencies(n);
				tinymce.each(dependencies, function(dep) {
					var newUrl = t.createUrl(u, dep);
					t.load(newUrl.resource, newUrl, undefined, undefined);
				});
				if (cb) {
					if (s) {
						cb.call(s);
					} else {
						cb.call(tinymce.ScriptLoader);
					}
				}
			}

			if (t.urls[n])
				return;
			if (typeof u === "object")
				url = u.prefix + u.resource + u.suffix;

			if (url.indexOf('/') != 0 && url.indexOf('://') == -1)
				url = tinymce.baseURL + '/' + url;

			t.urls[n] = url.substring(0, url.lastIndexOf('/'));

			if (t.lookup[n]) {
				loadDependencies();
			} else {
				tinymce.ScriptLoader.add(url, loadDependencies, s);
			}
		}
	});

	// Create plugin and theme managers
	tinymce.PluginManager = new tinymce.AddOnManager();
	tinymce.ThemeManager = new tinymce.AddOnManager();
}(tinymce));

/**
 * TinyMCE theme class.
 *
 * @class tinymce.Theme
 */

/**
 * Initializes the theme.
 *
 * @method init
 * @param {tinymce.Editor} editor Editor instance that created the theme instance.
 * @param {String} url Absolute URL where the theme is located.
 */

/**
 * Meta info method, this method gets executed when TinyMCE wants to present information about the theme for example in the about/help dialog.
 *
 * @method getInfo
 * @return {Object} Returns an object with meta information about the theme the current items are longname, author, authorurl, infourl and version.
 */

/**
 * This method is responsible for rendering/generating the overall user interface with toolbars, buttons, iframe containers etc.
 *
 * @method renderUI
 * @param {Object} obj Object parameter containing the targetNode DOM node that will be replaced visually with an editor instance.
 * @return {Object} an object with items like iframeContainer, editorContainer, sizeContainer, deltaWidth, deltaHeight.
 */

/**
 * Plugin base class, this is a pseudo class that describes how a plugin is to be created for TinyMCE. The methods below are all optional.
 *
 * @class tinymce.Plugin
 * @example
 * // Create a new plugin class
 * tinymce.create('tinymce.plugins.ExamplePlugin', {
 *     init : function(ed, url) {
 *         // Register an example button
 *         ed.addButton('example', {
 *             title : 'example.desc',
 *             onclick : function() {
 *                  // Display an alert when the user clicks the button
 *                  ed.windowManager.alert('Hello world!');
 *             },
 *             'class' : 'bold' // Use the bold icon from the theme
 *         });
 *     }
 * });
 *
 * // Register plugin with a short name
 * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);
 *
 * // Initialize TinyMCE with the new plugin and button
 * tinyMCE.init({
 *    ...
 *    plugins : '-example', // - means TinyMCE will not try to load it
 *    theme_advanced_buttons1 : 'example' // Add the new example button to the toolbar
 * });
 */

/**
 * Initialization function for the plugin. This will be called when the plugin is created.
 *
 * @method init
 * @param {tinymce.Editor} editor Editor instance that created the plugin instance.
 * @param {String} url Absolute URL where the plugin is located.
 * @example
 * // Creates a new plugin class
 * tinymce.create('tinymce.plugins.ExamplePlugin', {
 *     init : function(ed, url) {
 *         // Register the command so that it can be invoked by using tinyMCE.activeEditor.execCommand('mceExample');
 *         ed.addCommand('mceExample', function() {
 *             ed.windowManager.open({
 *                 file : url + '/dialog.htm',
 *                 width : 320 + ed.getLang('example.delta_width', 0),
 *                 height : 120 + ed.getLang('example.delta_height', 0),
 *                 inline : 1
 *             }, {
 *                 plugin_url : url, // Plugin absolute URL
 *                 some_custom_arg : 'custom arg' // Custom argument
 *             });
 *         });
 *
 *         // Register example button
 *         ed.addButton('example', {
 *             title : 'example.desc',
 *             cmd : 'mceExample',
 *             image : url + '/img/example.gif'
 *         });
 *
 *         // Add a node change handler, selects the button in the UI when a image is selected
 *         ed.onNodeChange.add(function(ed, cm, n) {
 *             cm.setActive('example', n.nodeName == 'IMG');
 *         });
 *     }
 * });
 *
 * // Register plugin
 * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);
 */

/**
 * Meta info method, this method gets executed when TinyMCE wants to present information about the plugin for example in the about/help dialog.
 *
 * @method getInfo
 * @return {Object} Returns an object with meta information about the plugin the current items are longname, author, authorurl, infourl and version.
 * @example
 * // Creates a new plugin class
 * tinymce.create('tinymce.plugins.ExamplePlugin', {
 *     // Meta info method
 *     getInfo : function() {
 *         return {
 *             longname : 'Example plugin',
 *             author : 'Some author',
 *             authorurl : 'http://tinymce.moxiecode.com',
 *             infourl : 'http://wiki.moxiecode.com/index.php/TinyMCE:Plugins/example',
 *             version : "1.0"
 *         };
 *     }
 * });
 *
 * // Register plugin
 * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);
 *
 * // Initialize TinyMCE with the new plugin
 * tinyMCE.init({
 *    ...
 *    plugins : '-example' // - means TinyMCE will not try to load it
 * });
 */

/**
 * Gets called when a new control instance is created.
 *
 * @method createControl
 * @param {String} name Control name to create for example "mylistbox"
 * @param {tinymce.ControlManager} controlman Control manager/factory to use to create the control.
 * @return {tinymce.ui.Control} Returns a new control instance or null.
 * @example
 * // Creates a new plugin class
 * tinymce.create('tinymce.plugins.ExamplePlugin', {
 *     createControl: function(n, cm) {
 *         switch (n) {
 *             case 'mylistbox':
 *                 var mlb = cm.createListBox('mylistbox', {
 *                      title : 'My list box',
 *                      onselect : function(v) {
 *                          tinyMCE.activeEditor.windowManager.alert('Value selected:' + v);
 *                      }
 *                 });
 *
 *                 // Add some values to the list box
 *                 mlb.add('Some item 1', 'val1');
 *                 mlb.add('some item 2', 'val2');
 *                 mlb.add('some item 3', 'val3');
 *
 *                 // Return the new listbox instance
 *                 return mlb;
 *         }
 *
 *         return null;
 *     }
 * });
 *
 * // Register plugin
 * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);
 *
 * // Initialize TinyMCE with the new plugin and button
 * tinyMCE.init({
 *    ...
 *    plugins : '-example', // - means TinyMCE will not try to load it
 *    theme_advanced_buttons1 : 'mylistbox' // Add the new mylistbox control to the toolbar
 * });
 */
/**
 * EditorManager.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	/**
	 * @class tinymce
	 */

	// Shorten names
	var each = tinymce.each, extend = tinymce.extend,
		DOM = tinymce.DOM, Event = tinymce.dom.Event,
		ThemeManager = tinymce.ThemeManager, PluginManager = tinymce.PluginManager,
		explode = tinymce.explode,
		Dispatcher = tinymce.util.Dispatcher, undefined, instanceCounter = 0;

	// Setup some URLs where the editor API is located and where the document is
	tinymce.documentBaseURL = window.location.href.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
	if (!/[\/\\]$/.test(tinymce.documentBaseURL))
		tinymce.documentBaseURL += '/';

	tinymce.baseURL = new tinymce.util.URI(tinymce.documentBaseURL).toAbsolute(tinymce.baseURL);

	/**
	 * Absolute baseURI for the installation path of TinyMCE.
	 *
	 * @property baseURI
	 * @type tinymce.util.URI
	 */
	tinymce.baseURI = new tinymce.util.URI(tinymce.baseURL);

	// Add before unload listener
	// This was required since IE was leaking memory if you added and removed beforeunload listeners
	// with attachEvent/detatchEvent so this only adds one listener and instances can the attach to the onBeforeUnload event
	tinymce.onBeforeUnload = new Dispatcher(tinymce);

	// Must be on window or IE will leak if the editor is placed in frame or iframe
	Event.add(window, 'beforeunload', function(e) {
		tinymce.onBeforeUnload.dispatch(tinymce, e);
	});

	/**
	 * Fires when a new editor instance is added to the tinymce collection.
	 *
	 * @event onAddEditor
	 * @param {tinymce} sender TinyMCE root class/namespace.
	 * @param {tinymce.Editor} editor Editor instance.
	 * @example
	 * tinyMCE.execCommand("mceAddControl", false, "some_textarea");
	 * tinyMCE.onAddEditor.add(function(mgr,ed) {
	 *     console.debug('A new editor is available' + ed.id);
	 * });
	 */
	tinymce.onAddEditor = new Dispatcher(tinymce);

	/**
	 * Fires when an editor instance is removed from the tinymce collection.
	 *
	 * @event onRemoveEditor
	 * @param {tinymce} sender TinyMCE root class/namespace.
	 * @param {tinymce.Editor} editor Editor instance.
	 */
	tinymce.onRemoveEditor = new Dispatcher(tinymce);

	tinymce.EditorManager = extend(tinymce, {
		/**
		 * Collection of editor instances.
		 *
		 * @property editors
		 * @type Object
		 * @example
		 * for (edId in tinyMCE.editors)
		 *     tinyMCE.editors[edId].save();
		 */
		editors : [],

		/**
		 * Collection of language pack data.
		 *
		 * @property i18n
		 * @type Object
		 */
		i18n : {},

		/**
		 * Currently active editor instance.
		 *
		 * @property activeEditor
		 * @type tinymce.Editor
		 * @example
		 * tinyMCE.activeEditor.selection.getContent();
		 * tinymce.EditorManager.activeEditor.selection.getContent();
		 */
		activeEditor : null,

		/**
		 * Initializes a set of editors. This method will create a bunch of editors based in the input.
		 *
		 * @method init
		 * @param {Object} s Settings object to be passed to each editor instance.
		 * @example
		 * // Initializes a editor using the longer method
		 * tinymce.EditorManager.init({
		 *    some_settings : 'some value'
		 * });
		 *
		 * // Initializes a editor instance using the shorter version
		 * tinyMCE.init({
		 *    some_settings : 'some value'
		 * });
		 */
		init : function(s) {
			var t = this, pl, sl = tinymce.ScriptLoader, e, el = [], ed;

			function execCallback(se, n, s) {
				var f = se[n];

				if (!f)
					return;

				if (tinymce.is(f, 'string')) {
					s = f.replace(/\.\w+$/, '');
					s = s ? tinymce.resolve(s) : 0;
					f = tinymce.resolve(f);
				}

				return f.apply(s || this, Array.prototype.slice.call(arguments, 2));
			};

			s = extend({
				theme : "simple",
				language : "en"
			}, s);

			t.settings = s;

			// Legacy call
			Event.add(document, 'init', function() {
				var l, co;

				execCallback(s, 'onpageload');

				switch (s.mode) {
					case "exact":
						l = s.elements || '';

						if(l.length > 0) {
							each(explode(l), function(v) {
								if (DOM.get(v)) {
									ed = new tinymce.Editor(v, s);
									el.push(ed);
									ed.render(1);
								} else {
									each(document.forms, function(f) {
										each(f.elements, function(e) {
											if (e.name === v) {
												v = 'mce_editor_' + instanceCounter++;
												DOM.setAttrib(e, 'id', v);

												ed = new tinymce.Editor(v, s);
												el.push(ed);
												ed.render(1);
											}
										});
									});
								}
							});
						}
						break;

					case "textareas":
					case "specific_textareas":
						function hasClass(n, c) {
							return c.constructor === RegExp ? c.test(n.className) : DOM.hasClass(n, c);
						};

						each(DOM.select('textarea'), function(v) {
							if (s.editor_deselector && hasClass(v, s.editor_deselector))
								return;

							if (!s.editor_selector || hasClass(v, s.editor_selector)) {
								// Can we use the name
								e = DOM.get(v.name);
								if (!v.id && !e)
									v.id = v.name;

								// Generate unique name if missing or already exists
								if (!v.id || t.get(v.id))
									v.id = DOM.uniqueId();

								ed = new tinymce.Editor(v.id, s);
								el.push(ed);
								ed.render(1);
							}
						});
						break;
				}

				// Call onInit when all editors are initialized
				if (s.oninit) {
					l = co = 0;

					each(el, function(ed) {
						co++;

						if (!ed.initialized) {
							// Wait for it
							ed.onInit.add(function() {
								l++;

								// All done
								if (l == co)
									execCallback(s, 'oninit');
							});
						} else
							l++;

						// All done
						if (l == co)
							execCallback(s, 'oninit');
					});
				}
			});
		},

		/**
		 * Returns a editor instance by id.
		 *
		 * @method get
		 * @param {String/Number} id Editor instance id or index to return.
		 * @return {tinymce.Editor} Editor instance to return.
		 * @example
		 * // Adds an onclick event to an editor by id (shorter version)
		 * tinyMCE.get('mytextbox').onClick.add(function(ed, e) {
		 *    ed.windowManager.alert('Hello world!');
		 * });
		 *
		 * // Adds an onclick event to an editor by id (longer version)
		 * tinymce.EditorManager.get('mytextbox').onClick.add(function(ed, e) {
		 *    ed.windowManager.alert('Hello world!');
		 * });
		 */
		get : function(id) {
			if (id === undefined)
				return this.editors;

			return this.editors[id];
		},

		/**
		 * Returns a editor instance by id. This method was added for compatibility with the 2.x branch.
		 *
		 * @method getInstanceById
		 * @param {String} id Editor instance id to return.
		 * @return {tinymce.Editor} Editor instance to return.
		 * @deprecated Use get method instead.
		 * @see #get
		 */
		getInstanceById : function(id) {
			return this.get(id);
		},

		/**
		 * Adds an editor instance to the editor collection. This will also set it as the active editor.
		 *
		 * @method add
		 * @param {tinymce.Editor} editor Editor instance to add to the collection.
		 * @return {tinymce.Editor} The same instance that got passed in.
		 */
		add : function(editor) {
			var self = this, editors = self.editors;

			// Add named and index editor instance
			editors[editor.id] = editor;
			editors.push(editor);

			self._setActive(editor);
			self.onAddEditor.dispatch(self, editor);

			// #ifdef jquery

			// Patch the tinymce.Editor instance with jQuery adapter logic
			if (tinymce.adapter)
				tinymce.adapter.patchEditor(editor);

			// #endif

			return editor;
		},

		/**
		 * Removes a editor instance from the collection.
		 *
		 * @method remove
		 * @param {tinymce.Editor} e Editor instance to remove.
		 * @return {tinymce.Editor} The editor that got passed in will be return if it was found otherwise null.
		 */
		remove : function(editor) {
			var t = this, i, editors = t.editors;

			// Not in the collection
			if (!editors[editor.id])
				return null;

			delete editors[editor.id];

			for (i = 0; i < editors.length; i++) {
				if (editors[i] == editor) {
					editors.splice(i, 1);
					break;
				}
			}

			// Select another editor since the active one was removed
			if (t.activeEditor == editor)
				t._setActive(editors[0]);

			editor.destroy();
			t.onRemoveEditor.dispatch(t, editor);

			return editor;
		},

		/**
		 * Executes a specific command on the currently active editor.
		 *
		 * @method execCommand
		 * @param {String} c Command to perform for example Bold.
		 * @param {Boolean} u Optional boolean state if a UI should be presented for the command or not.
		 * @param {String} v Optional value parameter like for example an URL to a link.
		 * @return {Boolean} true/false if the command was executed or not.
		 */
		execCommand : function(c, u, v) {
			var t = this, ed = t.get(v), w;

			// Manager commands
			switch (c) {
				case "mceFocus":
					ed.focus();
					return true;

				case "mceAddEditor":
				case "mceAddControl":
					if (!t.get(v))
						new tinymce.Editor(v, t.settings).render();

					return true;

				case "mceAddFrameControl":
					w = v.window;

					// Add tinyMCE global instance and tinymce namespace to specified window
					w.tinyMCE = tinyMCE;
					w.tinymce = tinymce;

					tinymce.DOM.doc = w.document;
					tinymce.DOM.win = w;

					ed = new tinymce.Editor(v.element_id, v);
					ed.render();

					// Fix IE memory leaks
					if (tinymce.isIE) {
						function clr() {
							ed.destroy();
							w.detachEvent('onunload', clr);
							w = w.tinyMCE = w.tinymce = null; // IE leak
						};

						w.attachEvent('onunload', clr);
					}

					v.page_window = null;

					return true;

				case "mceRemoveEditor":
				case "mceRemoveControl":
					if (ed)
						ed.remove();

					return true;

				case 'mceToggleEditor':
					if (!ed) {
						t.execCommand('mceAddControl', 0, v);
						return true;
					}

					if (ed.isHidden())
						ed.show();
					else
						ed.hide();

					return true;
			}

			// Run command on active editor
			if (t.activeEditor)
				return t.activeEditor.execCommand(c, u, v);

			return false;
		},

		/**
		 * Executes a command on a specific editor by id. This method was added for compatibility with the 2.x branch.
		 *
		 * @deprecated Use the execCommand method of a editor instance instead.
		 * @method execInstanceCommand
		 * @param {String} id Editor id to perform the command on.
		 * @param {String} c Command to perform for example Bold.
		 * @param {Boolean} u Optional boolean state if a UI should be presented for the command or not.
		 * @param {String} v Optional value parameter like for example an URL to a link.
		 * @return {Boolean} true/false if the command was executed or not.
		 */
		execInstanceCommand : function(id, c, u, v) {
			var ed = this.get(id);

			if (ed)
				return ed.execCommand(c, u, v);

			return false;
		},

		/**
		 * Calls the save method on all editor instances in the collection. This can be useful when a form is to be submitted.
		 *
		 * @method triggerSave
		 * @example
		 * // Saves all contents
		 * tinyMCE.triggerSave();
		 */
		triggerSave : function() {
			each(this.editors, function(e) {
				e.save();
			});
		},

		/**
		 * Adds a language pack, this gets called by the loaded language files like en.js.
		 *
		 * @method addI18n
		 * @param {String} p Prefix for the language items. For example en.myplugin
		 * @param {Object} o Name/Value collection with items to add to the language group.
		 */
		addI18n : function(p, o) {
			var lo, i18n = this.i18n;

			if (!tinymce.is(p, 'string')) {
				each(p, function(o, lc) {
					each(o, function(o, g) {
						each(o, function(o, k) {
							if (g === 'common')
								i18n[lc + '.' + k] = o;
							else
								i18n[lc + '.' + g + '.' + k] = o;
						});
					});
				});
			} else {
				each(o, function(o, k) {
					i18n[p + '.' + k] = o;
				});
			}
		},

		// Private methods

		_setActive : function(editor) {
			this.selectedInstance = this.activeEditor = editor;
		}
	});
})(tinymce);

/**
 * Alternative name for tinymce added for 2.x compatibility.
 *
 * @member
 * @property tinyMCE
 * @type tinymce
 * @example
 * // To initialize editor instances
 * tinyMCE.init({
 *    ...
 * });
 */

/**
 * Alternative name for tinymce added for compatibility.
 *
 * @member tinymce
 * @property EditorManager
 * @type tinymce
 * @example
 * // To initialize editor instances
 * tinymce.EditorManager.get('editor');
 */
/**
 * Editor.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	// Shorten these names
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, extend = tinymce.extend,
		Dispatcher = tinymce.util.Dispatcher, each = tinymce.each, isGecko = tinymce.isGecko,
		isIE = tinymce.isIE, isWebKit = tinymce.isWebKit, is = tinymce.is,
		ThemeManager = tinymce.ThemeManager, PluginManager = tinymce.PluginManager,
		inArray = tinymce.inArray, grep = tinymce.grep, explode = tinymce.explode;

	/**
	 * This class contains the core logic for a TinyMCE editor.
	 *
	 * @class tinymce.Editor
	 * @example
	 * // Add a class to all paragraphs in the editor.
	 * tinyMCE.activeEditor.dom.addClass(tinyMCE.activeEditor.dom.select('p'), 'someclass');
	 *
	 * // Gets the current editors selection as text
	 * tinyMCE.activeEditor.selection.getContent({format : 'text'});
	 *
	 * // Creates a new editor instance
	 * var ed = new tinymce.Editor('textareaid', {
	 *     some_setting : 1
	 * });
	 *
	 * // Select each item the user clicks on
	 * ed.onClick.add(function(ed, e) {
	 *     ed.selection.select(e.target);
	 * });
	 *
	 * ed.render();
	 */
	tinymce.create('tinymce.Editor', {
		/**
		 * Constructs a editor instance by id.
		 *
		 * @constructor
		 * @method Editor
		 * @param {String} id Unique id for the editor.
		 * @param {Object} s Optional settings string for the editor.
		 * @author Moxiecode
		 */
		Editor : function(id, s) {
			var t = this;

			/**
			 * Editor instance id, normally the same as the div/textarea that was replaced.
			 *
			 * @property id
			 * @type String
			 */
			t.id = t.editorId = id;

			t.execCommands = {};
			t.queryStateCommands = {};
			t.queryValueCommands = {};

			/**
			 * State to force the editor to return false on a isDirty call.
			 *
			 * @property isNotDirty
			 * @type Boolean
			 * @example
			 * function ajaxSave() {
			 *     var ed = tinyMCE.get('elm1');
			 *
			 *     // Save contents using some XHR call
			 *     alert(ed.getContent());
			 *
			 *     ed.isNotDirty = 1; // Force not dirty state
			 * }
			 */
			t.isNotDirty = false;

			/**
			 * Name/Value object containting plugin instances.
			 *
			 * @property plugins
			 * @type Object
			 * @example
			 * // Execute a method inside a plugin directly
			 * tinyMCE.activeEditor.plugins.someplugin.someMethod();
			 */
			t.plugins = {};

			// Add events to the editor
			each([
				/**
				 * Fires before the initialization of the editor.
				 *
				 * @event onPreInit
				 * @param {tinymce.Editor} sender Editor instance.
				 * @see #onInit
				 * @example
				 * // Adds an observer to the onPreInit event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onPreInit.add(function(ed) {
				 *           console.debug('PreInit: ' + ed.id);
				 *       });
				 *    }
				 * });
				 */
				'onPreInit',

				/**
				 * Fires before the initialization of the editor.
				 *
				 * @event onBeforeRenderUI
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onBeforeRenderUI event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
 				 *      ed.onBeforeRenderUI.add(function(ed, cm) {
 				 *          console.debug('Before render: ' + ed.id);
 				 *      });
				 *    }
				 * });
				 */
				'onBeforeRenderUI',

				/**
				 * Fires after the rendering has completed.
				 *
				 * @event onPostRender
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onPostRender event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onPostRender.add(function(ed, cm) {
				 *           console.debug('After render: ' + ed.id);
				 *       });
				 *    }
				 * });
				 */
				'onPostRender',

				/**
				 * Fires after the initialization of the editor is done.
				 *
				 * @event onInit
				 * @param {tinymce.Editor} sender Editor instance.
				 * @see #onPreInit
				 * @example
				 * // Adds an observer to the onInit event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onInit.add(function(ed) {
				 *           console.debug('Editor is done: ' + ed.id);
				 *       });
				 *    }
				 * });
				 */
				'onInit',

				/**
				 * Fires when the editor instance is removed from page.
				 *
				 * @event onRemove
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onRemove event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onRemove.add(function(ed) {
				 *           console.debug('Editor was removed: ' + ed.id);
				 *       });
				 *    }
				 * });
				 */
				'onRemove',

				/**
				 * Fires when the editor is activated.
				 *
				 * @event onActivate
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onActivate event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onActivate.add(function(ed) {
				 *           console.debug('Editor was activated: ' + ed.id);
				 *       });
				 *    }
				 * });
				 */
				'onActivate',

				/**
				 * Fires when the editor is deactivated.
				 *
				 * @event onDeactivate
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onDeactivate event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onDeactivate.add(function(ed) {
				 *           console.debug('Editor was deactivated: ' + ed.id);
				 *       });
				 *    }
				 * });
				 */
				'onDeactivate',

				/**
				 * Fires when something in the body of the editor is clicked.
				 *
				 * @event onClick
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onClick event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onClick.add(function(ed, e) {
				 *           console.debug('Editor was clicked: ' + e.target.nodeName);
				 *       });
				 *    }
				 * });
				 */
				'onClick',

				/**
				 * Fires when a registered event is intercepted.
				 *
				 * @event onEvent
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onEvent event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onEvent.add(function(ed, e) {
 				 *          console.debug('Editor event occured: ' + e.target.nodeName);
				 *       });
				 *    }
				 * });
				 */
				'onEvent',

				/**
				 * Fires when a mouseup event is intercepted inside the editor.
				 *
				 * @event onMouseUp
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onMouseUp event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onMouseUp.add(function(ed, e) {
				 *           console.debug('Mouse up event: ' + e.target.nodeName);
				 *       });
				 *    }
				 * });
				 */
				'onMouseUp',

				/**
				 * Fires when a mousedown event is intercepted inside the editor.
				 *
				 * @event onMouseDown
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onMouseDown event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onMouseDown.add(function(ed, e) {
				 *           console.debug('Mouse down event: ' + e.target.nodeName);
				 *       });
				 *    }
				 * });
				 */
				'onMouseDown',

				/**
				 * Fires when a dblclick event is intercepted inside the editor.
				 *
				 * @event onDblClick
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onDblClick event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onDblClick.add(function(ed, e) {
 				 *          console.debug('Double click event: ' + e.target.nodeName);
				 *       });
				 *    }
				 * });
				 */
				'onDblClick',

				/**
				 * Fires when a keydown event is intercepted inside the editor.
				 *
				 * @event onKeyDown
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onKeyDown event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onKeyDown.add(function(ed, e) {
				 *           console.debug('Key down event: ' + e.keyCode);
				 *       });
				 *    }
				 * });
				 */
				'onKeyDown',

				/**
				 * Fires when a keydown event is intercepted inside the editor.
				 *
				 * @event onKeyUp
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onKeyUp event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onKeyUp.add(function(ed, e) {
				 *           console.debug('Key up event: ' + e.keyCode);
				 *       });
				 *    }
				 * });
				 */
				'onKeyUp',

				/**
				 * Fires when a keypress event is intercepted inside the editor.
				 *
				 * @event onKeyPress
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onKeyPress event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onKeyPress.add(function(ed, e) {
				 *           console.debug('Key press event: ' + e.keyCode);
				 *       });
				 *    }
				 * });
				 */
				'onKeyPress',

				/**
				 * Fires when a contextmenu event is intercepted inside the editor.
				 *
				 * @event onContextMenu
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onContextMenu event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onContextMenu.add(function(ed, e) {
				 *            console.debug('Context menu event:' + e.target);
				 *       });
				 *    }
				 * });
				 */
				'onContextMenu',

				/**
				 * Fires when a form submit event is intercepted.
				 *
				 * @event onSubmit
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onSubmit event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onSubmit.add(function(ed, e) {
				 *            console.debug('Form submit:' + e.target);
				 *       });
				 *    }
				 * });
				 */
				'onSubmit',

				/**
				 * Fires when a form reset event is intercepted.
				 *
				 * @event onReset
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onReset event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onReset.add(function(ed, e) {
				 *            console.debug('Form reset:' + e.target);
				 *       });
				 *    }
				 * });
				 */
				'onReset',

				/**
				 * Fires when a paste event is intercepted inside the editor.
				 *
				 * @event onPaste
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onPaste event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onPaste.add(function(ed, e) {
				 *            console.debug('Pasted plain text');
				 *       });
				 *    }
				 * });
				 */
				'onPaste',

				/**
				 * Fires when the Serializer does a preProcess on the contents.
				 *
				 * @event onPreProcess
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Object} obj PreProcess object.
				 * @option {Node} node DOM node for the item being serialized.
				 * @option {String} format The specified output format normally "html".
				 * @option {Boolean} get Is true if the process is on a getContent operation.
				 * @option {Boolean} set Is true if the process is on a setContent operation.
				 * @option {Boolean} cleanup Is true if the process is on a cleanup operation.
				 * @example
				 * // Adds an observer to the onPreProcess event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onPreProcess.add(function(ed, o) {
				 *            // Add a class to each paragraph in the editor
				 *            ed.dom.addClass(ed.dom.select('p', o.node), 'myclass');
				 *       });
				 *    }
				 * });
				 */
				'onPreProcess',

				/**
				 * Fires when the Serializer does a postProcess on the contents.
				 *
				 * @event onPostProcess
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Object} obj PreProcess object.
				 * @example
				 * // Adds an observer to the onPostProcess event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onPostProcess.add(function(ed, o) {
				 *            // Remove all paragraphs and replace with BR
				 *            o.content = o.content.replace(/<p[^>]+>|<p>/g, '');
				 *            o.content = o.content.replace(/<\/p>/g, '<br />');
				 *       });
				 *    }
				 * });
				 */
				'onPostProcess',

				/**
				 * Fires before new contents is added to the editor. Using for example setContent.
				 *
				 * @event onBeforeSetContent
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onBeforeSetContent event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onBeforeSetContent.add(function(ed, o) {
				 *            // Replaces all a characters with b characters
				 *            o.content = o.content.replace(/a/g, 'b');
				 *       });
				 *    }
				 * });
				 */
				'onBeforeSetContent',

				/**
				 * Fires before contents is extracted from the editor using for example getContent.
				 *
				 * @event onBeforeGetContent
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Event} evt W3C DOM Event instance.
				 * @example
				 * // Adds an observer to the onBeforeGetContent event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onBeforeGetContent.add(function(ed, o) {
				 *            console.debug('Before get content.');
				 *       });
				 *    }
				 * });
				 */
				'onBeforeGetContent',

				/**
				 * Fires after the contents has been added to the editor using for example onSetContent.
				 *
				 * @event onSetContent
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onSetContent event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onSetContent.add(function(ed, o) {
				 *            // Replaces all a characters with b characters
				 *            o.content = o.content.replace(/a/g, 'b');
				 *       });
				 *    }
				 * });
				 */
				'onSetContent',

				/**
				 * Fires after the contents has been extracted from the editor using for example getContent.
				 *
				 * @event onGetContent
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onGetContent event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onGetContent.add(function(ed, o) {
				 *           // Replace all a characters with b
				 *           o.content = o.content.replace(/a/g, 'b');
				 *       });
				 *    }
				 * });
				 */
				'onGetContent',

				/**
				 * Fires when the editor gets loaded with contents for example when the load method is executed.
				 *
				 * @event onLoadContent
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onLoadContent event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onLoadContent.add(function(ed, o) {
				 *           // Output the element name
				 *           console.debug(o.element.nodeName);
				 *       });
				 *    }
				 * });
				 */
				'onLoadContent',

				/**
				 * Fires when the editor contents gets saved for example when the save method is executed.
				 *
				 * @event onSaveContent
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onSaveContent event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onSaveContent.add(function(ed, o) {
				 *           // Output the element name
				 *           console.debug(o.element.nodeName);
				 *       });
				 *    }
				 * });
				 */
				'onSaveContent',

				/**
				 * Fires when the user changes node location using the mouse or keyboard.
				 *
				 * @event onNodeChange
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onNodeChange event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onNodeChange.add(function(ed, cm, e) {
				 *           // Activates the link button when the caret is placed in a anchor element
				 *           if (e.nodeName == 'A')
				 *              cm.setActive('link', true);
				 *       });
				 *    }
				 * });
				 */
				'onNodeChange',

				/**
				 * Fires when a new undo level is added to the editor.
				 *
				 * @event onChange
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onChange event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 * 	  ed.onChange.add(function(ed, l) {
				 * 		  console.debug('Editor contents was modified. Contents: ' + l.content);
				 * 	  });
				 *    }
				 * });
				 */
				'onChange',

				/**
				 * Fires before a command gets executed for example "Bold".
				 *
				 * @event onBeforeExecCommand
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onBeforeExecCommand event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onBeforeExecCommand.add(function(ed, cmd, ui, val) {
				 *           console.debug('Command is to be executed: ' + cmd);
				 *       });
				 *    }
				 * });
				 */
				'onBeforeExecCommand',

				/**
				 * Fires after a command is executed for example "Bold".
				 *
				 * @event onExecCommand
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onExecCommand event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onExecCommand.add(function(ed, cmd, ui, val) {
				 *           console.debug('Command was executed: ' + cmd);
				 *       });
				 *    }
				 * });
				 */
				'onExecCommand',

				/**
				 * Fires when the contents is undo:ed.
				 *
				 * @event onUndo
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Object} level Undo level object.
				 * @ example
				 * // Adds an observer to the onUndo event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onUndo.add(function(ed, level) {
				 *           console.debug('Undo was performed: ' + level.content);
				 *       });
				 *    }
				 * });
				 */
				'onUndo',

				/**
				 * Fires when the contents is redo:ed.
				 *
				 * @event onRedo
				 * @param {tinymce.Editor} sender Editor instance.
				 * @param {Object} level Undo level object.
				 * @example
				 * // Adds an observer to the onRedo event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onRedo.add(function(ed, level) {
				 *           console.debug('Redo was performed: ' +level.content);
				 *       });
				 *    }
				 * });
				 */
				'onRedo',

				/**
				 * Fires when visual aids is enabled/disabled.
				 *
				 * @event onVisualAid
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onVisualAid event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onVisualAid.add(function(ed, e, s) {
				 *           console.debug('onVisualAid event: ' + ed.id + ", State: " + s);
				 *       });
				 *    }
				 * });
				 */
				'onVisualAid',

				/**
				 * Fires when the progress throbber is shown above the editor.
				 *
				 * @event onSetProgressState
				 * @param {tinymce.Editor} sender Editor instance.
				 * @example
				 * // Adds an observer to the onSetProgressState event using tinyMCE.init
				 * tinyMCE.init({
				 *    ...
				 *    setup : function(ed) {
				 *       ed.onSetProgressState.add(function(ed, b) {
				 *            if (b)
				 *                 console.debug('SHOW!');
				 *            else
				 *                 console.debug('HIDE!');
				 *       });
				 *    }
				 * });
				 */
				'onSetProgressState'
			], function(e) {
				t[e] = new Dispatcher(t);
			});

			/**
			 * Name/value collection with editor settings.
			 *
			 * @property settings
			 * @type Object
			 * @example
			 * // Get the value of the theme setting
			 * tinyMCE.activeEditor.windowManager.alert("You are using the " + tinyMCE.activeEditor.settings.theme + " theme");
			 */
			t.settings = s = extend({
				id : id,
				language : 'en',
				docs_language : 'en',
				theme : 'simple',
				skin : 'default',
				delta_width : 0,
				delta_height : 0,
				popup_css : '',
				plugins : '',
				document_base_url : tinymce.documentBaseURL,
				add_form_submit_trigger : 1,
				submit_patch : 1,
				add_unload_trigger : 1,
				convert_urls : 1,
				relative_urls : 1,
				remove_script_host : 1,
				table_inline_editing : 0,
				object_resizing : 1,
				cleanup : 1,
				accessibility_focus : 1,
				custom_shortcuts : 1,
				custom_undo_redo_keyboard_shortcuts : 1,
				custom_undo_redo_restore_selection : 1,
				custom_undo_redo : 1,
				doctype : tinymce.isIE6 ? '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">' : '<!DOCTYPE>', // Use old doctype on IE 6 to avoid horizontal scroll
				visual_table_class : 'mceItemTable',
				visual : 1,
				font_size_style_values : 'xx-small,x-small,small,medium,large,x-large,xx-large',
				apply_source_formatting : 1,
				directionality : 'ltr',
				forced_root_block : 'p',
				hidden_input : 1,
				padd_empty_editor : 1,
				render_ui : 1,
				init_theme : 1,
				force_p_newlines : 1,
				indentation : '30px',
				keep_styles : 1,
				fix_table_elements : 1,
				inline_styles : 1,
				convert_fonts_to_spans : true,
				indent : 'simple',
				indent_before : 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr',
				indent_after : 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr',
				validate : true,
				entity_encoding : 'named',
				url_converter : t.convertURL,
				url_converter_scope : t,
				ie7_compat : true
			}, s);

			/**
			 * URI object to document configured for the TinyMCE instance.
			 *
			 * @property documentBaseURI
			 * @type tinymce.util.URI
			 * @example
			 * // Get relative URL from the location of document_base_url
			 * tinyMCE.activeEditor.documentBaseURI.toRelative('/somedir/somefile.htm');
			 *
			 * // Get absolute URL from the location of document_base_url
			 * tinyMCE.activeEditor.documentBaseURI.toAbsolute('somefile.htm');
			 */
			t.documentBaseURI = new tinymce.util.URI(s.document_base_url || tinymce.documentBaseURL, {
				base_uri : tinyMCE.baseURI
			});

			/**
			 * URI object to current document that holds the TinyMCE editor instance.
			 *
			 * @property baseURI
			 * @type tinymce.util.URI
			 * @example
			 * // Get relative URL from the location of the API
			 * tinyMCE.activeEditor.baseURI.toRelative('/somedir/somefile.htm');
			 *
			 * // Get absolute URL from the location of the API
			 * tinyMCE.activeEditor.baseURI.toAbsolute('somefile.htm');
			 */
			t.baseURI = tinymce.baseURI;

			/**
			 * Array with CSS files to load into the iframe.
			 *
			 * @property contentCSS
			 * @type Array
			 */
			t.contentCSS = [];

			// Call setup
			t.execCallback('setup', t);
		},

		/**
		 * Renderes the editor/adds it to the page.
		 *
		 * @method render
		 */
		render : function(nst) {
			var t = this, s = t.settings, id = t.id, sl = tinymce.ScriptLoader;

			// Page is not loaded yet, wait for it
			if (!Event.domLoaded) {
				Event.add(document, 'init', function() {
					t.render();
				});
				return;
			}

			tinyMCE.settings = s;

			// Element not found, then skip initialization
			if (!t.getElement())
				return;

			// Is a iPad/iPhone and not on iOS5, then skip initialization. We need to sniff
			// here since the browser says it has contentEditable support but there is no visible
			// caret We will remove this check ones Apple implements full contentEditable support
			if (tinymce.isIDevice && !tinymce.isIOS5)
				return;

			// Add hidden input for non input elements inside form elements
			if (!/TEXTAREA|INPUT/i.test(t.getElement().nodeName) && s.hidden_input && DOM.getParent(id, 'form'))
				DOM.insertAfter(DOM.create('input', {type : 'hidden', name : id}), id);

			/**
			 * Window manager reference, use this to open new windows and dialogs.
			 *
			 * @property windowManager
			 * @type tinymce.WindowManager
			 * @example
			 * // Shows an alert message
			 * tinyMCE.activeEditor.windowManager.alert('Hello world!');
			 *
			 * // Opens a new dialog with the file.htm file and the size 320x240
			 * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.
			 * tinyMCE.activeEditor.windowManager.open({
			 *    url : 'file.htm',
			 *    width : 320,
			 *    height : 240
			 * }, {
			 *    custom_param : 1
			 * });
			 */
			if (tinymce.WindowManager)
				t.windowManager = new tinymce.WindowManager(t);

			if (s.encoding == 'xml') {
				t.onGetContent.add(function(ed, o) {
					if (o.save)
						o.content = DOM.encode(o.content);
				});
			}

			if (s.add_form_submit_trigger) {
				t.onSubmit.addToTop(function() {
					if (t.initialized) {
						t.save();
						t.isNotDirty = 1;
					}
				});
			}

			if (s.add_unload_trigger) {
				t._beforeUnload = tinyMCE.onBeforeUnload.add(function() {
					if (t.initialized && !t.destroyed && !t.isHidden())
						t.save({format : 'raw', no_events : true});
				});
			}

			tinymce.addUnload(t.destroy, t);

			if (s.submit_patch) {
				t.onBeforeRenderUI.add(function() {
					var n = t.getElement().form;

					if (!n)
						return;

					// Already patched
					if (n._mceOldSubmit)
						return;

					// Check page uses id="submit" or name="submit" for it's submit button
					if (!n.submit.nodeType && !n.submit.length) {
						t.formElement = n;
						n._mceOldSubmit = n.submit;
						n.submit = function() {
							// Save all instances
							tinymce.triggerSave();
							t.isNotDirty = 1;

							return t.formElement._mceOldSubmit(t.formElement);
						};
					}

					n = null;
				});
			}

			// Load scripts
			function loadScripts() {
				if (s.language && s.language_load !== false)
					sl.add(tinymce.baseURL + '/langs/' + s.language + '.js');

				if (s.theme && s.theme.charAt(0) != '-' && !ThemeManager.urls[s.theme])
					ThemeManager.load(s.theme, 'themes/' + s.theme + '/editor_template' + tinymce.suffix + '.js');

				each(explode(s.plugins), function(p) {
					if (p &&!PluginManager.urls[p]) {
						if (p.charAt(0) == '-') {
							p = p.substr(1, p.length);
							var dependencies = PluginManager.dependencies(p);
							each(dependencies, function(dep) {
								var defaultSettings = {prefix:'plugins/', resource: dep, suffix:'/editor_plugin' + tinymce.suffix + '.js'};
								var dep = PluginManager.createUrl(defaultSettings, dep);
								PluginManager.load(dep.resource, dep);

							});
						} else {
							// Skip safari plugin, since it is removed as of 3.3b1
							if (p == 'safari') {
								return;
							}
							PluginManager.load(p, {prefix:'plugins/', resource: p, suffix:'/editor_plugin' + tinymce.suffix + '.js'});
						}
					}
				});

				// Init when que is loaded
				sl.loadQueue(function() {
					if (!t.removed)
						t.init();
				});
			};

			loadScripts();
		},

		/**
		 * Initializes the editor this will be called automatically when
		 * all plugins/themes and language packs are loaded by the rendered method.
		 * This method will setup the iframe and create the theme and plugin instances.
		 *
		 * @method init
		 */
		init : function() {
			var n, t = this, s = t.settings, w, h, e = t.getElement(), o, ti, u, bi, bc, re, i, initializedPlugins = [];

			tinymce.add(t);

			s.aria_label = s.aria_label || DOM.getAttrib(e, 'aria-label', t.getLang('aria.rich_text_area'));

			/**
			 * Reference to the theme instance that was used to generate the UI.
			 *
			 * @property theme
			 * @type tinymce.Theme
			 * @example
			 * // Executes a method on the theme directly
			 * tinyMCE.activeEditor.theme.someMethod();
			 */
			if (s.theme) {
				s.theme = s.theme.replace(/-/, '');
				o = ThemeManager.get(s.theme);
				t.theme = new o();

				if (t.theme.init && s.init_theme)
					t.theme.init(t, ThemeManager.urls[s.theme] || tinymce.documentBaseURL.replace(/\/$/, ''));
			}
			function initPlugin(p) {
				var c = PluginManager.get(p), u = PluginManager.urls[p] || tinymce.documentBaseURL.replace(/\/$/, ''), po;
				if (c && tinymce.inArray(initializedPlugins,p) === -1) {
					each(PluginManager.dependencies(p), function(dep){
						initPlugin(dep);
					});
					po = new c(t, u);

					t.plugins[p] = po;

					if (po.init) {
						po.init(t, u);
						initializedPlugins.push(p);
					}
				}
			}

			// Create all plugins
			each(explode(s.plugins.replace(/\-/g, '')), initPlugin);

			// Setup popup CSS path(s)
			if (s.popup_css !== false) {
				if (s.popup_css)
					s.popup_css = t.documentBaseURI.toAbsolute(s.popup_css);
				else
					s.popup_css = t.baseURI.toAbsolute("themes/" + s.theme + "/skins/" + s.skin + "/dialog.css");
			}

			if (s.popup_css_add)
				s.popup_css += ',' + t.documentBaseURI.toAbsolute(s.popup_css_add);

			/**
			 * Control manager instance for the editor. Will enables you to create new UI elements and change their states etc.
			 *
			 * @property controlManager
			 * @type tinymce.ControlManager
			 * @example
			 * // Disables the bold button
			 * tinyMCE.activeEditor.controlManager.setDisabled('bold', true);
			 */
			t.controlManager = new tinymce.ControlManager(t);

			if (s.custom_undo_redo) {
				t.onBeforeExecCommand.add(function(ed, cmd, ui, val, a) {
					if (cmd != 'Undo' && cmd != 'Redo' && cmd != 'mceRepaint' && (!a || !a.skip_undo))
						t.undoManager.beforeChange();
				});

				t.onExecCommand.add(function(ed, cmd, ui, val, a) {
					if (cmd != 'Undo' && cmd != 'Redo' && cmd != 'mceRepaint' && (!a || !a.skip_undo))
						t.undoManager.add();
				});
			}

			t.onExecCommand.add(function(ed, c) {
				// Don't refresh the select lists until caret move
				if (!/^(FontName|FontSize)$/.test(c))
					t.nodeChanged();
			});

			// Remove ghost selections on images and tables in Gecko
			if (isGecko) {
				function repaint(a, o) {
					if (!o || !o.initial)
						t.execCommand('mceRepaint');
				};

				t.onUndo.add(repaint);
				t.onRedo.add(repaint);
				t.onSetContent.add(repaint);
			}

			// Enables users to override the control factory
			t.onBeforeRenderUI.dispatch(t, t.controlManager);

			// Measure box
			if (s.render_ui) {
				w = s.width || e.style.width || e.offsetWidth;
				h = s.height || e.style.height || e.offsetHeight;
				t.orgDisplay = e.style.display;
				re = /^[0-9\.]+(|px)$/i;

				if (re.test('' + w))
					w = Math.max(parseInt(w) + (o.deltaWidth || 0), 100);

				if (re.test('' + h))
					h = Math.max(parseInt(h) + (o.deltaHeight || 0), 100);

				// Render UI
				o = t.theme.renderUI({
					targetNode : e,
					width : w,
					height : h,
					deltaWidth : s.delta_width,
					deltaHeight : s.delta_height
				});

				t.editorContainer = o.editorContainer;
			}

			// #ifdef contentEditable

			// Content editable mode ends here
			if (s.content_editable) {
				e = n = o = null; // Fix IE leak
				return t.setupContentEditable();
			}

			// #endif

			// User specified a document.domain value
			if (document.domain && location.hostname != document.domain)
				tinymce.relaxedDomain = document.domain;

			// Resize editor
			DOM.setStyles(o.sizeContainer || o.editorContainer, {
				width : w,
				height : h
			});

			// Load specified content CSS last
			if (s.content_css) {
				tinymce.each(explode(s.content_css), function(u) {
					t.contentCSS.push(t.documentBaseURI.toAbsolute(u));
				});
			}

			h = (o.iframeHeight || h) + (typeof(h) == 'number' ? (o.deltaHeight || 0) : '');
			if (h < 100)
				h = 100;

			t.iframeHTML = s.doctype + '<html><head xmlns="http://www.w3.org/1999/xhtml">';

			// We only need to override paths if we have to
			// IE has a bug where it remove site absolute urls to relative ones if this is specified
			if (s.document_base_url != tinymce.documentBaseURL)
				t.iframeHTML += '<base href="' + t.documentBaseURI.getURI() + '" />';

			// IE8 doesn't support carets behind images setting ie7_compat would force IE8+ to run in IE7 compat mode.
//			if (s.ie7_compat)
//				t.iframeHTML += '<meta http-equiv="X-UA-Compatible" content="IE=7" />';
//			else
//				t.iframeHTML += '<meta http-equiv="X-UA-Compatible" content="IE=edge" />';

			t.iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';

			t.iframeHTML += '<style type="text/css">body {font:12px arial, helvetica; margin: 0; padding: 8px; background-color: #fff;}</style>';

			// Load the CSS by injecting them into the HTML this will reduce "flicker"
			for (i = 0; i < t.contentCSS.length; i++) {
				t.iframeHTML += '<link type="text/css" rel="stylesheet" href="' + t.contentCSS[i] + '" />';
			}

			bi = s.body_id || 'tinymce';
			if (bi.indexOf('=') != -1) {
				bi = t.getParam('body_id', '', 'hash');
				bi = bi[t.id] || bi;
			}

			bc = s.body_class || '';
			if (bc.indexOf('=') != -1) {
				bc = t.getParam('body_class', '', 'hash');
				bc = bc[t.id] || '';
			}

			t.iframeHTML += '</head><body id="' + bi + '" class="mceContentBody ' + bc + '"><br></body></html>';

			// Domain relaxing enabled, then set document domain
			if (tinymce.relaxedDomain && (isIE || (tinymce.isOpera && parseFloat(opera.version()) < 11))) {
				// We need to write the contents here in IE since multiple writes messes up refresh button and back button
				u = 'javascript:(function(){document.open();document.domain="' + document.domain + '";var ed = window.parent.tinyMCE.get("' + t.id + '");document.write(ed.iframeHTML);document.close();ed.setupIframe();})()';
			}

			// Create iframe
			// TODO: ACC add the appropriate description on this.
			n = DOM.add(o.iframeContainer, 'iframe', {
				id : t.id + "_ifr",
				src : u || 'javascript:""', // Workaround for HTTPS warning in IE6/7
				frameBorder : '0',
				allowTransparency : "true",
				title : s.aria_label,
				style : {
					width : '100%',
					height : h,
					display : 'block' // Important for Gecko to render the iframe correctly
				}
			});

			t.contentAreaContainer = o.iframeContainer;
			DOM.get(o.editorContainer).style.display = t.orgDisplay;
			DOM.get(t.id).style.display = 'none';
			DOM.setAttrib(t.id, 'aria-hidden', true);

			if (!tinymce.relaxedDomain || !u)
				t.setupIframe();

			e = n = o = null; // Cleanup
		},

		/**
		 * This method get called by the init method ones the iframe is loaded.
		 * It will fill the iframe with contents, setups DOM and selection objects for the iframe.
		 * This method should not be called directly.
		 *
		 * @method setupIframe
		 */
		setupIframe : function() {
			var t = this, s = t.settings, e = DOM.get(t.id), d = t.getDoc(), h, b;

			// Setup iframe body
			if (!isIE || !tinymce.relaxedDomain) {
				d.open();
				d.write(t.iframeHTML);
				d.close();

				if (tinymce.relaxedDomain)
					d.domain = tinymce.relaxedDomain;
			}

			// It will not steal focus while setting contentEditable
			b = t.getBody();
			b.disabled = true;

			if (!s.readonly)
				b.contentEditable = true;

			b.disabled = false;

			/**
			 * Schema instance, enables you to validate elements and it's children.
			 *
			 * @property schema
			 * @type tinymce.html.Schema
			 */
			t.schema = new tinymce.html.Schema(s);

			/**
			 * DOM instance for the editor.
			 *
			 * @property dom
			 * @type tinymce.dom.DOMUtils
			 * @example
			 * // Adds a class to all paragraphs within the editor
			 * tinyMCE.activeEditor.dom.addClass(tinyMCE.activeEditor.dom.select('p'), 'someclass');
			 */
			t.dom = new tinymce.dom.DOMUtils(t.getDoc(), {
				keep_values : true,
				url_converter : t.convertURL,
				url_converter_scope : t,
				hex_colors : s.force_hex_style_colors,
				class_filter : s.class_filter,
				update_styles : 1,
				fix_ie_paragraphs : 1,
				schema : t.schema
			});

			/**
			 * HTML parser will be used when contents is inserted into the editor.
			 *
			 * @property parser
			 * @type tinymce.html.DomParser
			 */
			t.parser = new tinymce.html.DomParser(s, t.schema);

			// Force anchor names closed, unless the setting "allow_html_in_named_anchor" is explicitly included.
			if (!t.settings.allow_html_in_named_anchor) {
				t.parser.addAttributeFilter('name', function(nodes, name) {
					var i = nodes.length, sibling, prevSibling, parent, node;

					while (i--) {
						node = nodes[i];
						if (node.name === 'a' && node.firstChild) {
							parent = node.parent;

							// Move children after current node
							sibling = node.lastChild;
							do {
								prevSibling = sibling.prev;
								parent.insert(sibling, node);
								sibling = prevSibling;
							} while (sibling);
						}
					}
				});
			}

			// Convert src and href into data-mce-src, data-mce-href and data-mce-style
			t.parser.addAttributeFilter('src,href,style', function(nodes, name) {
				var i = nodes.length, node, dom = t.dom, value, internalName;

				while (i--) {
					node = nodes[i];
					value = node.attr(name);
					internalName = 'data-mce-' + name;

					// Add internal attribute if we need to we don't on a refresh of the document
					if (!node.attributes.map[internalName]) {
						if (name === "style")
							node.attr(internalName, dom.serializeStyle(dom.parseStyle(value), node.name));
						else
							node.attr(internalName, t.convertURL(value, name, node.name));
					}
				}
			});

			// Keep scripts from executing
			t.parser.addNodeFilter('script', function(nodes, name) {
				var i = nodes.length;

				while (i--)
					nodes[i].attr('type', 'mce-text/javascript');
			});

			t.parser.addNodeFilter('#cdata', function(nodes, name) {
				var i = nodes.length, node;

				while (i--) {
					node = nodes[i];
					node.type = 8;
					node.name = '#comment';
					node.value = '[CDATA[' + node.value + ']]';
				}
			});

			t.parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function(nodes, name) {
				var i = nodes.length, node, nonEmptyElements = t.schema.getNonEmptyElements();

				while (i--) {
					node = nodes[i];

					if (node.isEmpty(nonEmptyElements))
						node.empty().append(new tinymce.html.Node('br', 1)).shortEnded = true;
				}
			});

			/**
			 * DOM serializer for the editor. Will be used when contents is extracted from the editor.
			 *
			 * @property serializer
			 * @type tinymce.dom.Serializer
			 * @example
			 * // Serializes the first paragraph in the editor into a string
			 * tinyMCE.activeEditor.serializer.serialize(tinyMCE.activeEditor.dom.select('p')[0]);
			 */
			t.serializer = new tinymce.dom.Serializer(s, t.dom, t.schema);

			/**
			 * Selection instance for the editor.
			 *
			 * @property selection
			 * @type tinymce.dom.Selection
			 * @example
			 * // Sets some contents to the current selection in the editor
			 * tinyMCE.activeEditor.selection.setContent('Some contents');
			 *
			 * // Gets the current selection
			 * alert(tinyMCE.activeEditor.selection.getContent());
			 *
			 * // Selects the first paragraph found
			 * tinyMCE.activeEditor.selection.select(tinyMCE.activeEditor.dom.select('p')[0]);
			 */
			t.selection = new tinymce.dom.Selection(t.dom, t.getWin(), t.serializer);

			/**
			 * Formatter instance.
			 *
			 * @property formatter
			 * @type tinymce.Formatter
			 */
			t.formatter = new tinymce.Formatter(this);

			// Register default formats
			t.formatter.register({
				alignleft : [
					{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'left'}},
					{selector : 'img,table', collapsed : false, styles : {'float' : 'left'}}
				],

				aligncenter : [
					{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'center'}},
					{selector : 'img', collapsed : false, styles : {display : 'block', marginLeft : 'auto', marginRight : 'auto'}},
					{selector : 'table', collapsed : false, styles : {marginLeft : 'auto', marginRight : 'auto'}}
				],

				alignright : [
					{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'right'}},
					{selector : 'img,table', collapsed : false, styles : {'float' : 'right'}}
				],

				alignfull : [
					{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'justify'}}
				],

				bold : [
					{inline : 'strong', remove : 'all'},
					{inline : 'span', styles : {fontWeight : 'bold'}},
					{inline : 'b', remove : 'all'}
				],

				italic : [
					{inline : 'em', remove : 'all'},
					{inline : 'span', styles : {fontStyle : 'italic'}},
					{inline : 'i', remove : 'all'}
				],

				underline : [
					{inline : 'span', styles : {textDecoration : 'underline'}, exact : true},
					{inline : 'u', remove : 'all'}
				],

				strikethrough : [
					{inline : 'span', styles : {textDecoration : 'line-through'}, exact : true},
					{inline : 'strike', remove : 'all'}
				],

				forecolor : {inline : 'span', styles : {color : '%value'}, wrap_links : false},
				hilitecolor : {inline : 'span', styles : {backgroundColor : '%value'}, wrap_links : false},
				fontname : {inline : 'span', styles : {fontFamily : '%value'}},
				fontsize : {inline : 'span', styles : {fontSize : '%value'}},
				fontsize_class : {inline : 'span', attributes : {'class' : '%value'}},
				blockquote : {block : 'blockquote', wrapper : 1, remove : 'all'},
				subscript : {inline : 'sub'},
				superscript : {inline : 'sup'},

				link : {inline : 'a', selector : 'a', remove : 'all', split : true, deep : true,
					onmatch : function(node) {
						return true;
					},

					onformat : function(elm, fmt, vars) {
						each(vars, function(value, key) {
							t.dom.setAttrib(elm, key, value);
						});
					}
				},

				removeformat : [
					{selector : 'b,strong,em,i,font,u,strike', remove : 'all', split : true, expand : false, block_expand : true, deep : true},
					{selector : 'span', attributes : ['style', 'class'], remove : 'empty', split : true, expand : false, deep : true},
					{selector : '*', attributes : ['style', 'class'], split : false, expand : false, deep : true}
				]
			});

			// Register default block formats
			each('p h1 h2 h3 h4 h5 h6 div address pre div code dt dd samp'.split(/\s/), function(name) {
				t.formatter.register(name, {block : name, remove : 'all'});
			});

			// Register user defined formats
			t.formatter.register(t.settings.formats);

			/**
			 * Undo manager instance, responsible for handling undo levels.
			 *
			 * @property undoManager
			 * @type tinymce.UndoManager
			 * @example
			 * // Undoes the last modification to the editor
			 * tinyMCE.activeEditor.undoManager.undo();
			 */
			t.undoManager = new tinymce.UndoManager(t);

			// Pass through
			t.undoManager.onAdd.add(function(um, l) {
				if (um.hasUndo())
					return t.onChange.dispatch(t, l, um);
			});

			t.undoManager.onUndo.add(function(um, l) {
				return t.onUndo.dispatch(t, l, um);
			});

			t.undoManager.onRedo.add(function(um, l) {
				return t.onRedo.dispatch(t, l, um);
			});

			t.forceBlocks = new tinymce.ForceBlocks(t, {
				forced_root_block : s.forced_root_block
			});

			t.editorCommands = new tinymce.EditorCommands(t);

			// Pass through
			t.serializer.onPreProcess.add(function(se, o) {
				return t.onPreProcess.dispatch(t, o, se);
			});

			t.serializer.onPostProcess.add(function(se, o) {
				return t.onPostProcess.dispatch(t, o, se);
			});

			t.onPreInit.dispatch(t);

			if (!s.gecko_spellcheck)
				t.getBody().spellcheck = 0;

			if (!s.readonly)
				t._addEvents();

			t.controlManager.onPostRender.dispatch(t, t.controlManager);
			t.onPostRender.dispatch(t);

			t.quirks = new tinymce.util.Quirks(this);

			if (s.directionality)
				t.getBody().dir = s.directionality;

			if (s.nowrap)
				t.getBody().style.whiteSpace = "nowrap";

			if (s.handle_node_change_callback) {
				t.onNodeChange.add(function(ed, cm, n) {
					t.execCallback('handle_node_change_callback', t.id, n, -1, -1, true, t.selection.isCollapsed());
				});
			}

			if (s.save_callback) {
				t.onSaveContent.add(function(ed, o) {
					var h = t.execCallback('save_callback', t.id, o.content, t.getBody());

					if (h)
						o.content = h;
				});
			}

			if (s.onchange_callback) {
				t.onChange.add(function(ed, l) {
					t.execCallback('onchange_callback', t, l);
				});
			}

			if (s.protect) {
				t.onBeforeSetContent.add(function(ed, o) {
					if (s.protect) {
						each(s.protect, function(pattern) {
							o.content = o.content.replace(pattern, function(str) {
								return '<!--mce:protected ' + escape(str) + '-->';
							});
						});
					}
				});
			}

			if (s.convert_newlines_to_brs) {
				t.onBeforeSetContent.add(function(ed, o) {
					if (o.initial)
						o.content = o.content.replace(/\r?\n/g, '<br />');
				});
			}

			if (s.preformatted) {
				t.onPostProcess.add(function(ed, o) {
					o.content = o.content.replace(/^\s*<pre.*?>/, '');
					o.content = o.content.replace(/<\/pre>\s*$/, '');

					if (o.set)
						o.content = '<pre class="mceItemHidden">' + o.content + '</pre>';
				});
			}

			if (s.verify_css_classes) {
				t.serializer.attribValueFilter = function(n, v) {
					var s, cl;

					if (n == 'class') {
						// Build regexp for classes
						if (!t.classesRE) {
							cl = t.dom.getClasses();

							if (cl.length > 0) {
								s = '';

								each (cl, function(o) {
									s += (s ? '|' : '') + o['class'];
								});

								t.classesRE = new RegExp('(' + s + ')', 'gi');
							}
						}

						return !t.classesRE || /(\bmceItem\w+\b|\bmceTemp\w+\b)/g.test(v) || t.classesRE.test(v) ? v : '';
					}

					return v;
				};
			}

			if (s.cleanup_callback) {
				t.onBeforeSetContent.add(function(ed, o) {
					o.content = t.execCallback('cleanup_callback', 'insert_to_editor', o.content, o);
				});

				t.onPreProcess.add(function(ed, o) {
					if (o.set)
						t.execCallback('cleanup_callback', 'insert_to_editor_dom', o.node, o);

					if (o.get)
						t.execCallback('cleanup_callback', 'get_from_editor_dom', o.node, o);
				});

				t.onPostProcess.add(function(ed, o) {
					if (o.set)
						o.content = t.execCallback('cleanup_callback', 'insert_to_editor', o.content, o);

					if (o.get)
						o.content = t.execCallback('cleanup_callback', 'get_from_editor', o.content, o);
				});
			}

			if (s.save_callback) {
				t.onGetContent.add(function(ed, o) {
					if (o.save)
						o.content = t.execCallback('save_callback', t.id, o.content, t.getBody());
				});
			}

			if (s.handle_event_callback) {
				t.onEvent.add(function(ed, e, o) {
					if (t.execCallback('handle_event_callback', e, ed, o) === false)
						Event.cancel(e);
				});
			}

			// Add visual aids when new contents is added
			t.onSetContent.add(function() {
				t.addVisual(t.getBody());
			});

			// Remove empty contents
			if (s.padd_empty_editor) {
				t.onPostProcess.add(function(ed, o) {
					o.content = o.content.replace(/^(<p[^>]*>(&nbsp;|&#160;|\s|\u00a0|)<\/p>[\r\n]*|<br \/>[\r\n]*)$/, '');
				});
			}

			if (isGecko) {
				// Fix gecko link bug, when a link is placed at the end of block elements there is
				// no way to move the caret behind the link. This fix adds a bogus br element after the link
				function fixLinks(ed, o) {
					each(ed.dom.select('a'), function(n) {
						var pn = n.parentNode;

						if (ed.dom.isBlock(pn) && pn.lastChild === n)
							ed.dom.add(pn, 'br', {'data-mce-bogus' : 1});
					});
				};

				t.onExecCommand.add(function(ed, cmd) {
					if (cmd === 'CreateLink')
						fixLinks(ed);
				});

				t.onSetContent.add(t.selection.onSetContent.add(fixLinks));
			}

			t.load({initial : true, format : 'html'});
			t.startContent = t.getContent({format : 'raw'});
			t.undoManager.add();
			t.initialized = true;

			t.onInit.dispatch(t);
			t.execCallback('setupcontent_callback', t.id, t.getBody(), t.getDoc());
			t.execCallback('init_instance_callback', t);
			t.focus(true);
			t.nodeChanged({initial : 1});

			// Load specified content CSS last
			each(t.contentCSS, function(u) {
				t.dom.loadCSS(u);
			});

			// Handle auto focus
			if (s.auto_focus) {
				setTimeout(function () {
					var ed = tinymce.get(s.auto_focus);

					ed.selection.select(ed.getBody(), 1);
					ed.selection.collapse(1);
					ed.getBody().focus();
					ed.getWin().focus();
				}, 100);
			}

			e = null;
		},

		// #ifdef contentEditable

		/**
		 * Sets up the contentEditable mode.
		 *
		 * @method setupContentEditable
		 */
		setupContentEditable : function() {
			var t = this, s = t.settings, e = t.getElement();

			t.contentDocument = s.content_document || document;
			t.contentWindow = s.content_window || window;
			t.bodyElement = e;

			// Prevent leak in IE
			s.content_document = s.content_window = null;

			DOM.hide(e);
			e.contentEditable = t.getParam('content_editable_state', true);
			DOM.show(e);

			if (!s.gecko_spellcheck)
				t.getDoc().body.spellcheck = 0;

			// Setup objects
			t.dom = new tinymce.dom.DOMUtils(t.getDoc(), {
				keep_values : true,
				url_converter : t.convertURL,
				url_converter_scope : t,
				hex_colors : s.force_hex_style_colors,
				class_filter : s.class_filter,
				root_element : t.id,
				fix_ie_paragraphs : 1,
				update_styles : 1
			});

			t.serializer = new tinymce.dom.Serializer(s, t.dom, schema);

			t.selection = new tinymce.dom.Selection(t.dom, t.getWin(), t.serializer);
			t.forceBlocks = new tinymce.ForceBlocks(t, {
				forced_root_block : s.forced_root_block
			});

			t.editorCommands = new tinymce.EditorCommands(t);

			// Pass through
			t.serializer.onPreProcess.add(function(se, o) {
				return t.onPreProcess.dispatch(t, o, se);
			});

			t.serializer.onPostProcess.add(function(se, o) {
				return t.onPostProcess.dispatch(t, o, se);
			});

			t.onPreInit.dispatch(t);
			t._addEvents();

			t.controlManager.onPostRender.dispatch(t, t.controlManager);
			t.onPostRender.dispatch(t);

			t.onSetContent.add(function() {
				t.addVisual(t.getBody());
			});

			//t.load({initial : true, format : (s.cleanup_on_startup ? 'html' : 'raw')});
			t.startContent = t.getContent({format : 'raw'});
			t.undoManager.add({initial : true});
			t.initialized = true;

			t.onInit.dispatch(t);
			t.focus(true);
			t.nodeChanged({initial : 1});

			// Load specified content CSS last
			if (s.content_css) {
				each(explode(s.content_css), function(u) {
					t.dom.loadCSS(t.documentBaseURI.toAbsolute(u));
				});
			}

			if (isIE) {
				// Store away selection
				t.dom.bind(t.getElement(), 'beforedeactivate', function() {
					t.lastSelectionBookmark = t.selection.getBookmark(1);
				});

				t.onBeforeExecCommand.add(function(ed, cmd, ui, val, o) {
					if (!DOM.getParent(ed.selection.getStart(), function(n) {return n == ed.getBody();}))
						o.terminate = 1;

					if (!DOM.getParent(ed.selection.getEnd(), function(n) {return n == ed.getBody();}))
						o.terminate = 1;
				});
			}

			e = null; // Cleanup
		},

		// #endif

		/**
		 * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection
		 * it will also place DOM focus inside the editor.
		 *
		 * @method focus
		 * @param {Boolean} sf Skip DOM focus. Just set is as the active editor.
		 */
		focus : function(sf) {
			var oed, t = this, selection = t.selection, ce = t.settings.content_editable, ieRng, controlElm, doc = t.getDoc();

			if (!sf) {
				// Get selected control element
				ieRng = selection.getRng();
				if (ieRng.item) {
					controlElm = ieRng.item(0);
				}

				t._refreshContentEditable();
				selection.normalize();

				// Is not content editable
				if (!ce)
					t.getWin().focus();

				// Focus the body as well since it's contentEditable
				if (tinymce.isGecko) {
					t.getBody().focus();
				}

				// Restore selected control element
				// This is needed when for example an image is selected within a
				// layer a call to focus will then remove the control selection
				if (controlElm && controlElm.ownerDocument == doc) {
					ieRng = doc.body.createControlRange();
					ieRng.addElement(controlElm);
					ieRng.select();
				}

				// #ifdef contentEditable

				// Content editable mode ends here
				if (ce) {
					if (tinymce.isWebKit)
//						t.getWin().focus();
						t.getBody().focus();
					else {
						if (tinymce.isIE)
							t.getElement().setActive();
						else
							t.getElement().focus();
					}
				}

				// #endif
			}

			if (tinymce.activeEditor != t) {
				if ((oed = tinymce.activeEditor) != null)
					oed.onDeactivate.dispatch(oed, t);

				t.onActivate.dispatch(t, oed);
			}

			tinymce._setActive(t);
		},

		/**
		 * Executes a legacy callback. This method is useful to call old 2.x option callbacks.
		 * There new event model is a better way to add callback so this method might be removed in the future.
		 *
		 * @method execCallback
		 * @param {String} n Name of the callback to execute.
		 * @return {Object} Return value passed from callback function.
		 */
		execCallback : function(n) {
			var t = this, f = t.settings[n], s;

			if (!f)
				return;

			// Look through lookup
			if (t.callbackLookup && (s = t.callbackLookup[n])) {
				f = s.func;
				s = s.scope;
			}

			if (is(f, 'string')) {
				s = f.replace(/\.\w+$/, '');
				s = s ? tinymce.resolve(s) : 0;
				f = tinymce.resolve(f);
				t.callbackLookup = t.callbackLookup || {};
				t.callbackLookup[n] = {func : f, scope : s};
			}

			return f.apply(s || t, Array.prototype.slice.call(arguments, 1));
		},

		/**
		 * Translates the specified string by replacing variables with language pack items it will also check if there is
		 * a key mathcin the input.
		 *
		 * @method translate
		 * @param {String} s String to translate by the language pack data.
		 * @return {String} Translated string.
		 */
		translate : function(s) {
			var c = this.settings.language || 'en', i18n = tinymce.i18n;

			if (!s)
				return '';

			return i18n[c + '.' + s] || s.replace(/{\#([^}]+)\}/g, function(a, b) {
				return i18n[c + '.' + b] || '{#' + b + '}';
			});
		},

		/**
		 * Returns a language pack item by name/key.
		 *
		 * @method getLang
		 * @param {String} n Name/key to get from the language pack.
		 * @param {String} dv Optional default value to retrive.
		 */
		getLang : function(n, dv) {
			return tinymce.i18n[(this.settings.language || 'en') + '.' + n] || (is(dv) ? dv : '{#' + n + '}');
		},

		/**
		 * Returns a configuration parameter by name.
		 *
		 * @method getParam
		 * @param {String} n Configruation parameter to retrive.
		 * @param {String} dv Optional default value to return.
		 * @param {String} ty Optional type parameter.
		 * @return {String} Configuration parameter value or default value.
		 * @example
		 * // Returns a specific config value from the currently active editor
		 * var someval = tinyMCE.activeEditor.getParam('myvalue');
		 *
		 * // Returns a specific config value from a specific editor instance by id
		 * var someval2 = tinyMCE.get('my_editor').getParam('myvalue');
		 */
		getParam : function(n, dv, ty) {
			var tr = tinymce.trim, v = is(this.settings[n]) ? this.settings[n] : dv, o;

			if (ty === 'hash') {
				o = {};

				if (is(v, 'string')) {
					each(v.indexOf('=') > 0 ? v.split(/[;,](?![^=;,]*(?:[;,]|$))/) : v.split(','), function(v) {
						v = v.split('=');

						if (v.length > 1)
							o[tr(v[0])] = tr(v[1]);
						else
							o[tr(v[0])] = tr(v);
					});
				} else
					o = v;

				return o;
			}

			return v;
		},

		/**
		 * Distpaches out a onNodeChange event to all observers. This method should be called when you
		 * need to update the UI states or element path etc.
		 *
		 * @method nodeChanged
		 * @param {Object} o Optional object to pass along for the node changed event.
		 */
		nodeChanged : function(o) {
			var t = this, s = t.selection, n = s.getStart() || t.getBody();

			// Fix for bug #1896577 it seems that this can not be fired while the editor is loading
			if (t.initialized) {
				o = o || {};
				n = isIE && n.ownerDocument != t.getDoc() ? t.getBody() : n; // Fix for IE initial state

				// Get parents and add them to object
				o.parents = [];
				t.dom.getParent(n, function(node) {
					if (node.nodeName == 'BODY')
						return true;

					o.parents.push(node);
				});

				t.onNodeChange.dispatch(
					t,
					o ? o.controlManager || t.controlManager : t.controlManager,
					n,
					s.isCollapsed(),
					o
				);
			}
		},

		/**
		 * Adds a button that later gets created by the ControlManager. This is a shorter and easier method
		 * of adding buttons without the need to deal with the ControlManager directly. But it's also less
		 * powerfull if you need more control use the ControlManagers factory methods instead.
		 *
		 * @method addButton
		 * @param {String} n Button name to add.
		 * @param {Object} s Settings object with title, cmd etc.
		 * @example
		 * // Adds a custom button to the editor and when a user clicks the button it will open
		 * // an alert box with the selected contents as plain text.
		 * tinyMCE.init({
		 *    ...
		 *
		 *    theme_advanced_buttons1 : 'example,..'
		 *
		 *    setup : function(ed) {
		 *       // Register example button
		 *       ed.addButton('example', {
		 *          title : 'example.desc',
		 *          image : '../jscripts/tiny_mce/plugins/example/img/example.gif',
		 *          onclick : function() {
		 *             ed.windowManager.alert('Hello world!! Selection: ' + ed.selection.getContent({format : 'text'}));
		 *          }
		 *       });
		 *    }
		 * });
		 */
		addButton : function(n, s) {
			var t = this;

			t.buttons = t.buttons || {};
			t.buttons[n] = s;
		},

		/**
		 * Adds a custom command to the editor, you can also override existing commands with this method.
		 * The command that you add can be executed with execCommand.
		 *
		 * @method addCommand
		 * @param {String} name Command name to add/override.
		 * @param {addCommandCallback} callback Function to execute when the command occurs.
		 * @param {Object} scope Optional scope to execute the function in.
		 * @example
		 * // Adds a custom command that later can be executed using execCommand
		 * tinyMCE.init({
		 *    ...
		 *
		 *    setup : function(ed) {
		 *       // Register example command
		 *       ed.addCommand('mycommand', function(ui, v) {
		 *          ed.windowManager.alert('Hello world!! Selection: ' + ed.selection.getContent({format : 'text'}));
		 *       });
		 *    }
		 * });
		 */
		addCommand : function(name, callback, scope) {
			/**
			 * Callback function that gets called when a command is executed.
			 *
			 * @callback addCommandCallback
			 * @param {Boolean} ui Display UI state true/false.
			 * @param {Object} value Optional value for command.
			 * @return {Boolean} True/false state if the command was handled or not.
			 */
			this.execCommands[name] = {func : callback, scope : scope || this};
		},

		/**
		 * Adds a custom query state command to the editor, you can also override existing commands with this method.
		 * The command that you add can be executed with queryCommandState function.
		 *
		 * @method addQueryStateHandler
		 * @param {String} name Command name to add/override.
		 * @param {addQueryStateHandlerCallback} callback Function to execute when the command state retrival occurs.
		 * @param {Object} scope Optional scope to execute the function in.
		 */
		addQueryStateHandler : function(name, callback, scope) {
			/**
			 * Callback function that gets called when a queryCommandState is executed.
			 *
			 * @callback addQueryStateHandlerCallback
			 * @return {Boolean} True/false state if the command is enabled or not like is it bold.
			 */
			this.queryStateCommands[name] = {func : callback, scope : scope || this};
		},

		/**
		 * Adds a custom query value command to the editor, you can also override existing commands with this method.
		 * The command that you add can be executed with queryCommandValue function.
		 *
		 * @method addQueryValueHandler
		 * @param {String} name Command name to add/override.
		 * @param {addQueryValueHandlerCallback} callback Function to execute when the command value retrival occurs.
		 * @param {Object} scope Optional scope to execute the function in.
		 */
		addQueryValueHandler : function(name, callback, scope) {
			/**
			 * Callback function that gets called when a queryCommandValue is executed.
			 *
			 * @callback addQueryValueHandlerCallback
			 * @return {Object} Value of the command or undefined.
			 */
			this.queryValueCommands[name] = {func : callback, scope : scope || this};
		},

		/**
		 * Adds a keyboard shortcut for some command or function.
		 *
		 * @method addShortcut
		 * @param {String} pa Shortcut pattern. Like for example: ctrl+alt+o.
		 * @param {String} desc Text description for the command.
		 * @param {String/Function} cmd_func Command name string or function to execute when the key is pressed.
		 * @param {Object} sc Optional scope to execute the function in.
		 * @return {Boolean} true/false state if the shortcut was added or not.
		 */
		addShortcut : function(pa, desc, cmd_func, sc) {
			var t = this, c;

			if (!t.settings.custom_shortcuts)
				return false;

			t.shortcuts = t.shortcuts || {};

			if (is(cmd_func, 'string')) {
				c = cmd_func;

				cmd_func = function() {
					t.execCommand(c, false, null);
				};
			}

			if (is(cmd_func, 'object')) {
				c = cmd_func;

				cmd_func = function() {
					t.execCommand(c[0], c[1], c[2]);
				};
			}

			each(explode(pa), function(pa) {
				var o = {
					func : cmd_func,
					scope : sc || this,
					desc : desc,
					alt : false,
					ctrl : false,
					shift : false
				};

				each(explode(pa, '+'), function(v) {
					switch (v) {
						case 'alt':
						case 'ctrl':
						case 'shift':
							o[v] = true;
							break;

						default:
							o.charCode = v.charCodeAt(0);
							o.keyCode = v.toUpperCase().charCodeAt(0);
					}
				});

				t.shortcuts[(o.ctrl ? 'ctrl' : '') + ',' + (o.alt ? 'alt' : '') + ',' + (o.shift ? 'shift' : '') + ',' + o.keyCode] = o;
			});

			return true;
		},

		/**
		 * Executes a command on the current instance. These commands can be TinyMCE internal commands prefixed with "mce" or
		 * they can be build in browser commands such as "Bold". A compleate list of browser commands is available on MSDN or Mozilla.org.
		 * This function will dispatch the execCommand function on each plugin, theme or the execcommand_callback option if none of these
		 * return true it will handle the command as a internal browser command.
		 *
		 * @method execCommand
		 * @param {String} cmd Command name to execute, for example mceLink or Bold.
		 * @param {Boolean} ui True/false state if a UI (dialog) should be presented or not.
		 * @param {mixed} val Optional command value, this can be anything.
		 * @param {Object} a Optional arguments object.
		 * @return {Boolean} True/false if the command was executed or not.
		 */
		execCommand : function(cmd, ui, val, a) {
			var t = this, s = 0, o, st;

			if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint|SelectAll)$/.test(cmd) && (!a || !a.skip_focus))
				t.focus();

			o = {};
			t.onBeforeExecCommand.dispatch(t, cmd, ui, val, o);
			if (o.terminate)
				return false;

			// Command callback
			if (t.execCallback('execcommand_callback', t.id, t.selection.getNode(), cmd, ui, val)) {
				t.onExecCommand.dispatch(t, cmd, ui, val, a);
				return true;
			}

			// Registred commands
			if (o = t.execCommands[cmd]) {
				st = o.func.call(o.scope, ui, val);

				// Fall through on true
				if (st !== true) {
					t.onExecCommand.dispatch(t, cmd, ui, val, a);
					return st;
				}
			}

			// Plugin commands
			each(t.plugins, function(p) {
				if (p.execCommand && p.execCommand(cmd, ui, val)) {
					t.onExecCommand.dispatch(t, cmd, ui, val, a);
					s = 1;
					return false;
				}
			});

			if (s)
				return true;

			// Theme commands
			if (t.theme && t.theme.execCommand && t.theme.execCommand(cmd, ui, val)) {
				t.onExecCommand.dispatch(t, cmd, ui, val, a);
				return true;
			}

			// Editor commands
			if (t.editorCommands.execCommand(cmd, ui, val)) {
				t.onExecCommand.dispatch(t, cmd, ui, val, a);
				return true;
			}

			// Browser commands
			t.getDoc().execCommand(cmd, ui, val);
			t.onExecCommand.dispatch(t, cmd, ui, val, a);
		},

		/**
		 * Returns a command specific state, for example if bold is enabled or not.
		 *
		 * @method queryCommandState
		 * @param {string} cmd Command to query state from.
		 * @return {Boolean} Command specific state, for example if bold is enabled or not.
		 */
		queryCommandState : function(cmd) {
			var t = this, o, s;

			// Is hidden then return undefined
			if (t._isHidden())
				return;

			// Registred commands
			if (o = t.queryStateCommands[cmd]) {
				s = o.func.call(o.scope);

				// Fall though on true
				if (s !== true)
					return s;
			}

			// Registred commands
			o = t.editorCommands.queryCommandState(cmd);
			if (o !== -1)
				return o;

			// Browser commands
			try {
				return this.getDoc().queryCommandState(cmd);
			} catch (ex) {
				// Fails sometimes see bug: 1896577
			}
		},

		/**
		 * Returns a command specific value, for example the current font size.
		 *
		 * @method queryCommandValue
		 * @param {string} c Command to query value from.
		 * @return {Object} Command specific value, for example the current font size.
		 */
		queryCommandValue : function(c) {
			var t = this, o, s;

			// Is hidden then return undefined
			if (t._isHidden())
				return;

			// Registred commands
			if (o = t.queryValueCommands[c]) {
				s = o.func.call(o.scope);

				// Fall though on true
				if (s !== true)
					return s;
			}

			// Registred commands
			o = t.editorCommands.queryCommandValue(c);
			if (is(o))
				return o;

			// Browser commands
			try {
				return this.getDoc().queryCommandValue(c);
			} catch (ex) {
				// Fails sometimes see bug: 1896577
			}
		},

		/**
		 * Shows the editor and hides any textarea/div that the editor is supposed to replace.
		 *
		 * @method show
		 */
		show : function() {
			var t = this;

			DOM.show(t.getContainer());
			DOM.hide(t.id);
			t.load();
		},

		/**
		 * Hides the editor and shows any textarea/div that the editor is supposed to replace.
		 *
		 * @method hide
		 */
		hide : function() {
			var t = this, d = t.getDoc();

			// Fixed bug where IE has a blinking cursor left from the editor
			if (isIE && d)
				d.execCommand('SelectAll');

			// We must save before we hide so Safari doesn't crash
			t.save();
			DOM.hide(t.getContainer());
			DOM.setStyle(t.id, 'display', t.orgDisplay);
		},

		/**
		 * Returns true/false if the editor is hidden or not.
		 *
		 * @method isHidden
		 * @return {Boolean} True/false if the editor is hidden or not.
		 */
		isHidden : function() {
			return !DOM.isHidden(this.id);
		},

		/**
		 * Sets the progress state, this will display a throbber/progess for the editor.
		 * This is ideal for asycronous operations like an AJAX save call.
		 *
		 * @method setProgressState
		 * @param {Boolean} b Boolean state if the progress should be shown or hidden.
		 * @param {Number} ti Optional time to wait before the progress gets shown.
		 * @param {Object} o Optional object to pass to the progress observers.
		 * @return {Boolean} Same as the input state.
		 * @example
		 * // Show progress for the active editor
		 * tinyMCE.activeEditor.setProgressState(true);
		 *
		 * // Hide progress for the active editor
		 * tinyMCE.activeEditor.setProgressState(false);
		 *
		 * // Show progress after 3 seconds
		 * tinyMCE.activeEditor.setProgressState(true, 3000);
		 */
		setProgressState : function(b, ti, o) {
			this.onSetProgressState.dispatch(this, b, ti, o);

			return b;
		},

		/**
		 * Loads contents from the textarea or div element that got converted into an editor instance.
		 * This method will move the contents from that textarea or div into the editor by using setContent
		 * so all events etc that method has will get dispatched as well.
		 *
		 * @method load
		 * @param {Object} o Optional content object, this gets passed around through the whole load process.
		 * @return {String} HTML string that got set into the editor.
		 */
		load : function(o) {
			var t = this, e = t.getElement(), h;

			if (e) {
				o = o || {};
				o.load = true;

				// Double encode existing entities in the value
				// mail-11350 no need to load text, because we set text manually after tinymce init.
				// mail-11350 loading and parsing text here is a waste of time, and it can lead to very long lags
//				h = t.setContent(is(e.value) ? e.value : e.innerHTML, o);
				o.element = e;

				if (!o.no_events)
					t.onLoadContent.dispatch(t, o);

				o.element = e = null;

				return h;
			}
		},

		/**
		 * Saves the contents from a editor out to the textarea or div element that got converted into an editor instance.
		 * This method will move the HTML contents from the editor into that textarea or div by getContent
		 * so all events etc that method has will get dispatched as well.
		 *
		 * @method save
		 * @param {Object} o Optional content object, this gets passed around through the whole save process.
		 * @return {String} HTML string that got set into the textarea/div.
		 */
		save : function(o) {
			var t = this, e = t.getElement(), h, f;

			if (!e || !t.initialized)
				return;

			o = o || {};
			o.save = true;

			// Add undo level will trigger onchange event
			if (!o.no_events) {
				t.undoManager.typing = false;
				t.undoManager.add();
			}

			o.element = e;
			h = o.content = t.getContent(o);

			if (!o.no_events)
				t.onSaveContent.dispatch(t, o);

			h = o.content;

			if (!/TEXTAREA|INPUT/i.test(e.nodeName)) {
				e.innerHTML = h;

				// Update hidden form element
				if (f = DOM.getParent(t.id, 'form')) {
					each(f.elements, function(e) {
						if (e.name == t.id) {
							e.value = h;
							return false;
						}
					});
				}
			} else
				e.value = h;

			o.element = e = null;

			return h;
		},

		/**
		 * Sets the specified content to the editor instance, this will cleanup the content before it gets set using
		 * the different cleanup rules options.
		 *
		 * @method setContent
		 * @param {String} content Content to set to editor, normally HTML contents but can be other formats as well.
		 * @param {Object} args Optional content object, this gets passed around through the whole set process.
		 * @return {String} HTML string that got set into the editor.
		 * @example
		 * // Sets the HTML contents of the activeEditor editor
		 * tinyMCE.activeEditor.setContent('<span>some</span> html');
		 *
		 * // Sets the raw contents of the activeEditor editor
		 * tinyMCE.activeEditor.setContent('<span>some</span> html', {format : 'raw'});
		 *
		 * // Sets the content of a specific editor (my_editor in this example)
		 * tinyMCE.get('my_editor').setContent(data);
		 *
		 * // Sets the bbcode contents of the activeEditor editor if the bbcode plugin was added
		 * tinyMCE.activeEditor.setContent('[b]some[/b] html', {format : 'bbcode'});
		 */
		setContent : function(content, args) {
			var self = this, rootNode, body = self.getBody(), forcedRootBlockName;

			// Setup args object
			args = args || {};
			args.format = args.format || 'html';
			args.set = true;
			args.content = content;

			// Do preprocessing
			if (!args.no_events)
				self.onBeforeSetContent.dispatch(self, args);

			content = args.content;

			// Padd empty content in Gecko and Safari. Commands will otherwise fail on the content
			// It will also be impossible to place the caret in the editor unless there is a BR element present
			if (!tinymce.isIE && (content.length === 0 || /^\s+$/.test(content))) {
				forcedRootBlockName = self.settings.forced_root_block;
				if (forcedRootBlockName)
					content = '<' + forcedRootBlockName + '><br data-mce-bogus="1"></' + forcedRootBlockName + '>';
				else
					content = '<br data-mce-bogus="1">';

//				berkel: MAIL-5013
//				body.innerHTML = content;
//				self.selection.select(body, true);
//				self.selection.collapse(true);
//				return;
			}

			// Parse and serialize the html
			if (args.format !== 'raw') {
				content = new tinymce.html.Serializer({}, self.schema).serialize(
					self.parser.parse(content)
				);
			}

			// Set the new cleaned contents to the editor
			args.content = tinymce.trim(content);
			self.dom.setHTML(body, args.content);

			// Do post processing
			if (!args.no_events)
				self.onSetContent.dispatch(self, args);

			self.selection.normalize();

			return args.content;
		},

		/**
		 * Gets the content from the editor instance, this will cleanup the content before it gets returned using
		 * the different cleanup rules options.
		 *
		 * @method getContent
		 * @param {Object} args Optional content object, this gets passed around through the whole get process.
		 * @return {String} Cleaned content string, normally HTML contents.
		 * @example
		 * // Get the HTML contents of the currently active editor
		 * console.debug(tinyMCE.activeEditor.getContent());
		 *
		 * // Get the raw contents of the currently active editor
		 * tinyMCE.activeEditor.getContent({format : 'raw'});
		 *
		 * // Get content of a specific editor:
		 * tinyMCE.get('content id').getContent()
		 */
		getContent : function(args) {
			var self = this, content;

			// Setup args object
			args = args || {};
			args.format = args.format || 'html';
			args.get = true;

			// Do preprocessing
			if (!args.no_events)
				self.onBeforeGetContent.dispatch(self, args);

			// Get raw contents or by default the cleaned contents
			if (args.format == 'raw')
				content = self.getBody().innerHTML;
			else
				content = self.serializer.serialize(self.getBody(), args);

			args.content = tinymce.trim(content);

			// Do post processing
			if (!args.no_events)
				self.onGetContent.dispatch(self, args);

			return args.content;
		},

		/**
		 * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
		 *
		 * @method isDirty
		 * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
		 * @example
		 * if (tinyMCE.activeEditor.isDirty())
		 *     alert("You must save your contents.");
		 */
		isDirty : function() {
			var self = this;

			return tinymce.trim(self.startContent) != tinymce.trim(self.getContent({format : 'raw', no_events : 1})) && !self.isNotDirty;
		},

		/**
		 * Returns the editors container element. The container element wrappes in
		 * all the elements added to the page for the editor. Such as UI, iframe etc.
		 *
		 * @method getContainer
		 * @return {Element} HTML DOM element for the editor container.
		 */
		getContainer : function() {
			var t = this;

			if (!t.container)
				t.container = DOM.get(t.editorContainer || t.id + '_parent');

			return t.container;
		},

		/**
		 * Returns the editors content area container element. The this element is the one who
		 * holds the iframe or the editable element.
		 *
		 * @method getContentAreaContainer
		 * @return {Element} HTML DOM element for the editor area container.
		 */
		getContentAreaContainer : function() {
			return this.contentAreaContainer;
		},

		/**
		 * Returns the target element/textarea that got replaced with a TinyMCE editor instance.
		 *
		 * @method getElement
		 * @return {Element} HTML DOM element for the replaced element.
		 */
		getElement : function() {
			return DOM.get(this.settings.content_element || this.id);
		},

		/**
		 * Returns the iframes window object.
		 *
		 * @method getWin
		 * @return {Window} Iframe DOM window object.
		 */
		getWin : function() {
			var t = this, e;

			if (!t.contentWindow) {
				e = DOM.get(t.id + "_ifr");

				if (e)
					t.contentWindow = e.contentWindow;
			}

			return t.contentWindow;
		},

		/**
		 * Returns the iframes document object.
		 *
		 * @method getDoc
		 * @return {Document} Iframe DOM document object.
		 */
		getDoc : function() {
			var t = this, w;

			if (!t.contentDocument) {
				w = t.getWin();

				if (w)
					t.contentDocument = w.document;
			}

			return t.contentDocument;
		},

		/**
		 * Returns the iframes body element.
		 *
		 * @method getBody
		 * @return {Element} Iframe body element.
		 */
		getBody : function() {
			return this.bodyElement || this.getDoc().body;
		},

		/**
		 * URL converter function this gets executed each time a user adds an img, a or
		 * any other element that has a URL in it. This will be called both by the DOM and HTML
		 * manipulation functions.
		 *
		 * @method convertURL
		 * @param {string} u URL to convert.
		 * @param {string} n Attribute name src, href etc.
		 * @param {string/HTMLElement} Tag name or HTML DOM element depending on HTML or DOM insert.
		 * @return {string} Converted URL string.
		 */
		convertURL : function(u, n, e) {
			var t = this, s = t.settings;

			// Use callback instead
			if (s.urlconverter_callback)
				return t.execCallback('urlconverter_callback', u, e, true, n);

			// Don't convert link href since thats the CSS files that gets loaded into the editor also skip local file URLs
			if (!s.convert_urls || (e && e.nodeName == 'LINK') || u.indexOf('file:') === 0)
				return u;

			// Convert to relative
			if (s.relative_urls)
				return t.documentBaseURI.toRelative(u);

			// Convert to absolute
			u = t.documentBaseURI.toAbsolute(u, s.remove_script_host);

			return u;
		},

		/**
		 * Adds visual aid for tables, anchors etc so they can be more easily edited inside the editor.
		 *
		 * @method addVisual
		 * @param {Element} e Optional root element to loop though to find tables etc that needs the visual aid.
		 */
		addVisual : function(e) {
			var t = this, s = t.settings;

			e = e || t.getBody();

			if (!is(t.hasVisual))
				t.hasVisual = s.visual;

			each(t.dom.select('table,a', e), function(e) {
				var v;

				switch (e.nodeName) {
					case 'TABLE':
						v = t.dom.getAttrib(e, 'border');

						if (!v || v == '0') {
							if (t.hasVisual)
								t.dom.addClass(e, s.visual_table_class);
							else
								t.dom.removeClass(e, s.visual_table_class);
						}

						return;

					case 'A':
						v = t.dom.getAttrib(e, 'name');

						if (v) {
							if (t.hasVisual)
								t.dom.addClass(e, 'mceItemAnchor');
							else
								t.dom.removeClass(e, 'mceItemAnchor');
						}

						return;
				}
			});

			t.onVisualAid.dispatch(t, e, t.hasVisual);
		},

		/**
		 * Removes the editor from the dom and tinymce collection.
		 *
		 * @method remove
		 */
		remove : function() {
			var t = this, e = t.getContainer();

			t.removed = 1; // Cancels post remove event execution
			t.hide();

			t.execCallback('remove_instance_callback', t);
			t.onRemove.dispatch(t);

			// Clear all execCommand listeners this is required to avoid errors if the editor was removed inside another command
			t.onExecCommand.listeners = [];

			tinymce.remove(t);
			DOM.remove(e);
		},

		/**
		 * Destroys the editor instance by removing all events, element references or other resources
		 * that could leak memory. This method will be called automatically when the page is unloaded
		 * but you can also call it directly if you know what you are doing.
		 *
		 * @method destroy
		 * @param {Boolean} s Optional state if the destroy is an automatic destroy or user called one.
		 */
		destroy : function(s) {
			var t = this;

			// One time is enough
			if (t.destroyed)
				return;

			if (!s) {
				tinymce.removeUnload(t.destroy);
				tinyMCE.onBeforeUnload.remove(t._beforeUnload);

				// Manual destroy
				if (t.theme && t.theme.destroy)
					t.theme.destroy();

				// Destroy controls, selection and dom
				t.controlManager.destroy();
				t.selection.destroy();
				t.dom.destroy();

				// Remove all events

				// Don't clear the window or document if content editable
				// is enabled since other instances might still be present
				if (!t.settings.content_editable) {
					Event.clear(t.getWin());
					Event.clear(t.getDoc());
				}

				Event.clear(t.getBody());
				Event.clear(t.formElement);
			}

			if (t.formElement) {
				t.formElement.submit = t.formElement._mceOldSubmit;
				t.formElement._mceOldSubmit = null;
			}

			t.contentAreaContainer = t.formElement = t.container = t.settings.content_element = t.bodyElement = t.contentDocument = t.contentWindow = null;

			if (t.selection)
				t.selection = t.selection.win = t.selection.dom = t.selection.dom.doc = null;

			t.destroyed = 1;
		},

		// Internal functions

		_addEvents : function() {
			// 'focus', 'blur', 'dblclick', 'beforedeactivate', submit, reset
			var t = this, i, s = t.settings, dom = t.dom, lo = {
				mouseup : 'onMouseUp',
				mousedown : 'onMouseDown',
				click : 'onClick',
				keyup : 'onKeyUp',
				keydown : 'onKeyDown',
				keypress : 'onKeyPress',
//				submit : 'onSubmit',
				reset : 'onReset',
				contextmenu : 'onContextMenu',
				dblclick : 'onDblClick',
				paste : 'onPaste' // Doesn't work in all browsers yet
			};

			function eventHandler(e, o) {
				var ty = e.type;

				// Don't fire events when it's removed
				if (t.removed)
					return;

				// Generic event handler
				if (t.onEvent.dispatch(t, e, o) !== false) {
					// Specific event handler
					t[lo[e.fakeType || e.type]].dispatch(t, e, o);
				}
			};

			// Add DOM events
			each(lo, function(v, k) {
				switch (k) {
					case 'contextmenu':
						dom.bind(t.getDoc(), k, eventHandler);
						break;

					case 'paste':
						dom.bind(t.getBody(), k, function(e) {
							eventHandler(e);
						});
						break;

					case 'submit':
					case 'reset':
						dom.bind(t.getElement().form || DOM.getParent(t.id, 'form'), k, eventHandler);
						break;

					default:
						dom.bind(s.content_editable ? t.getBody() : t.getDoc(), k, eventHandler);
				}
			});

			dom.bind(s.content_editable ? t.getBody() : (isGecko ? t.getDoc() : t.getWin()), 'focus', function(e) {
				t.focus(true);
			});

			// #ifdef contentEditable

			if (s.content_editable && tinymce.isOpera) {
				// Opera doesn't support focus event for contentEditable elements so we need to fake it
				function doFocus(e) {
					t.focus(true);
				};

				dom.bind(t.getBody(), 'click', doFocus);
				dom.bind(t.getBody(), 'keydown', doFocus);
			}

			// #endif

			// Fixes bug where a specified document_base_uri could result in broken images
			// This will also fix drag drop of images in Gecko
			if (tinymce.isGecko) {
				dom.bind(t.getDoc(), 'DOMNodeInserted', function(e) {
					var v;

					e = e.target;

					if (e.nodeType === 1 && e.nodeName === 'IMG' && (v = e.getAttribute('data-mce-src')))
						e.src = t.documentBaseURI.toAbsolute(v);
				});
			}

			// Set various midas options in Gecko
			if (isGecko) {
				function setOpts() {
					var t = this, d = t.getDoc(), s = t.settings;

					if (isGecko && !s.readonly) {
						t._refreshContentEditable();

						try {
							// Try new Gecko method
							d.execCommand("styleWithCSS", 0, false);
						} catch (ex) {
							// Use old method
							if (!t._isHidden())
								try {d.execCommand("useCSS", 0, true);} catch (ex) {}
						}

						if (!s.table_inline_editing)
							try {d.execCommand('enableInlineTableEditing', false, false);} catch (ex) {}

						if (!s.object_resizing)
							try {d.execCommand('enableObjectResizing', false, false);} catch (ex) {}
					}
				};

				t.onBeforeExecCommand.add(setOpts);
				t.onMouseDown.add(setOpts);
			}

			// Add node change handlers
			t.onMouseUp.add(t.nodeChanged);
			//t.onClick.add(t.nodeChanged);
			t.onKeyUp.add(function(ed, e) {
				var c = e.keyCode;

				if ((c >= 33 && c <= 36) || (c >= 37 && c <= 40) || c == 13 || c == 45 || c == 46 || c == 8 || (tinymce.isMac && (c == 91 || c == 93)) || e.ctrlKey)
					t.nodeChanged();
			});


			// Add block quote deletion handler
			t.onKeyDown.add(function(ed, e) {
				// Was the BACKSPACE key pressed?
				if (e.keyCode != 8)
					return;

				var n = ed.selection.getRng().startContainer;
				var offset = ed.selection.getRng().startOffset;

				while (n && n.nodeType && n.nodeType != 1 && n.parentNode)
					n = n.parentNode;

				// Is the cursor at the beginning of a blockquote?
				if (n && n.parentNode && n.parentNode.tagName === 'BLOCKQUOTE' && n.parentNode.firstChild == n && offset == 0) {
					// Remove the blockquote
					ed.formatter.toggle('blockquote', null, n.parentNode);

					// Move the caret to the beginning of n
					var rng = ed.selection.getRng();
					rng.setStart(n, 0);
					rng.setEnd(n, 0);
					ed.selection.setRng(rng);
					ed.selection.collapse(false);
				}
			});



			// Add reset handler
			t.onReset.add(function() {
				t.setContent(t.startContent, {format : 'raw'});
			});

			// Add shortcuts
			if (s.custom_shortcuts) {
				if (s.custom_undo_redo_keyboard_shortcuts) {
					t.addShortcut('ctrl+z', t.getLang('undo_desc'), 'Undo');
					t.addShortcut('ctrl+y', t.getLang('redo_desc'), 'Redo');
				}

				// Add default shortcuts for gecko
				t.addShortcut('ctrl+b', t.getLang('bold_desc'), 'Bold');
				t.addShortcut('ctrl+i', t.getLang('italic_desc'), 'Italic');
				t.addShortcut('ctrl+u', t.getLang('underline_desc'), 'Underline');

//				berkel: MAIL-1096
				// BlockFormat shortcuts keys
//				for (i=1; i<=6; i++)
//					t.addShortcut('ctrl+' + i, '', ['FormatBlock', false, 'h' + i]);

//				t.addShortcut('ctrl+7', '', ['FormatBlock', false, 'p']);
//				t.addShortcut('ctrl+8', '', ['FormatBlock', false, 'div']);
//				t.addShortcut('ctrl+9', '', ['FormatBlock', false, 'address']);

				function find(e) {
					var v = null;

					if (!e.altKey && !e.ctrlKey && !e.metaKey)
						return v;

					each(t.shortcuts, function(o) {
						if (tinymce.isMac && o.ctrl != e.metaKey)
							return;
						else if (!tinymce.isMac && o.ctrl != e.ctrlKey)
							return;

						if (o.alt != e.altKey)
							return;

						if (o.shift != e.shiftKey)
							return;

						if (e.keyCode == o.keyCode || (e.charCode && e.charCode == o.charCode)) {
							v = o;
							return false;
						}
					});

					return v;
				};

				t.onKeyUp.add(function(ed, e) {
					var o = find(e);

					if (o)
						return Event.cancel(e);
				});

				t.onKeyPress.add(function(ed, e) {
					var o = find(e);

					if (o)
						return Event.cancel(e);
				});

				t.onKeyDown.add(function(ed, e) {
					var o = find(e);

					if (o) {
						o.func.call(o.scope);
						return Event.cancel(e);
					}
				});
			}

			if (tinymce.isIE) {
				// Fix so resize will only update the width and height attributes not the styles of an image
				// It will also block mceItemNoResize items
				dom.bind(t.getDoc(), 'controlselect', function(e) {
					var re = t.resizeInfo, cb;

					e = e.target;

					// Don't do this action for non image elements
					if (e.nodeName !== 'IMG')
						return;

					if (re)
						dom.unbind(re.node, re.ev, re.cb);

					if (!dom.hasClass(e, 'mceItemNoResize')) {
						ev = 'resizeend';
						cb = dom.bind(e, ev, function(e) {
							var v;

							e = e.target;

							if (v = dom.getStyle(e, 'width')) {
								dom.setAttrib(e, 'width', v.replace(/[^0-9%]+/g, ''));
								dom.setStyle(e, 'width', '');
							}

							if (v = dom.getStyle(e, 'height')) {
								dom.setAttrib(e, 'height', v.replace(/[^0-9%]+/g, ''));
								dom.setStyle(e, 'height', '');
							}
						});
					} else {
						ev = 'resizestart';
						cb = dom.bind(e, 'resizestart', Event.cancel, Event);
					}

					re = t.resizeInfo = {
						node : e,
						ev : ev,
						cb : cb
					};
				});
			}

			if (tinymce.isOpera) {
				t.onClick.add(function(ed, e) {
					Event.prevent(e);
				});
			}

			// Add custom undo/redo handlers
			if (s.custom_undo_redo) {
				function addUndo() {
					t.undoManager.typing = false;
					t.undoManager.add();
				};

				dom.bind(t.getDoc(), 'focusout', function(e) {
					if (!t.removed && t.undoManager.typing)
						addUndo();
				});

				// Add undo level when contents is drag/dropped within the editor
				t.dom.bind(t.dom.getRoot(), 'dragend', function(e) {
					addUndo();
				});

				t.onKeyUp.add(function(ed, e) {
					var keyCode = e.keyCode;

					if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 13 || keyCode == 45 || e.ctrlKey)
						addUndo();
				});

				t.onKeyDown.add(function(ed, e) {
					var keyCode = e.keyCode, sel;

					if (keyCode == 8) {
						sel = t.getDoc().selection;

						// Fix IE control + backspace browser bug
						if (sel && sel.createRange && sel.createRange().item) {
							t.undoManager.beforeChange();
							ed.dom.remove(sel.createRange().item(0));
							addUndo();

							return Event.cancel(e);
						}
					}

					// Is caracter positon keys left,right,up,down,home,end,pgdown,pgup,enter
					if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 13 || keyCode == 45) {
						// Add position before enter key is pressed, used by IE since it still uses the default browser behavior
						// Todo: Remove this once we normalize enter behavior on IE
						if (tinymce.isIE && keyCode == 13)
							t.undoManager.beforeChange();

						if (t.undoManager.typing)
							addUndo();

						return;
					}

					// If key isn't shift,ctrl,alt,capslock,metakey
					if ((keyCode < 16 || keyCode > 20) && keyCode != 224 && keyCode != 91 && !t.undoManager.typing) {
						t.undoManager.beforeChange();
						t.undoManager.typing = true;
						t.undoManager.add();
					}
				});

				t.onMouseDown.add(function() {
					if (t.undoManager.typing)
						addUndo();
				});
			}

			// Fire a nodeChanged when the selection is changed on WebKit this fixes selection issues on iOS5
			// It only fires the nodeChange event every 50ms since it would other wise update the UI when you type and it hogs the CPU
			if (tinymce.isWebKit) {
				dom.bind(t.getDoc(), 'selectionchange', function() {
					if (t.selectionTimer) {
						clearTimeout(t.selectionTimer);
						t.selectionTimer = 0;
					}

					t.selectionTimer = window.setTimeout(function() {
						t.nodeChanged();
					}, 50);
				});
			}

			// Bug fix for FireFox keeping styles from end of selection instead of start.
			if (tinymce.isGecko) {
				function getAttributeApplyFunction() {
					var template = t.dom.getAttribs(t.selection.getStart().cloneNode(false));

					return function() {
						var target = t.selection.getStart();

						if (target !== t.getBody()) {
							t.dom.removeAllAttribs(target);

							each(template, function(attr) {
								target.setAttributeNode(attr.cloneNode(true));
							});
						}
					};
				}

				function isSelectionAcrossElements() {
					var s = t.selection;

					return !s.isCollapsed() && s.getStart() != s.getEnd();
				}

				t.onKeyPress.add(function(ed, e) {
					var applyAttributes;

					if ((e.keyCode == 8 || e.keyCode == 46) && isSelectionAcrossElements()) {
						applyAttributes = getAttributeApplyFunction();
						t.getDoc().execCommand('delete', false, null);
						applyAttributes();

						return Event.cancel(e);
					}
				});

				t.dom.bind(t.getDoc(), 'cut', function(e) {
					var applyAttributes;

					if (isSelectionAcrossElements()) {
						applyAttributes = getAttributeApplyFunction();
						t.onKeyUp.addToTop(Event.cancel, Event);

						setTimeout(function() {
							applyAttributes();
							t.onKeyUp.remove(Event.cancel, Event);
						}, 0);
					}
				});
			}
		},

		_refreshContentEditable : function() {
			var self = this, body, parent;

			// Check if the editor was hidden and the re-initalize contentEditable mode by removing and adding the body again
			if (self._isHidden()) {
				body = self.getBody();
				parent = body.parentNode;

				parent.removeChild(body);
				parent.appendChild(body);

				body.focus();
			}
		},

		_isHidden : function() {
			var s;

			if (!isGecko)
				return 0;

			// Weird, wheres that cursor selection?
			s = this.selection.getSel();
			return (!s || !s.rangeCount || s.rangeCount == 0);
		}
	});
})(tinymce);
/**
 * EditorCommands.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	// Added for compression purposes
	var each = tinymce.each, undefined, TRUE = true, FALSE = false;

	/**
	 * This class enables you to add custom editor commands and it contains
	 * overrides for native browser commands to address various bugs and issues.
	 *
	 * @class tinymce.EditorCommands
	 */
	tinymce.EditorCommands = function(editor) {
		var dom = editor.dom,
			selection = editor.selection,
			commands = {state: {}, exec : {}, value : {}},
			settings = editor.settings,
			formatter = editor.formatter,
			bookmark;

		/**
		 * Executes the specified command.
		 *
		 * @method execCommand
		 * @param {String} command Command to execute.
		 * @param {Boolean} ui Optional user interface state.
		 * @param {Object} value Optional value for command.
		 * @return {Boolean} true/false if the command was found or not.
		 */
		function execCommand(command, ui, value) {
			var func;

			command = command.toLowerCase();
			if (func = commands.exec[command]) {
				func(command, ui, value);
				return TRUE;
			}

			return FALSE;
		};

		/**
		 * Queries the current state for a command for example if the current selection is "bold".
		 *
		 * @method queryCommandState
		 * @param {String} command Command to check the state of.
		 * @return {Boolean/Number} true/false if the selected contents is bold or not, -1 if it's not found.
		 */
		function queryCommandState(command) {
			var func;

			command = command.toLowerCase();
			if (func = commands.state[command])
				return func(command);

			return -1;
		};

		/**
		 * Queries the command value for example the current fontsize.
		 *
		 * @method queryCommandValue
		 * @param {String} command Command to check the value of.
		 * @return {Object} Command value of false if it's not found.
		 */
		function queryCommandValue(command) {
			var func;

			command = command.toLowerCase();
			if (func = commands.value[command])
				return func(command);

			return FALSE;
		};

		/**
		 * Adds commands to the command collection.
		 *
		 * @method addCommands
		 * @param {Object} command_list Name/value collection with commands to add, the names can also be comma separated.
		 * @param {String} type Optional type to add, defaults to exec. Can be value or state as well.
		 */
		function addCommands(command_list, type) {
			type = type || 'exec';

			each(command_list, function(callback, command) {
				each(command.toLowerCase().split(','), function(command) {
					commands[type][command] = callback;
				});
			});
		};

		// Expose public methods
		tinymce.extend(this, {
			execCommand : execCommand,
			queryCommandState : queryCommandState,
			queryCommandValue : queryCommandValue,
			addCommands : addCommands
		});

		// Private methods

		function execNativeCommand(command, ui, value) {
			if (ui === undefined)
				ui = FALSE;

			if (value === undefined)
				value = null;

			return editor.getDoc().execCommand(command, ui, value);
		};

		function isFormatMatch(name) {
			return formatter.match(name);
		};

		function toggleFormat(name, value) {
			formatter.toggle(name, value ? {value : value} : undefined);
		};

	function storeSelection(type) {
			bookmark = selection.getBookmark(type);
		};

		function restoreSelection() {
			selection.moveToBookmark(bookmark);
		};

		// Add execCommand overrides
		addCommands({
			// Ignore these, added for compatibility
			'mceResetDesignMode,mceBeginUndoLevel' : function() {},

			// Add undo manager logic
			'mceEndUndoLevel,mceAddUndoLevel' : function() {
				editor.undoManager.add();
			},

			'Cut,Copy,Paste' : function(command) {
				var doc = editor.getDoc(), failed;

				// Try executing the native command
				try {
					execNativeCommand(command);
				} catch (ex) {
					// Command failed
					failed = TRUE;
				}

				// Present alert message about clipboard access not being available
				if (failed || !doc.queryCommandSupported(command)) {
					if (tinymce.isGecko) {
						editor.windowManager.confirm(editor.getLang('clipboard_msg'), function(state) {
							if (state)
								open('http://www.mozilla.org/editor/midasdemo/securityprefs.html', '_blank');
						});
					} else
						editor.windowManager.alert(editor.getLang('clipboard_no_support'));
				}
			},

			// Override unlink command
			unlink : function(command) {
				if (selection.isCollapsed())
					selection.select(selection.getNode());

				execNativeCommand(command);
				selection.collapse(FALSE);
			},

			// Override justify commands to use the text formatter engine
			'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull' : function(command) {
				var align = command.substring(7);

				if (!selection.getSelectedBlocks().length)
					toggleFormat('div');

				// Remove all other alignments first
				each('left,center,right,full'.split(','), function(name) {
					if (align != name)
						formatter.remove('align' + name);
				});

				toggleFormat('align' + align);
				execCommand('mceRepaint');
			},

			// Override list commands to fix WebKit bug
			'InsertUnorderedList,InsertOrderedList' : function(command) {
				var listElm, listParent;

				execNativeCommand(command);

				// WebKit produces lists within block elements so we need to split them
				// we will replace the native list creation logic to custom logic later on
				// TODO: Remove this when the list creation logic is removed
				listElm = dom.getParent(selection.getNode(), 'ol,ul');
				if (listElm) {
					listParent = listElm.parentNode;

					// If list is within a text block then split that block
					if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
						storeSelection();
						dom.split(listParent, listElm);
						restoreSelection();
					}
				}
			},

			// Override commands to use the text formatter engine
			'Bold,Italic,Underline,Strikethrough,Superscript,Subscript' : function(command) {
				toggleFormat(command);
			},

			// Override commands to use the text formatter engine
			'FontName' : function(command, ui, value) {
				toggleFormat(command, value);
			},

			'ForeColor,HiliteColor': function(command, ui, value)
			{
				toggleFormat(command, value);

				if (value == 'transparent') {
					var o = {
						'hilitecolor': 'backgroundColor',
						'forecolor': 'color'
					};

					storeSelection();

					var n = tinymce.isIE ? selection.getNode().parentNode : selection.getNode();
					each(dom.select('span', dom.getParent(n, 'span')), function(node){

						if (dom.getStyle(node, o[command]) == 'transparent') {
							each(dom.getParents(node.parentNode, 'span'), function(parent){
								if (dom.getStyle(parent, o[command]))
									dom.split(parent, node);
							});

							if (dom.getAttrib(node, 'style', '').split(';').length < 3)
								dom.remove(node, true);
						}
					});

					restoreSelection();
				}
			},

			FontSize : function(command, ui, value) {
				var fontClasses, fontSizes;

				// Convert font size 1-7 to styles
				if (value >= 1 && value <= 7) {
					fontSizes = tinymce.explode(settings.font_size_style_values);
					fontClasses = tinymce.explode(settings.font_size_classes);

					if (fontClasses)
						value = fontClasses[value - 1] || value;
					else
						value = fontSizes[value - 1] || value;
				}

				toggleFormat(command, value);
			},

			RemoveFormat : function(command) {
				formatter.remove(command);
			},

			mceBlockQuote : function(command) {
				toggleFormat('blockquote');
			},

			FormatBlock : function(command, ui, value) {
				return toggleFormat(value || 'p');
			},

			mceCleanup : function() {
				var bookmark = selection.getBookmark();

				editor.setContent(editor.getContent({cleanup : TRUE}), {cleanup : TRUE});

				selection.moveToBookmark(bookmark);
			},

			mceRemoveNode : function(command, ui, value) {
				var node = value || selection.getNode();

				// Make sure that the body node isn't removed
				if (node != editor.getBody()) {
					storeSelection();
					editor.dom.remove(node, TRUE);
					restoreSelection();
				}
			},

			mceSelectNodeDepth : function(command, ui, value) {
				var counter = 0;

				dom.getParent(selection.getNode(), function(node) {
					if (node.nodeType == 1 && counter++ == value) {
						selection.select(node);
						return FALSE;
					}
				}, editor.getBody());
			},

			mceSelectNode : function(command, ui, value) {
				selection.select(value);
			},

			mceInsertContent : function(command, ui, value) {
				var parser, serializer, parentNode, rootNode, fragment, args,
					marker, nodeRect, viewPortRect, rng, node, node2, bookmarkHtml, viewportBodyElement;

				// Setup parser and serializer
				parser = editor.parser;
				serializer = new tinymce.html.Serializer({}, editor.schema);
				bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">\uFEFF</span>';

				// Run beforeSetContent handlers on the HTML to be inserted
				args = {content: value, format: 'html'};
				selection.onBeforeSetContent.dispatch(selection, args);
				value = args.content;

				// Add caret at end of contents if it's missing
				if (value.indexOf('{$caret}') == -1)
					value += '{$caret}';

				// Replace the caret marker with a span bookmark element
				value = value.replace(/\{\$caret\}/, bookmarkHtml);

				// Insert node maker where we will insert the new HTML and get it's parent
				if (!selection.isCollapsed())
					editor.getDoc().execCommand('Delete', false, null);

				parentNode = selection.getNode();

				// Parse the fragment within the context of the parent node
				args = {context : parentNode.nodeName.toLowerCase()};
				fragment = parser.parse(value, args);

				// Move the caret to a more suitable location
				node = fragment.lastChild;
				if (node.attr('id') == 'mce_marker') {
					marker = node;

					for (node = node.prev; node; node = node.walk(true)) {
						if (node.type == 3 || !dom.isBlock(node.name)) {
							node.parent.insert(marker, node, node.name === 'br');
							break;
						}
					}
				}

				// If parser says valid we can insert the contents into that parent
				if (!args.invalid) {
					value = serializer.serialize(fragment);

					// Check if parent is empty or only has one BR element then set the innerHTML of that parent
					node = parentNode.firstChild;
					node2 = parentNode.lastChild;
					if (!node || (node === node2 && node.nodeName === 'BR'))
						dom.setHTML(parentNode, value);
					else
						selection.setContent(value);
				} else {
					// If the fragment was invalid within that context then we need
					// to parse and process the parent it's inserted into

					// Insert bookmark node and get the parent
					selection.setContent(bookmarkHtml);
					parentNode = editor.selection.getNode();
					rootNode = editor.getBody();

					// Opera will return the document node when selection is in root
					if (parentNode.nodeType == 9)
						parentNode = node = rootNode;
					else
						node = parentNode;

					// Find the ancestor just before the root element
					while (node !== rootNode) {
						parentNode = node;
						node = node.parentNode;
					}

					// Get the outer/inner HTML depending on if we are in the root and parser and serialize that
					value = parentNode == rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
					value = serializer.serialize(
						parser.parse(
							// Need to replace by using a function since $ in the contents would otherwise be a problem
							value.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function() {
								return serializer.serialize(fragment);
							})
						)
					);

					// Set the inner/outer HTML depending on if we are in the root or not
					if (parentNode == rootNode)
						dom.setHTML(rootNode, value);
					else
						dom.setOuterHTML(parentNode, value);
				}

				marker = dom.get('mce_marker');

				// Scroll range into view scrollIntoView on element can't be used since it will scroll the main view port as well
				nodeRect = dom.getRect(marker);
				viewPortRect = dom.getViewPort(editor.getWin());

				// Check if node is out side the viewport if it is then scroll to it
				if ((nodeRect.y + nodeRect.h > viewPortRect.y + viewPortRect.h || nodeRect.y < viewPortRect.y) ||
					(nodeRect.x > viewPortRect.x + viewPortRect.w || nodeRect.x < viewPortRect.x)) {
					viewportBodyElement = tinymce.isIE ? editor.getDoc().documentElement : editor.getBody();
					viewportBodyElement.scrollLeft = nodeRect.x;
					viewportBodyElement.scrollTop = nodeRect.y - viewPortRect.h + 25;
				}

				// Move selection before marker and remove it
				rng = dom.createRng();

				// If previous sibling is a text node set the selection to the end of that node
				node = marker.previousSibling;
				if (node && node.nodeType == 3) {
					rng.setStart(node, node.nodeValue.length);
				} else {
					// If the previous sibling isn't a text node or doesn't exist set the selection before the marker node
					rng.setStartBefore(marker);
					rng.setEndBefore(marker);
				}

				// Remove the marker node and set the new range
				dom.remove(marker);
				selection.setRng(rng);

				// Dispatch after event and add any visual elements needed
				selection.onSetContent.dispatch(selection, args);
				editor.addVisual();
			},

			mceInsertRawHTML : function(command, ui, value) {
				selection.setContent('tiny_mce_marker');
				editor.setContent(editor.getContent().replace(/tiny_mce_marker/g, function() { return value }));
			},

			mceSetContent : function(command, ui, value) {
				editor.setContent(value);
			},

			'Indent,Outdent' : function(command) {
				var intentValue, indentUnit, value;

				// Setup indent level
				intentValue = settings.indentation;
				indentUnit = /[a-z%]+$/i.exec(intentValue);
				intentValue = parseInt(intentValue);

				if (!selection.getSelectedBlocks().length)
					toggleFormat('div');

				var liParent = dom.getParent(selection.getNode(), 'UL,OL');

				if (!queryCommandState('InsertUnorderedList') && !queryCommandState('InsertOrderedList')) {
					each(selection.getSelectedBlocks(), function(element) {
						if (command == 'outdent') {
							value = Math.max(0, parseInt(element.style.paddingLeft || 0) - intentValue);
							dom.setStyle(element, 'paddingLeft', value ? value + indentUnit : '');
						} else {
							dom.setStyle(element, 'paddingLeft', (parseInt(element.style.paddingLeft || 0) + intentValue) + indentUnit);
						}
					});
				} else if (dom.select('li', liParent).length == 1) {
					if (command == 'outdent') {
						value = Math.max(0, parseInt(liParent.style.marginLeft || 0) - intentValue);
						dom.setStyle(liParent, 'marginLeft', value ? value + indentUnit : '');
					} else {
						dom.setStyle(liParent, 'marginLeft', (parseInt(liParent.style.marginLeft || 0) + intentValue) + indentUnit);
					}
				} else {
					execNativeCommand(command);
				}
			},

			mceRepaint : function() {
				var bookmark;

				if (tinymce.isGecko) {
					try {
						storeSelection(TRUE);

						if (selection.getSel())
							selection.getSel().selectAllChildren(editor.getBody());

						selection.collapse(TRUE);
						restoreSelection();
					} catch (ex) {
						// Ignore
					}
				}
			},

			mceToggleFormat : function(command, ui, value) {
				formatter.toggle(value);
			},

			InsertHorizontalRule : function() {
				editor.execCommand('mceInsertContent', false, '<hr />');
			},

			mceToggleVisualAid : function() {
				editor.hasVisual = !editor.hasVisual;
				editor.addVisual();
			},

			mceReplaceContent : function(command, ui, value) {
				editor.execCommand('mceInsertContent', false, value.replace(/\{\$selection\}/g, selection.getContent({format : 'text'})));
			},

			mceInsertLink : function(command, ui, value) {
				var anchor;

				if (typeof(value) == 'string')
					value = {href : value};

				anchor = dom.getParent(selection.getNode(), 'a');

				// Spaces are never valid in URLs and it's a very common mistake for people to make so we fix it here.
				value.href = value.href.replace(' ', '%20');

				// Remove existing links if there could be child links or that the href isn't specified
				if (!anchor || !value.href) {
					formatter.remove('link');
				}

				// Apply new link to selection
				if (value.href) {
					formatter.apply('link', value, anchor);
				}
			},

			selectAll : function() {
				var root = dom.getRoot(), rng = dom.createRng();

				rng.setStart(root, 0);
				rng.setEnd(root, root.childNodes.length);

				editor.selection.setRng(rng);
			}
		});

		// Add queryCommandState overrides
		addCommands({
			// Override justify commands
			'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull' : function(command) {
				return isFormatMatch('align' + command.substring(7));
			},

			'JustifySelect' : function() {
                return isFormatMatch('alignleft') ||
                    isFormatMatch('aligncenter') ||
                    isFormatMatch('alignright');
			},

			'Bold,Italic,Underline,Strikethrough,Superscript,Subscript' : function(command) {
				return isFormatMatch(command);
			},

			mceBlockQuote : function() {
				return isFormatMatch('blockquote');
			},

			Outdent : function() {
				var node;

				if (settings.inline_styles) {
					if ((node = dom.getParent(selection.getStart(), dom.isBlock)) && parseInt(node.style.paddingLeft) > 0)
						return TRUE;

					if ((node = dom.getParent(selection.getEnd(), dom.isBlock)) && parseInt(node.style.paddingLeft) > 0)
						return TRUE;
				}

				return queryCommandState('InsertUnorderedList') || queryCommandState('InsertOrderedList') || (!settings.inline_styles && !!dom.getParent(selection.getNode(), 'BLOCKQUOTE'));
			},

			'InsertUnorderedList,InsertOrderedList' : function(command) {
				return dom.getParent(selection.getNode(), command == 'insertunorderedlist' ? 'UL' : 'OL');
			}
		}, 'state');

		// Add queryCommandValue overrides
		addCommands({
			'FontSize,FontName' : function(command) {
				var value = 0, parent;

				if (parent = dom.getParent(selection.getNode(), 'span')) {
					if (command == 'fontsize')
						value = parent.style.fontSize;
					else
						value = parent.style.fontFamily.replace(/, /g, ',').replace(/[\'\"]/g, '').toLowerCase();
				}

				return value;
			}
		}, 'value');

		// Add undo manager logic
		if (settings.custom_undo_redo) {
			addCommands({
				Undo : function() {
					editor.undoManager.undo();
				},

				Redo : function() {
					editor.undoManager.redo();
				}
			});
		}
	};
})(tinymce);
/**
 * UndoManager.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var Dispatcher = tinymce.util.Dispatcher;

	/**
	 * This class handles the undo/redo history levels for the editor. Since the build in undo/redo has major drawbacks a custom one was needed.
	 *
	 * @class tinymce.UndoManager
	 */
	tinymce.UndoManager = function(editor) {
		var self, index = 0, data = [], beforeBookmark;

		function getContent() {
			return tinymce.trim(editor.getContent({format : 'raw', no_events : 1}));
		};

		return self = {
			/**
			 * State if the user is currently typing or not. This will add a typing operation into one undo
			 * level instead of one new level for each keystroke.
			 *
			 * @field {Boolean} typing
			 */
			typing : false,

			/**
			 * This event will fire each time a new undo level is added to the undo manager.
			 *
			 * @event onAdd
			 * @param {tinymce.UndoManager} sender UndoManager instance that got the new level.
			 * @param {Object} level The new level object containing a bookmark and contents.
			 */
			onAdd : new Dispatcher(self),

			/**
			 * This event will fire when the user make an undo of a change.
			 *
			 * @event onUndo
			 * @param {tinymce.UndoManager} sender UndoManager instance that got the new level.
			 * @param {Object} level The old level object containing a bookmark and contents.
			 */
			onUndo : new Dispatcher(self),

			/**
			 * This event will fire when the user make an redo of a change.
			 *
			 * @event onRedo
			 * @param {tinymce.UndoManager} sender UndoManager instance that got the new level.
			 * @param {Object} level The old level object containing a bookmark and contents.
			 */
			onRedo : new Dispatcher(self),

			/**
			 * Stores away a bookmark to be used when performing an undo action so that the selection is before
			 * the change has been made.
			 *
			 * @method beforeChange
			 */
			beforeChange : function() {
				beforeBookmark = editor.selection.getBookmark(2, true);
			},

			/**
			 * Adds a new undo level/snapshot to the undo list.
			 *
			 * @method add
			 * @param {Object} l Optional undo level object to add.
			 * @return {Object} Undo level that got added or null it a level wasn't needed.
			 */
			add : function(level) {
				var i, settings = editor.settings, lastLevel;

				level = level || {};
				level.content = getContent();

				// Add undo level if needed
				lastLevel = data[index];
				if (lastLevel && lastLevel.content == level.content)
					return null;

				// Set before bookmark on previous level
				if (data[index])
					data[index].beforeBookmark = beforeBookmark;

				// Time to compress
				if (settings.custom_undo_redo_levels) {
					if (data.length > settings.custom_undo_redo_levels) {
						for (i = 0; i < data.length - 1; i++)
							data[i] = data[i + 1];

						data.length--;
						index = data.length;
					}
				}

				// Get a non intrusive normalized bookmark
				level.bookmark = editor.selection.getBookmark(2, true);

				// Crop array if needed
				if (index < data.length - 1)
					data.length = index + 1;

				data.push(level);
				index = data.length - 1;

				self.onAdd.dispatch(self, level);
				editor.isNotDirty = 0;

				return level;
			},

			/**
			 * Undoes the last action.
			 *
			 * @method undo
			 * @return {Object} Undo level or null if no undo was performed.
			 */
			undo : function() {
				var level, i;

				if (self.typing) {
					self.add();
					self.typing = false;
				}

				if (index > 0) {
					level = data[--index];

					editor.setContent(level.content, {format : 'raw'});
					editor.selection.moveToBookmark(level.beforeBookmark);

					self.onUndo.dispatch(self, level);
				}

				return level;
			},

			/**
			 * Redoes the last action.
			 *
			 * @method redo
			 * @return {Object} Redo level or null if no redo was performed.
			 */
			redo : function() {
				var level;

				if (index < data.length - 1) {
					level = data[++index];

					editor.setContent(level.content, {format : 'raw'});
					editor.selection.moveToBookmark(level.bookmark);

					self.onRedo.dispatch(self, level);
				}

				return level;
			},

			/**
			 * Removes all undo levels.
			 *
			 * @method clear
			 */
			clear : function() {
				data = [];
				index = 0;
				self.typing = false;
			},

			/**
			 * Returns true/false if the undo manager has any undo levels.
			 *
			 * @method hasUndo
			 * @return {Boolean} true/false if the undo manager has any undo levels.
			 */
			hasUndo : function() {
				return index > 0 || this.typing;
			},

			/**
			 * Returns true/false if the undo manager has any redo levels.
			 *
			 * @method hasRedo
			 * @return {Boolean} true/false if the undo manager has any redo levels.
			 */
			hasRedo : function() {
				return index < data.length - 1 && !this.typing;
			}
		};
	};
})(tinymce);
/**
 * ForceBlocks.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	// Shorten names
	var Event = tinymce.dom.Event,
		isIE = tinymce.isIE,
		isGecko = tinymce.isGecko,
		isOpera = tinymce.isOpera,
		each = tinymce.each,
		extend = tinymce.extend,
		TRUE = true,
		FALSE = false;

	function cloneFormats(node) {
		var clone, temp, inner;

		do {
			if (/^(SPAN|STRONG|B|EM|I|FONT|STRIKE|U)$/.test(node.nodeName)) {
				if (clone) {
					temp = node.cloneNode(false);
					temp.appendChild(clone);
					clone = temp;
				} else {
					clone = inner = node.cloneNode(false);
				}

				clone.removeAttribute('id');
			}
		} while (node = node.parentNode);

		if (clone)
			return {wrapper : clone, inner : inner};
	};

	// Checks if the selection/caret is at the end of the specified block element
	function isAtEnd(rng, par) {
		var rng2 = par.ownerDocument.createRange();

		rng2.setStart(rng.endContainer, rng.endOffset);
		rng2.setEndAfter(par);

		// Get number of characters to the right of the cursor if it's zero then we are at the end and need to merge the next block element
		return rng2.cloneContents().textContent.length == 0;
	};

	function splitList(selection, dom, li) {
		var listBlock, block;

		if (dom.isEmpty(li)) {
			listBlock = dom.getParent(li, 'ul,ol');

			if (!dom.getParent(listBlock.parentNode, 'ul,ol')) {
				dom.split(listBlock, li);
				block = dom.create('p', 0, '<br data-mce-bogus="1" />');
				dom.replace(block, li);
				selection.select(block, 1);
			}

			return FALSE;
		}

		return TRUE;
	};

	/**
	 * This is a internal class and no method in this class should be called directly form the out side.
	 */
	tinymce.create('tinymce.ForceBlocks', {
		ForceBlocks : function(ed) {
			var t = this, s = ed.settings, elm;

			t.editor = ed;
			t.dom = ed.dom;
			elm = (s.forced_root_block || 'p').toLowerCase();
			s.element = elm.toUpperCase();

			ed.onPreInit.add(t.setup, t);
		},

		setup : function() {
			var t = this, ed = t.editor, s = ed.settings, dom = ed.dom, selection = ed.selection, blockElements = ed.schema.getBlockElements();

			// Force root blocks
			if (s.forced_root_block) {
				function addRootBlocks() {
					var node = selection.getStart(), rootNode = ed.getBody(), rng, startContainer, startOffset, endContainer, endOffset, rootBlockNode, tempNode, offset = -0xFFFFFF;

					if (!node || node.nodeType !== 1)
						return;

					// Check if node is wrapped in block
					while (node != rootNode) {
						if (blockElements[node.nodeName])
							return;

						node = node.parentNode;
					}

					// Get current selection
					rng = selection.getRng();
					if (rng.setStart) {
						startContainer = rng.startContainer;
						startOffset = rng.startOffset;
						endContainer = rng.endContainer;
						endOffset = rng.endOffset;
					} else {
						// Force control range into text range
						if (rng.item) {
							rng = ed.getDoc().body.createTextRange();
							rng.moveToElementText(rng.item(0));
						}

						tmpRng = rng.duplicate();
						tmpRng.collapse(true);
						startOffset = tmpRng.move('character', offset) * -1;

						if (!tmpRng.collapsed) {
							tmpRng = rng.duplicate();
							tmpRng.collapse(false);
							endOffset = (tmpRng.move('character', offset) * -1) - startOffset;
						}
					}

					// Wrap non block elements and text nodes
					for (node = rootNode.firstChild; node; node) {
						if (node.nodeType === 3 || (node.nodeType == 1 && !blockElements[node.nodeName])) {
							if (!rootBlockNode) {
								rootBlockNode = dom.create(s.forced_root_block);
								node.parentNode.insertBefore(rootBlockNode, node);
							}

							tempNode = node;
							node = node.nextSibling;
							rootBlockNode.appendChild(tempNode);
						} else {
							rootBlockNode = null;
							node = node.nextSibling;
						}
					}

					if (rng.setStart) {
						rng.setStart(startContainer, startOffset);
						rng.setEnd(endContainer, endOffset);
						selection.setRng(rng);
					} else {
						try {
							rng = ed.getDoc().body.createTextRange();
							rng.moveToElementText(rootNode);
							rng.collapse(true);
							rng.moveStart('character', startOffset);

							if (endOffset > 0)
								rng.moveEnd('character', endOffset);

							rng.select();
						} catch (ex) {
							// Ignore
						}
					}

					ed.nodeChanged();
				};

				ed.onKeyUp.add(addRootBlocks);
				ed.onClick.add(addRootBlocks);
			}

			if (s.force_br_newlines) {
				// Force IE to produce BRs on enter
				if (isIE) {
					ed.onKeyPress.add(function(ed, e) {
						var n;

						if (e.keyCode == 13 && selection.getNode().nodeName != 'LI') {
							selection.setContent('<br id="__" /> ', {format : 'raw'});
							n = dom.get('__');
							n.removeAttribute('id');
							selection.select(n);
							selection.collapse();
							return Event.cancel(e);
						}
					});
				}
				else if (isOpera) {
					ed.onKeyPress.add(function(ed, e) {
						if (e.keyCode == 13 && !e.shiftKey && selection.getNode().nodeName != 'LI') {
							ed.getDoc().execCommand('insertHTML', false, '<br id="__"/>');
							var n = dom.get('__');
							n.removeAttribute('id');
							selection.select(n);
							selection.collapse();
							return Event.cancel(e);
						}
					});
				}
			}

			if (s.force_p_newlines) {
				if (!isIE) {
					ed.onKeyPress.add(function(ed, e) {
						if (e.keyCode == 13 && !e.shiftKey && !t.insertPara(e))
							Event.cancel(e);
					});
				} else {
					// Ungly hack to for IE to preserve the formatting when you press
					// enter at the end of a block element with formatted contents
					// This logic overrides the browsers default logic with
					// custom logic that enables us to control the output
					tinymce.addUnload(function() {
						t._previousFormats = 0; // Fix IE leak
					});

					ed.onKeyPress.add(function(ed, e) {
						t._previousFormats = 0;

						// Clone the current formats, this will later be applied to the new block contents
						if (e.keyCode == 13 && !e.shiftKey && ed.selection.isCollapsed() && s.keep_styles)
							t._previousFormats = cloneFormats(ed.selection.getStart());
					});

					ed.onKeyUp.add(function(ed, e) {
						// Let IE break the element and the wrap the new caret location in the previous formats
						if (e.keyCode == 13 && !e.shiftKey) {
							var parent = ed.selection.getStart(), fmt = t._previousFormats;

							// Parent is an empty block
							if (!parent.hasChildNodes() && fmt) {
								parent = dom.getParent(parent, dom.isBlock);

								if (parent && parent.nodeName != 'LI') {
									parent.innerHTML = '';

									if (t._previousFormats) {
										parent.appendChild(fmt.wrapper);
										fmt.inner.innerHTML = '\uFEFF';
									} else
										parent.innerHTML = '\uFEFF';

									selection.select(parent, 1);
									selection.collapse(true);
									ed.getDoc().execCommand('Delete', false, null);
									t._previousFormats = 0;
								}
							}
						}
					});
				}

				if (isGecko) {
					ed.onKeyDown.add(function(ed, e) {
						if ((e.keyCode == 8 || e.keyCode == 46) && !e.shiftKey)
							t.backspaceDelete(e, e.keyCode == 8);
					});
				}
			}

			// Workaround for missing shift+enter support, http://bugs.webkit.org/show_bug.cgi?id=16973
			if (tinymce.isWebKit) {
				function insertBr(ed) {
					var rng = selection.getRng(), br, div = dom.create('div', null, ' '), divYPos, vpHeight = dom.getViewPort(ed.getWin()).h;

					// Insert BR element
					rng.insertNode(br = dom.create('br'));

					// Place caret after BR
					rng.setStartAfter(br);
					rng.setEndAfter(br);
					selection.setRng(rng);

					// Could not place caret after BR then insert an nbsp entity and move the caret
					if (selection.getSel().focusNode == br.previousSibling) {
						selection.select(dom.insertAfter(dom.doc.createTextNode('\u00a0'), br));
						selection.collapse(TRUE);
					}
/*this hack is broken*/
/*					// Create a temporary DIV after the BR and get the position as it
					// seems like getPos() returns 0 for text nodes and BR elements.
					dom.insertAfter(div, br);
					divYPos = dom.getPos(div).y;
					dom.remove(div);

					// Scroll to new position, scrollIntoView can't be used due to bug: http://bugs.webkit.org/show_bug.cgi?id=16117
					if (divYPos > vpHeight) // It is not necessary to scroll if the DIV is inside the view port.
						ed.getWin().scrollTo(0, divYPos);*/
				};

				ed.onKeyPress.add(function(ed, e) {
					if (e.keyCode == 13 && (e.shiftKey || (s.force_br_newlines && !dom.getParent(selection.getNode(), 'h1,h2,h3,h4,h5,h6,ol,ul')))) {
						insertBr(ed);
						Event.cancel(e);
					}
				});
			}

			// IE specific fixes
			if (isIE) {
				// Replaces IE:s auto generated paragraphs with the specified element name
				if (s.element != 'P') {
					ed.onKeyPress.add(function(ed, e) {
						t.lastElm = selection.getNode().nodeName;
					});

					ed.onKeyUp.add(function(ed, e) {
						var bl, n = selection.getNode(), b = ed.getBody();

						if (b.childNodes.length === 1 && n.nodeName == 'P') {
							n = dom.rename(n, s.element);
							selection.select(n);
							selection.collapse();
							ed.nodeChanged();
						} else if (e.keyCode == 13 && !e.shiftKey && t.lastElm != 'P') {
							bl = dom.getParent(n, 'p');

							if (bl) {
								dom.rename(bl, s.element);
								ed.nodeChanged();
							}
						}
					});
				}
			}
		},

		getParentBlock : function(n) {
			var d = this.dom;

			return d.getParent(n, d.isBlock);
		},

		insertPara : function(e) {
			var t = this, ed = t.editor, dom = ed.dom, d = ed.getDoc(), se = ed.settings, s = ed.selection.getSel(), r = s.getRangeAt(0), b = d.body;
			var rb, ra, dir, sn, so, en, eo, sb, eb, bn, bef, aft, sc, ec, n, vp = dom.getViewPort(ed.getWin()), y, ch, car;

			ed.undoManager.beforeChange();

			// If root blocks are forced then use Operas default behavior since it's really good
// Removed due to bug: #1853816
//			if (se.forced_root_block && isOpera)
//				return TRUE;

			// Setup before range
			rb = d.createRange();

			// If is before the first block element and in body, then move it into first block element
			rb.setStart(s.anchorNode, s.anchorOffset);
			rb.collapse(TRUE);

			// Setup after range
			ra = d.createRange();

			// If is before the first block element and in body, then move it into first block element
			ra.setStart(s.focusNode, s.focusOffset);
			ra.collapse(TRUE);

			// Setup start/end points
			dir = rb.compareBoundaryPoints(rb.START_TO_END, ra) < 0;
			sn = dir ? s.anchorNode : s.focusNode;
			so = dir ? s.anchorOffset : s.focusOffset;
			en = dir ? s.focusNode : s.anchorNode;
			eo = dir ? s.focusOffset : s.anchorOffset;

			// If selection is in empty table cell
			if (sn === en && /^(TD|TH)$/.test(sn.nodeName)) {
				if (sn.firstChild.nodeName == 'BR')
					dom.remove(sn.firstChild); // Remove BR

				// Create two new block elements
				if (sn.childNodes.length == 0) {
					ed.dom.add(sn, se.element, null, '<br />');
					aft = ed.dom.add(sn, se.element, null, '<br />');
				} else {
					n = sn.innerHTML;
					sn.innerHTML = '';
					ed.dom.add(sn, se.element, null, n);
					aft = ed.dom.add(sn, se.element, null, '<br />');
				}

				// Move caret into the last one
				r = d.createRange();
				r.selectNodeContents(aft);
				r.collapse(1);
				ed.selection.setRng(r);

				return FALSE;
			}

			// If the caret is in an invalid location in FF we need to move it into the first block
			if (sn == b && en == b && b.firstChild && ed.dom.isBlock(b.firstChild)) {
				sn = en = sn.firstChild;
				so = eo = 0;
				rb = d.createRange();
				rb.setStart(sn, 0);
				ra = d.createRange();
				ra.setStart(en, 0);
			}

			// If the body is totally empty add a BR element this might happen on webkit
			if (!d.body.hasChildNodes()) {
				d.body.appendChild(dom.create('br'));
			}

			// Never use body as start or end node
			sn = sn.nodeName == "HTML" ? d.body : sn; // Fix for Opera bug: https://bugs.opera.com/show_bug.cgi?id=273224&comments=yes
			sn = sn.nodeName == "BODY" ? sn.firstChild : sn;
			en = en.nodeName == "HTML" ? d.body : en; // Fix for Opera bug: https://bugs.opera.com/show_bug.cgi?id=273224&comments=yes
			en = en.nodeName == "BODY" ? en.firstChild : en;

			// Get start and end blocks
			sb = t.getParentBlock(sn);
			eb = t.getParentBlock(en);
			bn = sb ? sb.nodeName : se.element; // Get block name to create

			// Return inside list use default browser behavior
			if (n = t.dom.getParent(sb, 'li,pre')) {
				if (n.nodeName == 'LI')
					return splitList(ed.selection, t.dom, n);

				return TRUE;
			}

			// If caption or absolute layers then always generate new blocks within
			if (sb && (sb.nodeName == 'CAPTION' || /absolute|relative|fixed/gi.test(dom.getStyle(sb, 'position', 1)))) {
				bn = se.element;
				sb = null;
			}

			// If caption or absolute layers then always generate new blocks within
			if (eb && (eb.nodeName == 'CAPTION' || /absolute|relative|fixed/gi.test(dom.getStyle(sb, 'position', 1)))) {
				bn = se.element;
				eb = null;
			}

			// Use P instead
			if (/(TD|TABLE|TH|CAPTION)/.test(bn) || (sb && bn == "DIV" && /left|right/gi.test(dom.getStyle(sb, 'float', 1)))) {
				bn = se.element;
				sb = eb = null;
			}

			// Setup new before and after blocks
			bef = (sb && sb.nodeName == bn) ? sb.cloneNode(0) : ed.dom.create(bn);
			aft = (eb && eb.nodeName == bn) ? eb.cloneNode(0) : ed.dom.create(bn);

			// Remove id from after clone
			aft.removeAttribute('id');

			// Is header and cursor is at the end, then force paragraph under
			if (/^(H[1-6])$/.test(bn) && isAtEnd(r, sb))
				aft = ed.dom.create(se.element);

			// Find start chop node
			n = sc = sn;
			do {
				if (n == b || n.nodeType == 9 || t.dom.isBlock(n) || /(TD|TABLE|TH|CAPTION)/.test(n.nodeName))
					break;

				sc = n;
			} while ((n = n.previousSibling ? n.previousSibling : n.parentNode));

			// Find end chop node
			n = ec = en;
			do {
				if (n == b || n.nodeType == 9 || t.dom.isBlock(n) || /(TD|TABLE|TH|CAPTION)/.test(n.nodeName))
					break;

				ec = n;
			} while ((n = n.nextSibling ? n.nextSibling : n.parentNode));

			// Place first chop part into before block element
			if (sc.nodeName == bn)
				rb.setStart(sc, 0);
			else
				rb.setStartBefore(sc);

			rb.setEnd(sn, so);
			bef.appendChild(rb.cloneContents() || d.createTextNode('')); // Empty text node needed for Safari

			// Place secnd chop part within new block element
			try {
				ra.setEndAfter(ec);
			} catch(ex) {
				//console.debug(s.focusNode, s.focusOffset);
			}

			ra.setStart(en, eo);
			aft.appendChild(ra.cloneContents() || d.createTextNode('')); // Empty text node needed for Safari

			// Create range around everything
			r = d.createRange();
			if (!sc.previousSibling && sc.parentNode.nodeName == bn) {
				r.setStartBefore(sc.parentNode);
			} else {
				if (rb.startContainer.nodeName == bn && rb.startOffset == 0)
					r.setStartBefore(rb.startContainer);
				else
					r.setStart(rb.startContainer, rb.startOffset);
			}

			if (!ec.nextSibling && ec.parentNode.nodeName == bn)
				r.setEndAfter(ec.parentNode);
			else
				r.setEnd(ra.endContainer, ra.endOffset);

			// Delete and replace it with new block elements
			r.deleteContents();

			if (isOpera)
				ed.getWin().scrollTo(0, vp.y);

			// Never wrap blocks in blocks
			if (bef.firstChild && bef.firstChild.nodeName == bn)
				bef.innerHTML = bef.firstChild.innerHTML;

			if (aft.firstChild && aft.firstChild.nodeName == bn)
				aft.innerHTML = aft.firstChild.innerHTML;

			function appendStyles(e, en) {
				var nl = [], nn, n, i;

				e.innerHTML = '';

				// Make clones of style elements
				if (se.keep_styles) {
					n = en;
					do {
						// We only want style specific elements
						if (/^(SPAN|STRONG|B|EM|I|FONT|STRIKE|U)$/.test(n.nodeName)) {
							nn = n.cloneNode(FALSE);
							dom.setAttrib(nn, 'id', ''); // Remove ID since it needs to be unique
							nl.push(nn);
						}
					} while (n = n.parentNode);
				}

				// Append style elements to aft
				if (nl.length > 0) {
					for (i = nl.length - 1, nn = e; i >= 0; i--)
						nn = nn.appendChild(nl[i]);

					// Padd most inner style element
					nl[0].innerHTML = isOpera ? '\u00a0' : '<br />'; // Extra space for Opera so that the caret can move there
					return nl[0]; // Move caret to most inner element
				} else
					e.innerHTML = isOpera ? '\u00a0' : '<br />'; // Extra space for Opera so that the caret can move there
			};

			// Padd empty blocks
			if (dom.isEmpty(bef))
				appendStyles(bef, sn);

			// Fill empty afterblook with current style
			if (dom.isEmpty(aft))
				car = appendStyles(aft, en);

			// Opera needs this one backwards for older versions
			if (isOpera && parseFloat(opera.version()) < 9.5) {
				r.insertNode(bef);
				r.insertNode(aft);
			} else {
				r.insertNode(aft);
				r.insertNode(bef);
			}

			// Normalize
			aft.normalize();
			bef.normalize();

			// Move cursor and scroll into view
			ed.selection.select(aft, true);
			ed.selection.collapse(true);

			// scrollIntoView seems to scroll the parent window in most browsers now including FF 3.0b4 so it's time to stop using it and do it our selfs
			y = ed.dom.getPos(aft).y;
			//ch = aft.clientHeight;

			// Is element within viewport
			if (y < vp.y || y + 25 > vp.y + vp.h) {
				ed.getWin().scrollTo(0, y < vp.y ? y : y - vp.h + 25); // Needs to be hardcoded to roughly one line of text if a huge text block is broken into two blocks

				/*console.debug(
					'Element: y=' + y + ', h=' + ch + ', ' +
					'Viewport: y=' + vp.y + ", h=" + vp.h + ', bottom=' + (vp.y + vp.h)
				);*/
			}

			ed.undoManager.add();

			return FALSE;
		},

		backspaceDelete : function(e, bs) {
			var t = this, ed = t.editor, b = ed.getBody(), dom = ed.dom, n, se = ed.selection, r = se.getRng(), sc = r.startContainer, n, w, tn, walker;

			// Delete when caret is behind a element doesn't work correctly on Gecko see #3011651
			if (!bs && r.collapsed && sc.nodeType == 1 && r.startOffset == sc.childNodes.length) {
				walker = new tinymce.dom.TreeWalker(sc.lastChild, sc);

				// Walk the dom backwards until we find a text node
				for (n = sc.lastChild; n; n = walker.prev()) {
					if (n.nodeType == 3) {
						r.setStart(n, n.nodeValue.length);
						r.collapse(true);
						se.setRng(r);
						return;
					}
				}
			}

			// The caret sometimes gets stuck in Gecko if you delete empty paragraphs
			// This workaround removes the element by hand and moves the caret to the previous element
			if (sc && ed.dom.isBlock(sc) && !/^(TD|TH)$/.test(sc.nodeName) && bs) {
				if (sc.childNodes.length == 0 || (sc.childNodes.length == 1 && sc.firstChild.nodeName == 'BR')) {
					// Find previous block element
					n = sc;
					while ((n = n.previousSibling) && !ed.dom.isBlock(n)) ;

					if (n) {
						if (sc != b.firstChild) {
							// Find last text node
							w = ed.dom.doc.createTreeWalker(n, NodeFilter.SHOW_TEXT, null, FALSE);
							while (tn = w.nextNode())
								n = tn;

							// Place caret at the end of last text node
							r = ed.getDoc().createRange();
							r.setStart(n, n.nodeValue ? n.nodeValue.length : 0);
							r.setEnd(n, n.nodeValue ? n.nodeValue.length : 0);
							se.setRng(r);

							// Remove the target container
							ed.dom.remove(sc);
						}

						return Event.cancel(e);
					}
				}
			}
		}
	});
})(tinymce);
/**
 * ControlManager.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	// Shorten names
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each, extend = tinymce.extend;

	/**
	 * This class is responsible for managing UI control instances. It's both a factory and a collection for the controls.
	 * @class tinymce.ControlManager
	 */
	tinymce.create('tinymce.ControlManager', {
		/**
		 * Constructs a new control manager instance.
		 * Consult the Wiki for more details on this class.
		 *
		 * @constructor
		 * @method ControlManager
		 * @param {tinymce.Editor} ed TinyMCE editor instance to add the control to.
		 * @param {Object} s Optional settings object for the control manager.
		 */
		ControlManager : function(ed, s) {
			var t = this, i;

			s = s || {};
			t.editor = ed;
			t.controls = {};
			t.onAdd = new tinymce.util.Dispatcher(t);
			t.onPostRender = new tinymce.util.Dispatcher(t);
			t.prefix = s.prefix || ed.id + '_';
			t._cls = {};

			t.onPostRender.add(function() {
				each(t.controls, function(c) {
					c.postRender();
				});
			});
		},

		/**
		 * Returns a control by id or undefined it it wasn't found.
		 *
		 * @method get
		 * @param {String} id Control instance name.
		 * @return {tinymce.ui.Control} Control instance or undefined.
		 */
		get : function(id) {
			return this.controls[this.prefix + id] || this.controls[id];
		},

		/**
		 * Sets the active state of a control by id.
		 *
		 * @method setActive
		 * @param {String} id Control id to set state on.
		 * @param {Boolean} s Active state true/false.
		 * @return {tinymce.ui.Control} Control instance that got activated or null if it wasn't found.
		 */
		setActive : function(id, s) {
			var c = null;

			if (c = this.get(id))
				c.setActive(s);

			return c;
		},

		/**
		 * Sets the dsiabled state of a control by id.
		 *
		 * @method setDisabled
		 * @param {String} id Control id to set state on.
		 * @param {Boolean} s Active state true/false.
		 * @return {tinymce.ui.Control} Control instance that got disabled or null if it wasn't found.
		 */
		setDisabled : function(id, s) {
			var c = null;

			if (c = this.get(id))
				c.setDisabled(s);

			return c;
		},

		/**
		 * Adds a control to the control collection inside the manager.
		 *
		 * @method add
		 * @param {tinymce.ui.Control} Control instance to add to collection.
		 * @return {tinymce.ui.Control} Control instance that got passed in.
		 */
		add : function(c) {
			var t = this;

			if (c) {
				t.controls[c.id] = c;
				t.onAdd.dispatch(c, t);
			}

			return c;
		},

		/**
		 * Creates a control by name, when a control is created it will automatically add it to the control collection.
		 * It first ask all plugins for the specified control if the plugins didn't return a control then the default behavior
		 * will be used.
		 *
		 * @method createControl
		 * @param {String} n Control name to create for example "separator".
		 * @return {tinymce.ui.Control} Control instance that got created and added.
		 */
		createControl : function(n) {
			var c, t = this, ed = t.editor;

			each(ed.plugins, function(p) {
				if (p.createControl) {
					c = p.createControl(n, t);

					if (c)
						return false;
				}
			});

			switch (n) {
				case "|":
				case "separator":
					return t.createSeparator();
			}

			if (!c && ed.buttons && (c = ed.buttons[n]))
				return t.createButton(n, c);

			return t.add(c);
		},

		/**
		 * Creates a drop menu control instance by id.
		 *
		 * @method createDropMenu
		 * @param {String} id Unique id for the new dropdown instance. For example "some menu".
		 * @param {Object} s Optional settings object for the control.
		 * @param {Object} cc Optional control class to use instead of the default one.
		 * @return {tinymce.ui.Control} Control instance that got created and added.
		 */
		createDropMenu : function(id, s, cc) {
			var t = this, ed = t.editor, c, bm, v, cls;

			s = extend({
				'class' : 'mceDropDown',
				constrain : ed.settings.constrain_menus
			}, s);

			s['class'] = s['class'] + ' ' + ed.getParam('skin') + 'Skin';
			if (v = ed.getParam('skin_variant'))
				s['class'] += ' ' + ed.getParam('skin') + 'Skin' + v.substring(0, 1).toUpperCase() + v.substring(1);

			id = t.prefix + id;
			cls = cc || t._cls.dropmenu || tinymce.ui.DropMenu;
			c = t.controls[id] = new cls(id, s);
			c.onAddItem.add(function(c, o) {
				var s = o.settings;

				s.title = ed.getLang(s.title, s.title);

				if (!s.onclick) {
					s.onclick = function(v) {
						if (s.cmd)
							ed.execCommand(s.cmd, s.ui || false, s.value);
					};
				}
			});

			ed.onRemove.add(function() {
				c.destroy();
			});

			// Fix for bug #1897785, #1898007
			if (tinymce.isIE) {
				c.onShowMenu.add(function() {
					// IE 8 needs focus in order to store away a range with the current collapsed caret location
					ed.focus();

					bm = ed.selection.getBookmark(1);
				});

				c.onHideMenu.add(function() {
					if (bm) {
						ed.selection.moveToBookmark(bm);
						bm = 0;
					}
				});
			}

			return t.add(c);
		},

		/**
		 * Creates a list box control instance by id. A list box is either a native select element or a DOM/JS based list box control. This
		 * depends on the use_native_selects settings state.
		 *
		 * @method createListBox
		 * @param {String} id Unique id for the new listbox instance. For example "styles".
		 * @param {Object} s Optional settings object for the control.
		 * @param {Object} cc Optional control class to use instead of the default one.
		 * @return {tinymce.ui.Control} Control instance that got created and added.
		 */
		createListBox : function(id, s, cc) {
			var t = this, ed = t.editor, cmd, c, cls;

			if (t.get(id))
				return null;

			s.title = ed.translate(s.title);
			s.scope = s.scope || ed;

			if (!s.onselect) {
				s.onselect = function(v) {
					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			s = extend({
				title : s.title,
				'class' : 'mce_' + id,
				scope : s.scope,
				control_manager : t
			}, s);

			id = t.prefix + id;


			function useNativeListForAccessibility(ed) {
				return ed.settings.use_accessible_selects && !tinymce.isGecko
			}

			if (ed.settings.use_native_selects || useNativeListForAccessibility(ed))
				c = new tinymce.ui.NativeListBox(id, s);
			else {
				cls = cc || t._cls.listbox || tinymce.ui.ListBox;
				c = new cls(id, s, ed);
			}

			t.controls[id] = c;

			// Fix focus problem in Safari
			if (tinymce.isWebKit) {
				c.onPostRender.add(function(c, n) {
					// Store bookmark on mousedown
					Event.add(n, 'mousedown', function() {
						ed.bookmark = ed.selection.getBookmark(1);
					});

					// Restore on focus, since it might be lost
					Event.add(n, 'focus', function() {
						ed.selection.moveToBookmark(ed.bookmark);
						ed.bookmark = null;
					});
				});
			}

			if (c.hideMenu)
				ed.onMouseDown.add(c.hideMenu, c);

			return t.add(c);
		},

		/**
		 * Creates a button control instance by id.
		 *
		 * @method createButton
		 * @param {String} id Unique id for the new button instance. For example "bold".
		 * @param {Object} s Optional settings object for the control.
		 * @param {Object} cc Optional control class to use instead of the default one.
		 * @return {tinymce.ui.Control} Control instance that got created and added.
		 */
		createButton : function(id, s, cc) {
			var t = this, ed = t.editor, o, c, cls;

			if (t.get(id))
				return null;

			s.title = ed.translate(s.title);
			s.label = ed.translate(s.label);
			s.scope = s.scope || ed;

			if (!s.onclick && !s.menu_button) {
				s.onclick = function() {
					ed.execCommand(s.cmd, s.ui || false, s.value);
				};
			}

			s = extend({
				title : s.title,
				'class' : 'mce_' + id,
				unavailable_prefix : ed.getLang('unavailable', ''),
				scope : s.scope,
				control_manager : t
			}, s);

			id = t.prefix + id;

			if (s.menu_button) {
				cls = cc || t._cls.menubutton || tinymce.ui.MenuButton;
				c = new cls(id, s, ed);
				ed.onMouseDown.add(c.hideMenu, c);
			} else {
				cls = t._cls.button || tinymce.ui.Button;
				c = new cls(id, s, ed);
			}

			return t.add(c);
		},

		/**
		 * Creates a menu button control instance by id.
		 *
		 * @method createMenuButton
		 * @param {String} id Unique id for the new menu button instance. For example "menu1".
		 * @param {Object} s Optional settings object for the control.
		 * @param {Object} cc Optional control class to use instead of the default one.
		 * @return {tinymce.ui.Control} Control instance that got created and added.
		 */
		createMenuButton : function(id, s, cc) {
			s = s || {};
			s.menu_button = 1;

			return this.createButton(id, s, cc);
		},

		/**
		 * Creates a split button control instance by id.
		 *
		 * @method createSplitButton
		 * @param {String} id Unique id for the new split button instance. For example "spellchecker".
		 * @param {Object} s Optional settings object for the control.
		 * @param {Object} cc Optional control class to use instead of the default one.
		 * @return {tinymce.ui.Control} Control instance that got created and added.
		 */
		createSplitButton : function(id, s, cc) {
			var t = this, ed = t.editor, cmd, c, cls;

			if (t.get(id))
				return null;

			s.title = ed.translate(s.title);
			s.scope = s.scope || ed;

			if (!s.onclick) {
				s.onclick = function(v) {
					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			if (!s.onselect) {
				s.onselect = function(v) {
					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			s = extend({
				title : s.title,
				'class' : 'mce_' + id,
				scope : s.scope,
				control_manager : t
			}, s);

			id = t.prefix + id;
			cls = cc || t._cls.splitbutton || tinymce.ui.SplitButton;
			c = t.add(new cls(id, s, ed));
			ed.onMouseDown.add(c.hideMenu, c);

			return c;
		},

		createSignatureButton : function(id, s, cc) {
			var t = this, ed = t.editor, cmd, c, cls;

			if (t.get(id))
				return null;

			s.title = ed.translate(s.title);
			s.scope = s.scope || ed;

			if (!s.onclick) {
				s.onclick = function(v) {
					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			if (!s.onselect) {
				s.onselect = function(v) {
					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			s = extend({
				title : s.title,
				'class' : 'mce_' + id,
				scope : s.scope,
				control_manager : t
			}, s);

			id = t.prefix + id;
			cls = cc || t._cls.splitbutton || tinymce.ui.SignatureButton;
			c = t.add(new cls(id, s, ed));
			ed.onMouseDown.add(c.hideMenu, c);

			return c;
		},

		/**
		 * Creates a color split button control instance by id.
		 *
		 * @method createColorSplitButton
		 * @param {String} id Unique id for the new color split button instance. For example "forecolor".
		 * @param {Object} s Optional settings object for the control.
		 * @param {Object} cc Optional control class to use instead of the default one.
		 * @return {tinymce.ui.Control} Control instance that got created and added.
		 */
		createColorSplitButton : function(id, s, cc) {
			var t = this, ed = t.editor, cmd, c, cls, bm;

			if (t.get(id))
				return null;

			s.title = ed.translate(s.title);
			s.scope = s.scope || ed;

			if (!s.onclick) {
				s.onclick = function(v) {
					if (tinymce.isIE)
						bm = ed.selection.getBookmark(1);

					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			if (!s.onselect) {
				s.onselect = function(v) {
					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			s = extend({
				title : s.title,
				'class' : 'mce_' + id,
				'menu_class' : ed.getParam('skin') + 'Skin',
				scope : s.scope,
				more_colors_title : ed.getLang('more_colors')
			}, s);

			id = t.prefix + id;
			cls = cc || t._cls.colorsplitbutton || tinymce.ui.ColorSplitButton;
			c = new cls(id, s, ed);
			ed.onMouseDown.add(c.hideMenu, c);

			// Remove the menu element when the editor is removed
			ed.onRemove.add(function() {
				c.destroy();
			});

			// Fix for bug #1897785, #1898007
			if (tinymce.isIE) {
				c.onShowMenu.add(function() {
					// IE 8 needs focus in order to store away a range with the current collapsed caret location
					ed.focus();
					bm = ed.selection.getBookmark(1);
				});

				c.onHideMenu.add(function() {
					if (bm) {
						ed.selection.moveToBookmark(bm);
						bm = 0;
					}
				});
			}

			return t.add(c);
		},

		/**
		 * Creates a toolbar container control instance by id.
		 *
		 * @method createToolbar
		 * @param {String} id Unique id for the new toolbar container control instance. For example "toolbar1".
		 * @param {Object} s Optional settings object for the control.
		 * @param {Object} cc Optional control class to use instead of the default one.
		 * @return {tinymce.ui.Control} Control instance that got created and added.
		 */
		createToolbar : function(id, s, cc) {
			var c, t = this, cls;

			id = t.prefix + id;
			cls = cc || t._cls.toolbar || tinymce.ui.Toolbar;
			c = new cls(id, s, t.editor);

			if (t.get(id))
				return null;

			return t.add(c);
		},

		createToolbarGroup : function(id, s, cc) {
			var c, t = this, cls;
			id = t.prefix + id;
			cls = cc || this._cls.toolbarGroup || tinymce.ui.ToolbarGroup;
			c = new cls(id, s, t.editor);

			if (t.get(id))
				return null;

			return t.add(c);
		},

		/**
		 * Creates a separator control instance.
		 *
		 * @method createSeparator
		 * @param {Object} cc Optional control class to use instead of the default one.
		 * @return {tinymce.ui.Control} Control instance that got created and added.
		 */
		createSeparator : function(cc) {
			var cls = cc || this._cls.separator || tinymce.ui.Separator;

			return new cls();
		},

		createFontButton: function (id, s, cc) {
			var t = this, ed = t.editor, cmd, c, cls, bm;

			if (t.get(id))
				return null;

			s.title = ed.translate(s.title);
			s.scope = s.scope || ed;

			if (!s.onclick) {
				s.onclick = function(v) {
					if (tinymce.isIE)
						bm = ed.selection.getBookmark(1);

					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			if (!s.onselect) {
				s.onselect = function(v) {
				};
			}

			s = extend({
				title : s.title,
				'class' : 'mce_' + id,
				'menu_class' : ed.getParam('skin') + 'Skin',
				scope : s.scope
			}, s);

			id = t.prefix + id;
			cls = cc || t._cls.fontactionbutton || tinymce.ui.FontActionButton;
			c = new cls(id, s);
			ed.onMouseDown.add(c.hideMenu, c);

			// Remove the menu element when the editor is removed
			ed.onRemove.add(function() {
				c.destroy();
			});

			// Fix for bug #1897785, #1898007
			if (tinymce.isIE) {
				c.onShowMenu.add(function() {
					// IE 8 needs focus in order to store away a range with the current collapsed caret location
					ed.focus();
					bm = ed.selection.getBookmark(1);
				});

				c.onHideMenu.add(function() {
					if (bm) {
						ed.selection.moveToBookmark(bm);
						bm = 0;
					}
				});
			}

			return t.add(c);
		},

		createControlsButton : function(id, s, cc) {
			var t = this, ed = t.editor, cmd, c, cls, bm;

			if (t.get(id))
				return null;

			s.title = ed.translate(s.title);
			s.scope = s.scope || ed;

			if (!s.onclick) {
				s.onclick = function(v) {
					if (tinymce.isIE)
						bm = ed.selection.getBookmark(1);

					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			if (!s.onselect) {
				s.onselect = function(v) {
					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			s = extend({
				title : s.title,
				'class' : 'mce_' + id,
				'menu_class' : ed.getParam('skin') + 'Skin',
				scope : s.scope
			}, s);

			id = t.prefix + id;

			cls = cc || t._cls.controlsbutton || tinymce.ui.ControlsButton;
			c = new cls(id, s);
			ed.onMouseDown.add(c.hideMenu, c);

			// Remove the menu element when the editor is removed
			ed.onRemove.add(function() {
				c.destroy();
			});

			// Fix for bug #1897785, #1898007
			if (tinymce.isIE) {
				c.onShowMenu.add(function() {
					// IE 8 needs focus in order to store away a range with the current collapsed caret location
					ed.focus();
					bm = ed.selection.getBookmark(1);
				});

				c.onHideMenu.add(function() {
					if (bm) {
						ed.selection.moveToBookmark(bm);
						bm = 0;
					}
				});
			}

			return t.add(c);
		},

		createEmotionsSplitButton: function(id, s, cc)
		{
			var t = this, ed = t.editor, cmd, c, cls, bm;

			if (t.get(id))
				return null;

			s.title = ed.translate(s.title);
			s.scope = s.scope || ed;

			if (!s.onclick) {
				s.onclick = function(v) {
//					if (tinymce.isIE)
//						bm = ed.selection.getBookmark(1);
					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			if (!s.onselect) {
				s.onselect = function(v) {
					ed.execCommand(s.cmd, s.ui || false, v || s.value);
				};
			}

			s = extend({
				title : s.title,
				'class' : 'mce_' + id,
				'menu_class' : ed.getParam('skin') + 'Skin',
				scope : s.scope
			}, s);

			id = t.prefix + id;
			cls = cc || t._cls.emotionssplitbutton || tinymce.ui.EmotionsSplitButton;
			c = new cls(id, s);
			ed.onMouseDown.add(c.hideMenu, c);

			// Remove the menu element when the editor is removed
			ed.onRemove.add(function() {
				c.destroy();
			});

			// Fix for bug #1897785, #1898007
			if (tinymce.isIE) {
				c.onShowMenu.add(function() {
					// IE 8 needs focus in order to store away a range with the current collapsed caret location
					ed.focus();
					bm = ed.selection.getBookmark(1);
				});

				c.onChangeTab.add(function() {
					if (bm) {
						ed.selection.moveToBookmark(bm);
					}
				});

				c.onHideMenu.add(function() {
					if (bm) {
						ed.selection.moveToBookmark(bm);
						ed.selection.collapse();
						bm = 0;
					}
				});
			}

			return t.add(c);
		},

		/**
		 * Overrides a specific control type with a custom class.
		 *
		 * @method setControlType
		 * @param {string} n Name of the control to override for example button or dropmenu.
		 * @param {function} c Class reference to use instead of the default one.
		 * @return {function} Same as the class reference.
		 */
		setControlType : function(n, c) {
			return this._cls[n.toLowerCase()] = c;
		},

		/**
		 * Destroy.
		 *
		 * @method destroy
		 */
		destroy : function() {
			each(this.controls, function(c) {
				c.destroy();
			});

			this.controls = null;
		}
	});
})(tinymce);
/**
 * WindowManager.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var Dispatcher = tinymce.util.Dispatcher, each = tinymce.each, isIE = tinymce.isIE, isOpera = tinymce.isOpera;

	/**
	 * This class handles the creation of native windows and dialogs. This class can be extended to provide for example inline dialogs.
	 *
	 * @class tinymce.WindowManager
	 * @example
	 * // Opens a new dialog with the file.htm file and the size 320x240
	 * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.
	 * tinyMCE.activeEditor.windowManager.open({
	 *    url : 'file.htm',
	 *    width : 320,
	 *    height : 240
	 * }, {
	 *    custom_param : 1
	 * });
	 *
	 * // Displays an alert box using the active editors window manager instance
	 * tinyMCE.activeEditor.windowManager.alert('Hello world!');
	 *
	 * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm
	 * tinyMCE.activeEditor.windowManager.confirm("Do you want to do something", function(s) {
	 *    if (s)
	 *       tinyMCE.activeEditor.windowManager.alert("Ok");
	 *    else
	 *       tinyMCE.activeEditor.windowManager.alert("Cancel");
	 * });
	 */
	tinymce.create('tinymce.WindowManager', {
		/**
		 * Constructs a new window manager instance.
		 *
		 * @constructor
		 * @method WindowManager
		 * @param {tinymce.Editor} ed Editor instance that the windows are bound to.
		 */
		WindowManager : function(ed) {
			var t = this;

			t.editor = ed;
			t.onOpen = new Dispatcher(t);
			t.onClose = new Dispatcher(t);
			t.params = {};
			t.features = {};
		},

		/**
		 * Opens a new window.
		 *
		 * @method open
		 * @param {Object} s Optional name/value settings collection contains things like width/height/url etc.
		 * @option {String} title Window title.
		 * @option {String} file URL of the file to open in the window.
		 * @option {Number} width Width in pixels.
		 * @option {Number} height Height in pixels.
		 * @option {Boolean} resizable Specifies whether the popup window is resizable or not.
		 * @option {Boolean} maximizable Specifies whether the popup window has a "maximize" button and can get maximized or not.
		 * @option {Boolean} inline Specifies whether to display in-line (set to 1 or true for in-line display; requires inlinepopups plugin).
		 * @option {String/Boolean} popup_css Optional CSS to use in the popup. Set to false to remove the default one.
		 * @option {Boolean} translate_i18n Specifies whether translation should occur or not of i18 key strings. Default is true.
		 * @option {String/bool} close_previous Specifies whether a previously opened popup window is to be closed or not (like when calling the file browser window over the advlink popup).
		 * @option {String/bool} scrollbars Specifies whether the popup window can have scrollbars if required (i.e. content larger than the popup size specified).
		 * @param {Object} p Optional parameters/arguments collection can be used by the dialogs to retrive custom parameters.
		 * @option {String} plugin_url url to plugin if opening plugin window that calls tinyMCEPopup.requireLangPack() and needs access to the plugin language js files
		 */
		open : function(s, p) {
			var t = this, f = '', x, y, mo = t.editor.settings.dialog_type == 'modal', w, sw, sh, vp = tinymce.DOM.getViewPort(), u;

			// Default some options
			s = s || {};
			p = p || {};
			sw = isOpera ? vp.w : screen.width; // Opera uses windows inside the Opera window
			sh = isOpera ? vp.h : screen.height;
			s.name = s.name || 'mc_' + new Date().getTime();
			s.width = parseInt(s.width || 320);
			s.height = parseInt(s.height || 240);
			s.resizable = true;
			s.left = s.left || parseInt(sw / 2.0) - (s.width / 2.0);
			s.top = s.top || parseInt(sh / 2.0) - (s.height / 2.0);
			p.inline = false;
			p.mce_width = s.width;
			p.mce_height = s.height;
			p.mce_auto_focus = s.auto_focus;

			if (mo) {
				if (isIE) {
					s.center = true;
					s.help = false;
					s.dialogWidth = s.width + 'px';
					s.dialogHeight = s.height + 'px';
					s.scroll = s.scrollbars || false;
				}
			}

			// Build features string
			each(s, function(v, k) {
				if (tinymce.is(v, 'boolean'))
					v = v ? 'yes' : 'no';

				if (!/^(name|url)$/.test(k)) {
					if (isIE && mo)
						f += (f ? ';' : '') + k + ':' + v;
					else
						f += (f ? ',' : '') + k + '=' + v;
				}
			});

			t.features = s;
			t.params = p;
			t.onOpen.dispatch(t, s, p);

			u = s.url || s.file;
			u = tinymce._addVer(u);

			try {
				if (isIE && mo) {
					w = 1;
					window.showModalDialog(u, window, f);
				} else
					w = window.open(u, s.name, f);
			} catch (ex) {
				// Ignore
			}

			if (!w)
				alert(t.editor.getLang('popup_blocked'));
		},

		/**
		 * Closes the specified window. This will also dispatch out a onClose event.
		 *
		 * @method close
		 * @param {Window} w Native window object to close.
		 */
		close : function(w) {
			w.close();
			this.onClose.dispatch(this);
		},

		/**
		 * Creates a instance of a class. This method was needed since IE can't create instances
		 * of classes from a parent window due to some reference problem. Any arguments passed after the class name
		 * will be passed as arguments to the constructor.
		 *
		 * @method createInstance
		 * @param {String} cl Class name to create an instance of.
		 * @return {Object} Instance of the specified class.
		 * @example
		 * var uri = tinyMCEPopup.editor.windowManager.createInstance('tinymce.util.URI', 'http://www.somesite.com');
		 * alert(uri.getURI());
		 */
		createInstance : function(cl, a, b, c, d, e) {
			var f = tinymce.resolve(cl);

			return new f(a, b, c, d, e);
		},

		/**
		 * Creates a confirm dialog. Please don't use the blocking behavior of this
		 * native version use the callback method instead then it can be extended.
		 *
		 * @method confirm
		 * @param {String} t Title for the new confirm dialog.
		 * @param {function} cb Callback function to be executed after the user has selected ok or cancel.
		 * @param {Object} s Optional scope to execute the callback in.
		 * @example
		 * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm
		 * tinyMCE.activeEditor.windowManager.confirm("Do you want to do something", function(s) {
		 *    if (s)
		 *       tinyMCE.activeEditor.windowManager.alert("Ok");
		 *    else
		 *       tinyMCE.activeEditor.windowManager.alert("Cancel");
		 * });
		 */
		confirm : function(t, cb, s, w) {
			w = w || window;

			cb.call(s || this, w.confirm(this._decode(this.editor.getLang(t, t))));
		},

		/**
		 * Creates a alert dialog. Please don't use the blocking behavior of this
		 * native version use the callback method instead then it can be extended.
		 *
		 * @method alert
		 * @param {String} t Title for the new alert dialog.
		 * @param {function} cb Callback function to be executed after the user has selected ok.
		 * @param {Object} s Optional scope to execute the callback in.
		 * @example
		 * // Displays an alert box using the active editors window manager instance
		 * tinyMCE.activeEditor.windowManager.alert('Hello world!');
		 */
		alert : function(tx, cb, s, w) {
			var t = this;

			w = w || window;
			w.alert(t._decode(t.editor.getLang(tx, tx)));

			if (cb)
				cb.call(s || t);
		},

		/**
		 * Resizes the specified window or id.
		 *
		 * @param {Number} dw Delta width.
		 * @param {Number} dh Delta height.
		 * @param {window/id} win Window if the dialog isn't inline. Id if the dialog is inline.
		 */
		resizeBy : function(dw, dh, win) {
			win.resizeBy(dw, dh);
		},

		// Internal functions

		_decode : function(s) {
			return tinymce.DOM.decode(s).replace(/\\n/g, '\n');
		}
	});
}(tinymce));/**
 * Formatter.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	/**
	 * Text formatter engine class. This class is used to apply formats like bold, italic, font size
	 * etc to the current selection or specific nodes. This engine was build to replace the browsers
	 * default formatting logic for execCommand due to it's inconsistant and buggy behavior.
	 *
	 * @class tinymce.Formatter
	 * @example
	 *  tinymce.activeEditor.formatter.register('mycustomformat', {
	 *    inline : 'span',
	 *    styles : {color : '#ff0000'}
	 *  });
	 *
	 *  tinymce.activeEditor.formatter.apply('mycustomformat');
	 */

	/**
	 * Constructs a new formatter instance.
	 *
	 * @constructor Formatter
	 * @param {tinymce.Editor} ed Editor instance to construct the formatter engine to.
	 */
	tinymce.Formatter = function(ed) {
		var formats = {},
			each = tinymce.each,
			dom = ed.dom,
			selection = ed.selection,
			TreeWalker = tinymce.dom.TreeWalker,
			rangeUtils = new tinymce.dom.RangeUtils(dom),
			isValid = ed.schema.isValidChild,
			isBlock = dom.isBlock,
			forcedRootBlock = ed.settings.forced_root_block,
			nodeIndex = dom.nodeIndex,
			INVISIBLE_CHAR = '\uFEFF',
			MCE_ATTR_RE = /^(src|href|style)$/,
			FALSE = false,
			TRUE = true,
			undefined,
			pendingFormats = {apply : [], remove : []};

		function isArray(obj) {
			return obj instanceof Array;
		};

		function getParents(node, selector) {
			return dom.getParents(node, selector, dom.getRoot());
		};

		function isCaretNode(node) {
			return node.nodeType === 1 && (node.face === 'mceinline' || node.style.fontFamily === 'mceinline');
		};

		// Public functions

		/**
		 * Returns the format by name or all formats if no name is specified.
		 *
		 * @method get
		 * @param {String} name Optional name to retrive by.
		 * @return {Array/Object} Array/Object with all registred formats or a specific format.
		 */
		function get(name) {
			return name ? formats[name] : formats;
		};

		/**
		 * Registers a specific format by name.
		 *
		 * @method register
		 * @param {Object/String} name Name of the format for example "bold".
		 * @param {Object/Array} format Optional format object or array of format variants can only be omitted if the first arg is an object.
		 */
		function register(name, format) {
			if (name) {
				if (typeof(name) !== 'string') {
					each(name, function(format, name) {
						register(name, format);
					});
				} else {
					// Force format into array and add it to internal collection
					format = format.length ? format : [format];

					each(format, function(format) {
						// Set deep to false by default on selector formats this to avoid removing
						// alignment on images inside paragraphs when alignment is changed on paragraphs
						if (format.deep === undefined)
							format.deep = !format.selector;

						// Default to true
						if (format.split === undefined)
							format.split = !format.selector || format.inline;

						// Default to true
						if (format.remove === undefined && format.selector && !format.inline)
							format.remove = 'none';

						// Mark format as a mixed format inline + block level
						if (format.selector && format.inline) {
							format.mixed = true;
							format.block_expand = true;
						}

						// Split classes if needed
						if (typeof(format.classes) === 'string')
							format.classes = format.classes.split(/\s+/);
					});

					formats[name] = format;
				}
			}
		};

		var getTextDecoration = function(node) {
			var decoration;

			ed.dom.getParent(node, function(n) {
				decoration = ed.dom.getStyle(n, 'text-decoration');
				return decoration && decoration !== 'none';
			});

			return decoration;
		};

		var processUnderlineAndColor = function(node) {
			var textDecoration;
			if (node.nodeType === 1 && node.parentNode && node.parentNode.nodeType === 1) {
				textDecoration = getTextDecoration(node.parentNode);
				if (ed.dom.getStyle(node, 'color') && textDecoration) {
					ed.dom.setStyle(node, 'text-decoration', textDecoration);
				} else if (ed.dom.getStyle(node, 'textdecoration') === textDecoration) {
					ed.dom.setStyle(node, 'text-decoration', null);
				}
			}
		};

		/**
		 * Applies the specified format to the current selection or specified node.
		 *
		 * @method apply
		 * @param {String} name Name of format to apply.
		 * @param {Object} vars Optional list of variables to replace within format before applying it.
		 * @param {Node} node Optional node to apply the format to defaults to current selection.
		 */
		function apply(name, vars, node) {
			var formatList = get(name), format = formatList[0], bookmark, rng, i, isCollapsed = selection.isCollapsed();

			/**
			 * Moves the start to the first suitable text node.
			 */
			function moveStart(rng) {
				var container = rng.startContainer,
					offset = rng.startOffset,
					walker, node;

				// Move startContainer/startOffset in to a suitable node
				if (container.nodeType == 1 || container.nodeValue === "") {
					container = container.nodeType == 1 ? container.childNodes[offset] : container;

					// Might fail if the offset is behind the last element in it's container
					if (container) {
						walker = new TreeWalker(container, container.parentNode);
						for (node = walker.current(); node; node = walker.next()) {
							if (node.nodeType == 3 && !isWhiteSpaceNode(node)) {
								rng.setStart(node, 0);
								break;
							}
						}
					}
				}

				return rng;
			};

			function setElementFormat(elm, fmt) {
				fmt = fmt || format;

				if (elm) {
					if (fmt.onformat) {
						fmt.onformat(elm, fmt, vars, node);
					}

					each(fmt.styles, function(value, name) {
						dom.setStyle(elm, name, replaceVars(value, vars));
					});

					each(fmt.attributes, function(value, name) {
						dom.setAttrib(elm, name, replaceVars(value, vars));
					});

					each(fmt.classes, function(value) {
						value = replaceVars(value, vars);

						if (!dom.hasClass(elm, value))
							dom.addClass(elm, value);
					});
				}
			};
			function adjustSelectionToVisibleSelection() {
				function findSelectionEnd(start, end) {
					var walker = new TreeWalker(end);
					for (node = walker.current(); node; node = walker.prev()) {
						if (node.childNodes.length > 1 || node == start) {
							return node;
						}
					}
				};

				// Adjust selection so that a end container with a end offset of zero is not included in the selection
				// as this isn't visible to the user.
				var rng = ed.selection.getRng();
				var start = rng.startContainer;
				var end = rng.endContainer;

				if (start != end && rng.endOffset == 0) {
					var newEnd = findSelectionEnd(start, end);
					var endOffset = newEnd.nodeType == 3 ? newEnd.length : newEnd.childNodes.length;

					rng.setEnd(newEnd, endOffset);
				}

				return rng;
			}

			function applyStyleToList(node, bookmark, wrapElm, newWrappers, process){
				var nodes = [], listIndex = -1, list, startIndex = -1, endIndex = -1, currentWrapElm;

				// find the index of the first child list.
				each(node.childNodes, function(n, index) {
					if (n.nodeName === "UL" || n.nodeName === "OL") {
						listIndex = index;
						list = n;
						return false;
					}
				});

				// get the index of the bookmarks
				each(node.childNodes, function(n, index) {
					if (n.nodeName === "SPAN" && dom.getAttrib(n, "data-mce-type") == "bookmark") {
						if (n.id == bookmark.id + "_start") {
							startIndex = index;
						} else if (n.id == bookmark.id + "_end") {
							endIndex = index;
						}
					}
				});

				// if the selection spans across an embedded list, or there isn't an embedded list - handle processing normally
				if (listIndex <= 0 || (startIndex < listIndex && endIndex > listIndex)) {
					each(tinymce.grep(node.childNodes), process);
					return 0;
				} else {
					currentWrapElm = wrapElm.cloneNode(FALSE);

					// create a list of the nodes on the same side of the list as the selection
					each(tinymce.grep(node.childNodes), function(n, index) {
						if ((startIndex < listIndex && index < listIndex) || (startIndex > listIndex && index > listIndex)) {
							nodes.push(n);
							n.parentNode.removeChild(n);
						}
					});

					// insert the wrapping element either before or after the list.
					if (startIndex < listIndex) {
						node.insertBefore(currentWrapElm, list);
					} else if (startIndex > listIndex) {
						node.insertBefore(currentWrapElm, list.nextSibling);
					}

					// add the new nodes to the list.
					newWrappers.push(currentWrapElm);

					each(nodes, function(node) {
						currentWrapElm.appendChild(node);
					});

					return currentWrapElm;
				}
			};

			function applyRngStyle(rng, bookmark) {
				var newWrappers = [], wrapName, wrapElm;

				// Setup wrapper element
				wrapName = format.inline || format.block;
				wrapElm = dom.create(wrapName);
				setElementFormat(wrapElm);

				rangeUtils.walk(rng, function(nodes) {
					var currentWrapElm;

					/**
					 * Process a list of nodes wrap them.
					 */
					function process(node) {
						var nodeName = node.nodeName.toLowerCase(), parentName = node.parentNode.nodeName.toLowerCase(), found;

						// Stop wrapping on br elements
						if (isEq(nodeName, 'br')) {
							currentWrapElm = 0;

							// Remove any br elements when we wrap things
							if (format.block)
								dom.remove(node);

							return;
						}

						// If node is wrapper type
						if (format.wrapper && matchNode(node, name, vars)) {
							currentWrapElm = 0;
							return;
						}

						// Can we rename the block
						if (format.block && !format.wrapper && isTextBlock(nodeName)) {
							node = dom.rename(node, wrapName);
							setElementFormat(node);
							newWrappers.push(node);
							currentWrapElm = 0;
							return;
						}

						// Handle selector patterns
						if (format.selector) {
							// Look for matching formats
							each(formatList, function(format) {
								// Check collapsed state if it exists
								if ('collapsed' in format && format.collapsed !== isCollapsed) {
									return;
								}

								if (dom.is(node, format.selector) && !isCaretNode(node)) {
									setElementFormat(node, format);
									found = true;
								}
							});

							// Continue processing if a selector match wasn't found and a inline element is defined
							if (!format.inline || found) {
								currentWrapElm = 0;
								return;
							}
						}

						// Is it valid to wrap this item
						if (isValid(wrapName, nodeName) && isValid(parentName, wrapName) &&
								!(node.nodeType === 3 && node.nodeValue.length === 1 && node.nodeValue.charCodeAt(0) === 65279)) {
							// Start wrapping
							if (!currentWrapElm) {
								// Wrap the node
								currentWrapElm = wrapElm.cloneNode(FALSE);
								node.parentNode.insertBefore(currentWrapElm, node);
								newWrappers.push(currentWrapElm);
							}

							currentWrapElm.appendChild(node);
						} else if (nodeName == 'li' && bookmark) {
							// Start wrapping - if we are in a list node and have a bookmark, then we will always begin by wrapping in a new element.
							currentWrapElm = applyStyleToList(node, bookmark, wrapElm, newWrappers, process);
						} else {
							// Start a new wrapper for possible children
							currentWrapElm = 0;

							each(tinymce.grep(node.childNodes), process);

							// End the last wrapper
							currentWrapElm = 0;
						}
					};

					// Process siblings from range
					each(nodes, process);
				});

				// Wrap links inside as well, for example color inside a link when the wrapper is around the link
				if (format.wrap_links === false) {
					each(newWrappers, function(node) {
						function process(node) {
							var i, currentWrapElm, children;

							if (node.nodeName === 'A') {
								currentWrapElm = wrapElm.cloneNode(FALSE);
								newWrappers.push(currentWrapElm);

								children = tinymce.grep(node.childNodes);
								for (i = 0; i < children.length; i++)
									currentWrapElm.appendChild(children[i]);

								node.appendChild(currentWrapElm);
							}

							each(tinymce.grep(node.childNodes), process);
						};

						process(node);
					});
				}

				// Cleanup
				each(newWrappers, function(node) {
					var childCount;

					function getChildCount(node) {
						var count = 0;

						each(node.childNodes, function(node) {
							if (!isWhiteSpaceNode(node) && !isBookmarkNode(node))
								count++;
						});

						return count;
					};

					function mergeStyles(node) {
						var child, clone;

						each(node.childNodes, function(node) {
							if (node.nodeType == 1 && !isBookmarkNode(node) && !isCaretNode(node)) {
								child = node;
								return FALSE; // break loop
							}
						});

						// If child was found and of the same type as the current node
						if (child && matchName(child, format)) {
							clone = child.cloneNode(FALSE);
							setElementFormat(clone);

							dom.replace(clone, node, TRUE);
							dom.remove(child, 1);
						}

						return clone || node;
					};

					childCount = getChildCount(node);

					// Remove empty nodes but only if there is multiple wrappers and they are not block
					// elements so never remove single <h1></h1> since that would remove the currrent empty block element where the caret is at
					if ((newWrappers.length > 1 || !isBlock(node)) && childCount === 0) {
						dom.remove(node, 1);
						return;
					}

					if (format.inline || format.wrapper) {
						// Merges the current node with it's children of similar type to reduce the number of elements
						if (!format.exact && childCount === 1)
							node = mergeStyles(node);

						// Remove/merge children
						each(formatList, function(format) {
							// Merge all children of similar type will move styles from child to parent
							// this: <span style="color:red"><b><span style="color:red; font-size:10px">text</span></b></span>
							// will become: <span style="color:red"><b><span style="font-size:10px">text</span></b></span>
							each(dom.select(format.inline, node), function(child) {
								var parent;

								// When wrap_links is set to false we don't want
								// to remove the format on children within links
								if (format.wrap_links === false) {
									parent = child.parentNode;

									do {
										if (parent.nodeName === 'A')
											return;
									} while (parent = parent.parentNode);
								}

								removeFormat(format, vars, child, format.exact ? child : null);
							});
						});

						// Remove child if direct parent is of same type
						if (matchNode(node.parentNode, name, vars)) {
							dom.remove(node, 1);
							node = 0;
							return TRUE;
						}

						// Look for parent with similar style format
						if (format.merge_with_parents) {
							dom.getParent(node.parentNode, function(parent) {
								if (matchNode(parent, name, vars)) {
									dom.remove(node, 1);
									node = 0;
									return TRUE;
								}
							});
						}

						// Merge next and previous siblings if they are similar <b>text</b><b>text</b> becomes <b>texttext</b>
						if (node && format.merge_siblings !== false) {
							node = mergeSiblings(getNonWhiteSpaceSibling(node), node);
							node = mergeSiblings(node, getNonWhiteSpaceSibling(node, TRUE));
						}
					}
				});
			};

			if (format) {
				if (node) {
					rng = dom.createRng();

					rng.setStartBefore(node);
					rng.setEndAfter(node);

					applyRngStyle(expandRng(rng, formatList));
				} else {
					if (!isCollapsed || !format.inline || dom.select('td.mceSelected,th.mceSelected').length) {
						// Obtain selection node before selection is unselected by applyRngStyle()
						var curSelNode = ed.selection.getNode();

						// Apply formatting to selection
						ed.selection.setRng(adjustSelectionToVisibleSelection());
						bookmark = selection.getBookmark();
						applyRngStyle(expandRng(selection.getRng(TRUE), formatList), bookmark);

						// Colored nodes should be underlined so that the color of the underline matches the text color.
						if (format.styles && (format.styles.color || format.styles.textDecoration)) {
							tinymce.walk(curSelNode, processUnderlineAndColor, 'childNodes');
							processUnderlineAndColor(curSelNode);
						}

						selection.moveToBookmark(bookmark);
						selection.setRng(moveStart(selection.getRng(TRUE)));
						ed.nodeChanged();
					} else
						performCaretAction('apply', name, vars);
				}
			}
		};

		/**
		 * Removes the specified format from the current selection or specified node.
		 *
		 * @method remove
		 * @param {String} name Name of format to remove.
		 * @param {Object} vars Optional list of variables to replace within format before removing it.
		 * @param {Node} node Optional node to remove the format from defaults to current selection.
		 */
		function remove(name, vars, node) {
			var formatList = get(name), format = formatList[0], bookmark, i, rng;
			/**
			 * Moves the start to the first suitable text node.
			 */
			function moveStart(rng) {
				var container = rng.startContainer,
					offset = rng.startOffset,
					walker, node, nodes, tmpNode;

				// Convert text node into index if possible
				if (container.nodeType == 3 && offset >= container.nodeValue.length - 1) {
					container = container.parentNode;
					offset = nodeIndex(container) + 1;
				}

				// Move startContainer/startOffset in to a suitable node
				if (container.nodeType == 1) {
					nodes = container.childNodes;
					container = nodes[Math.min(offset, nodes.length - 1)];
					walker = new TreeWalker(container);

					// If offset is at end of the parent node walk to the next one
					if (offset > nodes.length - 1)
						walker.next();

					for (node = walker.current(); node; node = walker.next()) {
						if (node.nodeType == 3 && !isWhiteSpaceNode(node)) {
							// IE has a "neat" feature where it moves the start node into the closest element
							// we can avoid this by inserting an element before it and then remove it after we set the selection
							tmpNode = dom.create('a', null, INVISIBLE_CHAR);
							node.parentNode.insertBefore(tmpNode, node);

							// Set selection and remove tmpNode
							rng.setStart(node, 0);
							selection.setRng(rng);
							dom.remove(tmpNode);

							return;
						}
					}
				}
			};

			// Merges the styles for each node
			function process(node) {
				var children, i, l;

				// Grab the children first since the nodelist might be changed
				children = tinymce.grep(node.childNodes);

				// Process current node
				for (i = 0, l = formatList.length; i < l; i++) {
					if (removeFormat(formatList[i], vars, node, node))
						break;
				}

				// Process the children
				if (format.deep) {
					for (i = 0, l = children.length; i < l; i++)
						process(children[i]);
				}
			};

			function findFormatRoot(container) {
				var formatRoot;

				// Find format root
				each(getParents(container.parentNode).reverse(), function(parent) {
					var format;

					// Find format root element
					if (!formatRoot && parent.id != '_start' && parent.id != '_end') {
						// Is the node matching the format we are looking for
						format = matchNode(parent, name, vars);
						if (format && format.split !== false)
							formatRoot = parent;
					}
				});

				return formatRoot;
			};

			function wrapAndSplit(format_root, container, target, split) {
				var parent, clone, lastClone, firstClone, i, formatRootParent;

				// Format root found then clone formats and split it
				if (format_root) {
					formatRootParent = format_root.parentNode;

					for (parent = container.parentNode; parent && parent != formatRootParent; parent = parent.parentNode) {
						clone = parent.cloneNode(FALSE);

						for (i = 0; i < formatList.length; i++) {
							if (removeFormat(formatList[i], vars, clone, clone)) {
								clone = 0;
								break;
							}
						}

						// Build wrapper node
						if (clone) {
							if (lastClone)
								clone.appendChild(lastClone);

							if (!firstClone)
								firstClone = clone;

							lastClone = clone;
						}
					}

					// Never split block elements if the format is mixed
					if (split && (!format.mixed || !isBlock(format_root)))
						container = dom.split(format_root, container);

					// Wrap container in cloned formats
					if (lastClone) {
						target.parentNode.insertBefore(lastClone, target);
						firstClone.appendChild(target);
					}
				}

				return container;
			};

			function splitToFormatRoot(container) {
				return wrapAndSplit(findFormatRoot(container), container, container, true);
			};

			function unwrap(start) {
				var node = dom.get(start ? '_start' : '_end'),
					out = node[start ? 'firstChild' : 'lastChild'];

				// If the end is placed within the start the result will be removed
				// So this checks if the out node is a bookmark node if it is it
				// checks for another more suitable node
				if (isBookmarkNode(out))
					out = out[start ? 'firstChild' : 'lastChild'];

				dom.remove(node, true);

				return out;
			};

			function removeRngStyle(rng) {
				var startContainer, endContainer;

				rng = expandRng(rng, formatList, TRUE);

				if (format.split) {
					startContainer = getContainer(rng, TRUE);
					endContainer = getContainer(rng);

					if (startContainer != endContainer) {
						// Wrap start/end nodes in span element since these might be cloned/moved
						startContainer = wrap(startContainer, 'span', {id : '_start', 'data-mce-type' : 'bookmark'});
						endContainer = wrap(endContainer, 'span', {id : '_end', 'data-mce-type' : 'bookmark'});

						// Split start/end
						splitToFormatRoot(startContainer);
						splitToFormatRoot(endContainer);

						// Unwrap start/end to get real elements again
						startContainer = unwrap(TRUE);
						endContainer = unwrap();
					} else
						startContainer = endContainer = splitToFormatRoot(startContainer);

					// Update range positions since they might have changed after the split operations
					rng.startContainer = startContainer.parentNode;
					rng.startOffset = nodeIndex(startContainer);
					rng.endContainer = endContainer.parentNode;
					rng.endOffset = nodeIndex(endContainer) + 1;
				}

				// Remove items between start/end
				rangeUtils.walk(rng, function(nodes) {
					each(nodes, function(node) {
						process(node);

						// Remove parent span if it only contains text-decoration: underline, yet a parent node is also underlined.
						if (node.nodeType === 1 && ed.dom.getStyle(node, 'text-decoration') === 'underline' && node.parentNode && getTextDecoration(node.parentNode) === 'underline') {
							removeFormat({'deep': false, 'exact': true, 'inline': 'span', 'styles': {'textDecoration' : 'underline'}}, null, node);
						}
					});
				});
			};

			// Handle node
			if (node) {
				rng = dom.createRng();
				rng.setStartBefore(node);
				rng.setEndAfter(node);
				removeRngStyle(rng);
				return;
			}

			if (!selection.isCollapsed() || !format.inline || dom.select('td.mceSelected,th.mceSelected').length) {
				bookmark = selection.getBookmark();
				removeRngStyle(selection.getRng(TRUE));
				selection.moveToBookmark(bookmark);

				// Check if start element still has formatting then we are at: "<b>text|</b>text" and need to move the start into the next text node
				if (format.inline && match(name, vars, selection.getStart())) {
					moveStart(selection.getRng(true));
				}

				ed.nodeChanged();
			} else
				performCaretAction('remove', name, vars);
		};

		/**
		 * Toggles the specified format on/off.
		 *
		 * @method toggle
		 * @param {String} name Name of format to apply/remove.
		 * @param {Object} vars Optional list of variables to replace within format before applying/removing it.
		 * @param {Node} node Optional node to apply the format to or remove from. Defaults to current selection.
		 */
		function toggle(name, vars, node) {
			var fmt = get(name);

			if (match(name, vars, node) && (!('toggle' in fmt[0]) || fmt[0]['toggle']))
				remove(name, vars, node);
			else
				apply(name, vars, node);
		};

		/**
		 * Return true/false if the specified node has the specified format.
		 *
		 * @method matchNode
		 * @param {Node} node Node to check the format on.
		 * @param {String} name Format name to check.
		 * @param {Object} vars Optional list of variables to replace before checking it.
		 * @param {Boolean} similar Match format that has similar properties.
		 * @return {Object} Returns the format object it matches or undefined if it doesn't match.
		 */
		function matchNode(node, name, vars, similar) {
			var formatList = get(name), format, i, classes;

			function matchItems(node, format, item_name) {
				var key, value, items = format[item_name], i;

				// Custom match
				if (format.onmatch) {
					return format.onmatch(node, format, item_name);
				}

				// Check all items
				if (items) {
					// Non indexed object
					if (items.length === undefined) {
						for (key in items) {
							if (items.hasOwnProperty(key)) {
								if (item_name === 'attributes')
									value = dom.getAttrib(node, key);
								else
									value = getStyle(node, key);

								if (similar && !value && !format.exact)
									return;

								if ((!similar || format.exact) && !isEq(value, replaceVars(items[key], vars)))
									return;
							}
						}
					} else {
						// Only one match needed for indexed arrays
						for (i = 0; i < items.length; i++) {
							if (item_name === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(node, items[i]))
								return format;
						}
					}
				}

				return format;
			};

			if (formatList && node) {
				// Check each format in list
				for (i = 0; i < formatList.length; i++) {
					format = formatList[i];

					// Name name, attributes, styles and classes
					if (matchName(node, format) && matchItems(node, format, 'attributes') && matchItems(node, format, 'styles')) {
						// Match classes
						if (classes = format.classes) {
							for (i = 0; i < classes.length; i++) {
								if (!dom.hasClass(node, classes[i]))
									return;
							}
						}

						return format;
					}
				}
			}
		};

		/**
		 * Matches the current selection or specified node against the specified format name.
		 *
		 * @method match
		 * @param {String} name Name of format to match.
		 * @param {Object} vars Optional list of variables to replace before checking it.
		 * @param {Node} node Optional node to check.
		 * @return {boolean} true/false if the specified selection/node matches the format.
		 */
		function match(name, vars, node) {
			var startNode, i;

			function matchParents(node) {
				// Find first node with similar format settings
				node = dom.getParent(node, function(node) {
					return !!matchNode(node, name, vars, true);
				});

				// Do an exact check on the similar format element
				return matchNode(node, name, vars);
			};

			// Check specified node
			if (node)
				return matchParents(node);

			// Check pending formats
			if (selection.isCollapsed()) {
				for (i = pendingFormats.apply.length - 1; i >= 0; i--) {
					if (pendingFormats.apply[i].name == name)
						return true;
				}

				for (i = pendingFormats.remove.length - 1; i >= 0; i--) {
					if (pendingFormats.remove[i].name == name)
						return false;
				}

				return matchParents(selection.getNode());
			}

			// Check selected node
			node = selection.getNode();
			if (matchParents(node))
				return TRUE;

			// Check start node if it's different
			startNode = selection.getStart();
			if (startNode != node) {
				if (matchParents(startNode))
					return TRUE;
			}

			return FALSE;
		};

		/**
		 * Matches the current selection against the array of formats and returns a new array with matching formats.
		 *
		 * @method matchAll
		 * @param {Array} names Name of format to match.
		 * @param {Object} vars Optional list of variables to replace before checking it.
		 * @return {Array} Array with matched formats.
		 */
		function matchAll(names, vars) {
			var startElement, matchedFormatNames = [], checkedMap = {}, i, ni, name;

			// If the selection is collapsed then check pending formats
			if (selection.isCollapsed()) {
				for (ni = 0; ni < names.length; ni++) {
					// If the name is to be removed, then stop it from being added
					for (i = pendingFormats.remove.length - 1; i >= 0; i--) {
						name = names[ni];

						if (pendingFormats.remove[i].name == name) {
							checkedMap[name] = true;
							break;
						}
					}
				}

				// If the format is to be applied
				for (i = pendingFormats.apply.length - 1; i >= 0; i--) {
					for (ni = 0; ni < names.length; ni++) {
						name = names[ni];

						if (!checkedMap[name] && pendingFormats.apply[i].name == name) {
							checkedMap[name] = true;
							matchedFormatNames.push(name);
						}
					}
				}
			}

			// Check start of selection for formats
			startElement = selection.getStart();
			dom.getParent(startElement, function(node) {
				var i, name;

				for (i = 0; i < names.length; i++) {
					name = names[i];

					if (!checkedMap[name] && matchNode(node, name, vars)) {
						checkedMap[name] = true;
						matchedFormatNames.push(name);
					}
				}
			});

			return matchedFormatNames;
		};

		/**
		 * Returns true/false if the specified format can be applied to the current selection or not. It will currently only check the state for selector formats, it returns true on all other format types.
		 *
		 * @method canApply
		 * @param {String} name Name of format to check.
		 * @return {boolean} true/false if the specified format can be applied to the current selection/node.
		 */
		function canApply(name) {
			var formatList = get(name), startNode, parents, i, x, selector;

			if (formatList) {
				startNode = selection.getStart();
				parents = getParents(startNode);

				for (x = formatList.length - 1; x >= 0; x--) {
					selector = formatList[x].selector;

					// Format is not selector based, then always return TRUE
					if (!selector)
						return TRUE;

					for (i = parents.length - 1; i >= 0; i--) {
						if (dom.is(parents[i], selector))
							return TRUE;
					}
				}
			}

			return FALSE;
		};

		// Expose to public
		tinymce.extend(this, {
			get : get,
			register : register,
			apply : apply,
			remove : remove,
			toggle : toggle,
			match : match,
			matchAll : matchAll,
			matchNode : matchNode,
			canApply : canApply
		});

		// Private functions

		/**
		 * Checks if the specified nodes name matches the format inline/block or selector.
		 *
		 * @private
		 * @param {Node} node Node to match against the specified format.
		 * @param {Object} format Format object o match with.
		 * @return {boolean} true/false if the format matches.
		 */
		function matchName(node, format) {
			// Check for inline match
			if (isEq(node, format.inline))
				return TRUE;

			// Check for block match
			if (isEq(node, format.block))
				return TRUE;

			// Check for selector match
			if (format.selector)
				return dom.is(node, format.selector);
		};

		/**
		 * Compares two string/nodes regardless of their case.
		 *
		 * @private
		 * @param {String/Node} Node or string to compare.
		 * @param {String/Node} Node or string to compare.
		 * @return {boolean} True/false if they match.
		 */
		function isEq(str1, str2) {
			str1 = str1 || '';
			str2 = str2 || '';

			str1 = '' + (str1.nodeName || str1);
			str2 = '' + (str2.nodeName || str2);

			return str1.toLowerCase() == str2.toLowerCase();
		};

		/**
		 * Returns the style by name on the specified node. This method modifies the style
		 * contents to make it more easy to match. This will resolve a few browser issues.
		 *
		 * @private
		 * @param {Node} node to get style from.
		 * @param {String} name Style name to get.
		 * @return {String} Style item value.
		 */
		function getStyle(node, name) {
			var styleVal = dom.getStyle(node, name);

			// Force the format to hex
			if (name == 'color' || name == 'backgroundColor')
				styleVal = dom.toHex(styleVal);

			// Opera will return bold as 700
			if (name == 'fontWeight' && styleVal == 700)
				styleVal = 'bold';

			return '' + styleVal;
		};

		/**
		 * Replaces variables in the value. The variable format is %var.
		 *
		 * @private
		 * @param {String} value Value to replace variables in.
		 * @param {Object} vars Name/value array with variables to replace.
		 * @return {String} New value with replaced variables.
		 */
		function replaceVars(value, vars) {
			if (typeof(value) != "string")
				value = value(vars);
			else if (vars) {
				value = value.replace(/%(\w+)/g, function(str, name) {
					return vars[name] || str;
				});
			}

			return value;
		};

		function isWhiteSpaceNode(node) {
			return node && node.nodeType === 3 && /^([\s\r\n]+|)$/.test(node.nodeValue);
		};

		function wrap(node, name, attrs) {
			var wrapper = dom.create(name, attrs);

			node.parentNode.insertBefore(wrapper, node);
			wrapper.appendChild(node);

			return wrapper;
		};

		/**
		 * Expands the specified range like object to depending on format.
		 *
		 * For example on block formats it will move the start/end position
		 * to the beginning of the current block.
		 *
		 * @private
		 * @param {Object} rng Range like object.
		 * @param {Array} formats Array with formats to expand by.
		 * @return {Object} Expanded range like object.
		 */
		function expandRng(rng, format, remove) {
			var startContainer = rng.startContainer,
				startOffset = rng.startOffset,
				endContainer = rng.endContainer,
				endOffset = rng.endOffset, sibling, lastIdx, leaf;

			// This function walks up the tree if there is no siblings before/after the node
			function findParentContainer(container, child_name, sibling_name, root) {
				var parent, child;

				root = root || dom.getRoot();

				for (;;) {
					// Check if we can move up are we at root level or body level
					parent = container.parentNode;

					// Stop expanding on block elements or root depending on format
					if (parent == root || (!format[0].block_expand && isBlock(parent)))
						return container;

					for (sibling = parent[child_name]; sibling && sibling != container; sibling = sibling[sibling_name]) {
						if (sibling.nodeType == 1 && !isBookmarkNode(sibling))
							return container;

						if (sibling.nodeType == 3 && !isWhiteSpaceNode(sibling))
							return container;
					}

					container = container.parentNode;
				}

				return container;
			};

			// This function walks down the tree to find the leaf at the selection.
			// The offset is also returned as if node initially a leaf, the offset may be in the middle of the text node.
			function findLeaf(node, offset) {
				if (offset === undefined)
					offset = node.nodeType === 3 ? node.length : node.childNodes.length;
				while (node && node.hasChildNodes()) {
					node = node.childNodes[offset];
					if (node)
						offset = node.nodeType === 3 ? node.length : node.childNodes.length;
				}
				return { node: node, offset: offset };
			}

			// If index based start position then resolve it
			if (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {
				lastIdx = startContainer.childNodes.length - 1;
				startContainer = startContainer.childNodes[startOffset > lastIdx ? lastIdx : startOffset];

				if (startContainer.nodeType == 3)
					startOffset = 0;
			}

			// If index based end position then resolve it
			if (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {
				lastIdx = endContainer.childNodes.length - 1;
				endContainer = endContainer.childNodes[endOffset > lastIdx ? lastIdx : endOffset - 1];

				if (endContainer.nodeType == 3)
					endOffset = endContainer.nodeValue.length;
			}

			// Exclude bookmark nodes if possible
			if (isBookmarkNode(startContainer.parentNode))
				startContainer = startContainer.parentNode;

			if (isBookmarkNode(startContainer))
				startContainer = startContainer.nextSibling || startContainer;

			if (isBookmarkNode(endContainer.parentNode)) {
				endOffset = dom.nodeIndex(endContainer);
				endContainer = endContainer.parentNode;
			}

			if (isBookmarkNode(endContainer) && endContainer.previousSibling) {
				endContainer = endContainer.previousSibling;
				endOffset = endContainer.length;
			}

			if (format[0].inline) {
				// Avoid applying formatting to a trailing space.
				leaf = findLeaf(endContainer, endOffset);
				if (leaf.node) {
					while (leaf.node && leaf.offset === 0 && leaf.node.previousSibling)
						leaf = findLeaf(leaf.node.previousSibling);

					if (leaf.node && leaf.offset > 0 && leaf.node.nodeType === 3 &&
							leaf.node.nodeValue.charAt(leaf.offset - 1) === ' ') {

						if (leaf.offset > 1) {
							endContainer = leaf.node;
							endContainer.splitText(leaf.offset - 1);
						} else if (leaf.node.previousSibling) {
							endContainer = leaf.node.previousSibling;
						}
					}
				}
			}

			// Move start/end point up the tree if the leaves are sharp and if we are in different containers
			// Example * becomes !: !<p><b><i>*text</i><i>text*</i></b></p>!
			// This will reduce the number of wrapper elements that needs to be created
			// Move start point up the tree
			if (format[0].inline || format[0].block_expand) {
				startContainer = findParentContainer(startContainer, 'firstChild', 'nextSibling');
				endContainer = findParentContainer(endContainer, 'lastChild', 'previousSibling');
			}

			// Expand start/end container to matching selector
			if (format[0].selector && format[0].expand !== FALSE && !format[0].inline) {
				function findSelectorEndPoint(container, sibling_name) {
					var parents, i, y, curFormat;

					if (container.nodeType == 3 && container.nodeValue.length == 0 && container[sibling_name])
						container = container[sibling_name];

					parents = getParents(container);
					for (i = 0; i < parents.length; i++) {
						for (y = 0; y < format.length; y++) {
							curFormat = format[y];

							// If collapsed state is set then skip formats that doesn't match that
							if ("collapsed" in curFormat && curFormat.collapsed !== rng.collapsed)
								continue;

							if (dom.is(parents[i], curFormat.selector))
								return parents[i];
						}
					}

					return container;
				};

				// Find new startContainer/endContainer if there is better one
				startContainer = findSelectorEndPoint(startContainer, 'previousSibling');
				endContainer = findSelectorEndPoint(endContainer, 'nextSibling');
			}

			// Expand start/end container to matching block element or text node
			if (format[0].block || format[0].selector) {
				function findBlockEndPoint(container, sibling_name, sibling_name2) {
					var node;

					// Expand to block of similar type
					if (!format[0].wrapper)
						node = dom.getParent(container, format[0].block);

					// Expand to first wrappable block element or any block element
					if (!node)
						node = dom.getParent(container.nodeType == 3 ? container.parentNode : container, isBlock);

					// Exclude inner lists from wrapping
					if (node && format[0].wrapper)
						node = getParents(node, 'ul,ol').reverse()[0] || node;

					// Didn't find a block element look for first/last wrappable element
					if (!node) {
						node = container;

						while (node[sibling_name] && !isBlock(node[sibling_name])) {
							node = node[sibling_name];

							// Break on BR but include it will be removed later on
							// we can't remove it now since we need to check if it can be wrapped
							if (isEq(node, 'br'))
								break;
						}
					}

					return node || container;
				};

				// Find new startContainer/endContainer if there is better one
				startContainer = findBlockEndPoint(startContainer, 'previousSibling');
				endContainer = findBlockEndPoint(endContainer, 'nextSibling');

				// Non block element then try to expand up the leaf
				if (format[0].block) {
					if (!isBlock(startContainer))
						startContainer = findParentContainer(startContainer, 'firstChild', 'nextSibling');

					if (!isBlock(endContainer))
						endContainer = findParentContainer(endContainer, 'lastChild', 'previousSibling');
				}
			}

			// Setup index for startContainer
			if (startContainer.nodeType == 1) {
				startOffset = nodeIndex(startContainer);
				startContainer = startContainer.parentNode;
			}

			// Setup index for endContainer
			if (endContainer.nodeType == 1) {
				endOffset = nodeIndex(endContainer) + 1;
				endContainer = endContainer.parentNode;
			}

			// Return new range like object
			return {
				startContainer : startContainer,
				startOffset : startOffset,
				endContainer : endContainer,
				endOffset : endOffset
			};
		}

		/**
		 * Removes the specified format for the specified node. It will also remove the node if it doesn't have
		 * any attributes if the format specifies it to do so.
		 *
		 * @private
		 * @param {Object} format Format object with items to remove from node.
		 * @param {Object} vars Name/value object with variables to apply to format.
		 * @param {Node} node Node to remove the format styles on.
		 * @param {Node} compare_node Optional compare node, if specified the styles will be compared to that node.
		 * @return {Boolean} True/false if the node was removed or not.
		 */
		function removeFormat(format, vars, node, compare_node) {
			var i, attrs, stylesModified;

			// Check if node matches format
			if (!matchName(node, format))
				return FALSE;

			// Should we compare with format attribs and styles
			if (format.remove != 'all') {
				// Remove styles
				each(format.styles, function(value, name) {
					value = replaceVars(value, vars);

					// Indexed array
					if (typeof(name) === 'number') {
						name = value;
						compare_node = 0;
					}

					if (!compare_node || isEq(getStyle(compare_node, name), value))
						dom.setStyle(node, name, '');

					stylesModified = 1;
				});

				// Remove style attribute if it's empty
				if (stylesModified && dom.getAttrib(node, 'style') == '') {
					node.removeAttribute('style');
					node.removeAttribute('data-mce-style');
				}

				// Remove attributes
				each(format.attributes, function(value, name) {
					var valueOut;

					value = replaceVars(value, vars);

					// Indexed array
					if (typeof(name) === 'number') {
						name = value;
						compare_node = 0;
					}

					if (!compare_node || isEq(dom.getAttrib(compare_node, name), value)) {
						// Keep internal classes
						if (name == 'class') {
							value = dom.getAttrib(node, name);
							if (value) {
								// Build new class value where everything is removed except the internal prefixed classes
								valueOut = '';
								each(value.split(/\s+/), function(cls) {
									if (/mce\w+/.test(cls))
										valueOut += (valueOut ? ' ' : '') + cls;
								});

								// We got some internal classes left
								if (valueOut) {
									dom.setAttrib(node, name, valueOut);
									return;
								}
							}
						}

						// IE6 has a bug where the attribute doesn't get removed correctly
						if (name == "class")
							node.removeAttribute('className');

						// Remove mce prefixed attributes
						if (MCE_ATTR_RE.test(name))
							node.removeAttribute('data-mce-' + name);

						node.removeAttribute(name);
					}
				});

				// Remove classes
				each(format.classes, function(value) {
					value = replaceVars(value, vars);

					if (!compare_node || dom.hasClass(compare_node, value))
						dom.removeClass(node, value);
				});

				// Check for non internal attributes
				attrs = dom.getAttribs(node);
				for (i = 0; i < attrs.length; i++) {
					if (attrs[i].nodeName.indexOf('_') !== 0)
						return FALSE;
				}
			}

			// Remove the inline child if it's empty for example <b> or <span>
			if (format.remove != 'none') {
				removeNode(node, format);
				return TRUE;
			}
		};

		/**
		 * Removes the node and wrap it's children in paragraphs before doing so or
		 * appends BR elements to the beginning/end of the block element if forcedRootBlocks is disabled.
		 *
		 * If the div in the node below gets removed:
		 *  text<div>text</div>text
		 *
		 * Output becomes:
		 *  text<div><br />text<br /></div>text
		 *
		 * So when the div is removed the result is:
		 *  text<br />text<br />text
		 *
		 * @private
		 * @param {Node} node Node to remove + apply BR/P elements to.
		 * @param {Object} format Format rule.
		 * @return {Node} Input node.
		 */
		function removeNode(node, format) {
			var parentNode = node.parentNode, rootBlockElm;

			if (format.block) {
				if (!forcedRootBlock) {
					function find(node, next, inc) {
						node = getNonWhiteSpaceSibling(node, next, inc);

						return !node || (node.nodeName == 'BR' || isBlock(node));
					};

					// Append BR elements if needed before we remove the block
					if (isBlock(node) && !isBlock(parentNode)) {
						if (!find(node, FALSE) && !find(node.firstChild, TRUE, 1))
							node.insertBefore(dom.create('br'), node.firstChild);

						if (!find(node, TRUE) && !find(node.lastChild, FALSE, 1))
							node.appendChild(dom.create('br'));
					}
				} else {
					// Wrap the block in a forcedRootBlock if we are at the root of document
					if (parentNode == dom.getRoot()) {
						if (!format.list_block || !isEq(node, format.list_block)) {
							each(tinymce.grep(node.childNodes), function(node) {
								if (isValid(forcedRootBlock, node.nodeName.toLowerCase())) {
									if (!rootBlockElm)
										rootBlockElm = wrap(node, forcedRootBlock);
									else
										rootBlockElm.appendChild(node);
								} else
									rootBlockElm = 0;
							});
						}
					}
				}
			}

			// Never remove nodes that isn't the specified inline element if a selector is specified too
			if (format.selector && format.inline && !isEq(format.inline, node))
				return;

			dom.remove(node, 1);
		};

		/**
		 * Returns the next/previous non whitespace node.
		 *
		 * @private
		 * @param {Node} node Node to start at.
		 * @param {boolean} next (Optional) Include next or previous node defaults to previous.
		 * @param {boolean} inc (Optional) Include the current node in checking. Defaults to false.
		 * @return {Node} Next or previous node or undefined if it wasn't found.
		 */
		function getNonWhiteSpaceSibling(node, next, inc) {
			if (node) {
				next = next ? 'nextSibling' : 'previousSibling';

				for (node = inc ? node : node[next]; node; node = node[next]) {
					if (node.nodeType == 1 || !isWhiteSpaceNode(node))
						return node;
				}
			}
		};

		/**
		 * Checks if the specified node is a bookmark node or not.
		 *
		 * @param {Node} node Node to check if it's a bookmark node or not.
		 * @return {Boolean} true/false if the node is a bookmark node.
		 */
		function isBookmarkNode(node) {
			return node && node.nodeType == 1 && node.getAttribute('data-mce-type') == 'bookmark';
		};

		/**
		 * Merges the next/previous sibling element if they match.
		 *
		 * @private
		 * @param {Node} prev Previous node to compare/merge.
		 * @param {Node} next Next node to compare/merge.
		 * @return {Node} Next node if we didn't merge and prev node if we did.
		 */
		function mergeSiblings(prev, next) {
			var marker, sibling, tmpSibling;

			/**
			 * Compares two nodes and checks if it's attributes and styles matches.
			 * This doesn't compare classes as items since their order is significant.
			 *
			 * @private
			 * @param {Node} node1 First node to compare with.
			 * @param {Node} node2 Second node to compare with.
			 * @return {boolean} True/false if the nodes are the same or not.
			 */
			function compareElements(node1, node2) {
				// Not the same name
				if (node1.nodeName != node2.nodeName)
					return FALSE;

				/**
				 * Returns all the nodes attributes excluding internal ones, styles and classes.
				 *
				 * @private
				 * @param {Node} node Node to get attributes from.
				 * @return {Object} Name/value object with attributes and attribute values.
				 */
				function getAttribs(node) {
					var attribs = {};

					each(dom.getAttribs(node), function(attr) {
						var name = attr.nodeName.toLowerCase();

						// Don't compare internal attributes or style
						if (name.indexOf('_') !== 0 && name !== 'style')
							attribs[name] = dom.getAttrib(node, name);
					});

					return attribs;
				};

				/**
				 * Compares two objects checks if it's key + value exists in the other one.
				 *
				 * @private
				 * @param {Object} obj1 First object to compare.
				 * @param {Object} obj2 Second object to compare.
				 * @return {boolean} True/false if the objects matches or not.
				 */
				function compareObjects(obj1, obj2) {
					var value, name;

					for (name in obj1) {
						// Obj1 has item obj2 doesn't have
						if (obj1.hasOwnProperty(name)) {
							value = obj2[name];

							// Obj2 doesn't have obj1 item
							if (value === undefined)
								return FALSE;

							// Obj2 item has a different value
							if (obj1[name] != value)
								return FALSE;

							// Delete similar value
							delete obj2[name];
						}
					}

					// Check if obj 2 has something obj 1 doesn't have
					for (name in obj2) {
						// Obj2 has item obj1 doesn't have
						if (obj2.hasOwnProperty(name))
							return FALSE;
					}

					return TRUE;
				};

				// Attribs are not the same
				if (!compareObjects(getAttribs(node1), getAttribs(node2)))
					return FALSE;

				// Styles are not the same
				if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style'))))
					return FALSE;

				return TRUE;
			};

			// Check if next/prev exists and that they are elements
			if (prev && next) {
				function findElementSibling(node, sibling_name) {
					for (sibling = node; sibling; sibling = sibling[sibling_name]) {
						if (sibling.nodeType == 3 && sibling.nodeValue.length !== 0)
							return node;

						if (sibling.nodeType == 1 && !isBookmarkNode(sibling))
							return sibling;
					}

					return node;
				};

				// If previous sibling is empty then jump over it
				prev = findElementSibling(prev, 'previousSibling');
				next = findElementSibling(next, 'nextSibling');

				// Compare next and previous nodes
				if (compareElements(prev, next)) {
					// Append nodes between
					for (sibling = prev.nextSibling; sibling && sibling != next;) {
						tmpSibling = sibling;
						sibling = sibling.nextSibling;
						prev.appendChild(tmpSibling);
					}

					// Remove next node
					dom.remove(next);

					// Move children into prev node
					each(tinymce.grep(next.childNodes), function(node) {
						prev.appendChild(node);
					});

					return prev;
				}
			}

			return next;
		};

		/**
		 * Returns true/false if the specified node is a text block or not.
		 *
		 * @private
		 * @param {Node} node Node to check.
		 * @return {boolean} True/false if the node is a text block.
		 */
		function isTextBlock(name) {
			return /^(h[1-6]|p|div|pre|address|dl|dt|dd)$/.test(name);
		};

		function getContainer(rng, start) {
			var container, offset, lastIdx;

			container = rng[start ? 'startContainer' : 'endContainer'];
			offset = rng[start ? 'startOffset' : 'endOffset'];

			if (container.nodeType == 1) {
				lastIdx = container.childNodes.length - 1;

				if (!start && offset)
					offset--;

				container = container.childNodes[offset > lastIdx ? lastIdx : offset];
			}

			return container;
		};

		function performCaretAction(type, name, vars) {
			var i, currentPendingFormats = pendingFormats[type],
				otherPendingFormats = pendingFormats[type == 'apply' ? 'remove' : 'apply'];

			function hasPending() {
				return pendingFormats.apply.length || pendingFormats.remove.length;
			};

			function resetPending() {
				pendingFormats.apply = [];
				pendingFormats.remove = [];
			};

			function perform(caret_node) {
				// Apply pending formats
				each(pendingFormats.apply.reverse(), function(item) {
					apply(item.name, item.vars, caret_node);

					// Colored nodes should be underlined so that the color of the underline matches the text color.
					if (item.name === 'forecolor' && item.vars.value)
						processUnderlineAndColor(caret_node.parentNode);
				});

				// Remove pending formats
				each(pendingFormats.remove.reverse(), function(item) {
					remove(item.name, item.vars, caret_node);
				});

				dom.remove(caret_node, 1);
				resetPending();
			};

			// Check if it already exists then ignore it
			for (i = currentPendingFormats.length - 1; i >= 0; i--) {
				if (currentPendingFormats[i].name == name)
					return;
			}

			currentPendingFormats.push({name : name, vars : vars});

			// Check if it's in the other type, then remove it
			for (i = otherPendingFormats.length - 1; i >= 0; i--) {
				if (otherPendingFormats[i].name == name)
					otherPendingFormats.splice(i, 1);
			}

			// Pending apply or remove formats
			if (hasPending()) {

				if (tinymce.isIE) {
					selection.setContent('<font face="mceinline">&#65279;</font>', {'format': 'raw'});
				}
				else {
					ed.getDoc().execCommand('FontName', false, 'mceinline');
				}

				pendingFormats.lastRng = selection.getRng();

				// IE will convert the current word
				each(dom.select('font,span'), function(node) {
					var bookmark;

					if (isCaretNode(node)) {
						bookmark = selection.getBookmark();
						perform(node);
						selection.moveToBookmark(bookmark);
						ed.nodeChanged();
					}
				});

				// Only register listeners once if we need to
				if (!pendingFormats.isListening && hasPending()) {
					pendingFormats.isListening = true;
					function performPendingFormat(node, textNode) {
						var rng = dom.createRng();
						perform(node);

						rng.setStart(textNode, textNode.nodeValue.length);
						rng.setEnd(textNode, textNode.nodeValue.length);
						selection.setRng(rng);
						ed.nodeChanged();
					}
					var enterKeyPressed = false;

					each('onKeyDown,onKeyUp,onKeyPress,onMouseUp'.split(','), function(event) {
						ed[event].addToTop(function(ed, e) {
							if (e.keyCode==13 && !e.shiftKey) {
								enterKeyPressed = true;
								return;
							}
							// Do we have pending formats and is the selection moved has moved
							if (hasPending() && !tinymce.dom.RangeUtils.compareRanges(pendingFormats.lastRng, selection.getRng())) {
								var foundCaret = false;
								each(dom.select('font,span'), function(node) {
									var textNode, rng;

									// Look for marker
									if (isCaretNode(node)) {
										foundCaret = true;
										textNode = node.firstChild;

										// Find the first text node within node
										while (textNode && textNode.nodeType != 3)
											textNode = textNode.firstChild;

										if (textNode)
											performPendingFormat(node, textNode);
										else
											dom.remove(node);
									}
								});

								// no caret - so we are
								if (enterKeyPressed && !foundCaret) {
									var node = selection.getNode();
									var textNode = node;

									// Find the first text node within node
									while (textNode && textNode.nodeType != 3)
										textNode = textNode.firstChild;
									if (textNode) {
										node=textNode.parentNode;
										while (!isBlock(node)){
											node=node.parentNode;
										}
										performPendingFormat(node, textNode);
									}
								}

								// Always unbind and clear pending styles on keyup
								if (e.type == 'keyup' || e.type == 'mouseup') {
									resetPending();
									enterKeyPressed=false;
								}
							}
						});
					});
				}
			}
		};
	};
})(tinymce);
/**
 * LegacyInput.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

tinymce.onAddEditor.add(function(tinymce, ed) {
	var filters, fontSizes, dom, settings = ed.settings;

	if (settings.inline_styles) {
		fontSizes = tinymce.explode(settings.font_size_style_values);

		function replaceWithSpan(node, styles) {
			tinymce.each(styles, function(value, name) {
				if (value)
					dom.setStyle(node, name, value);
			});

			dom.rename(node, 'span');
		};

		filters = {
			font : function(dom, node) {
				replaceWithSpan(node, {
					backgroundColor : node.style.backgroundColor,
					color : node.color,
					fontFamily : node.face,
					fontSize : fontSizes[parseInt(node.size) - 1]
				});
			},

			u : function(dom, node) {
				replaceWithSpan(node, {
					textDecoration : 'underline'
				});
			},

			strike : function(dom, node) {
				replaceWithSpan(node, {
					textDecoration : 'line-through'
				});
			}
		};

		function convert(editor, params) {
			dom = editor.dom;

			if (settings.convert_fonts_to_spans) {
				tinymce.each(dom.select('font,u,strike', params.node), function(node) {
					filters[node.nodeName.toLowerCase()](ed.dom, node);
				});
			}
		};

		ed.onPreProcess.add(convert);
		ed.onSetContent.add(convert);

		ed.onInit.add(function() {
			ed.selection.onSetContent.add(convert);
		});
	}
});
/**
 * editor_plugin_src.js
 *
 * Copyright 2011, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function() {
	var each = tinymce.each, Event = tinymce.dom.Event, bookmark;

	// Skips text nodes that only contain whitespace since they aren't semantically important.
	function skipWhitespaceNodes(e, next) {
		while (e && (e.nodeType === 8 || (e.nodeType === 3 && /^[ \t\n\r]*$/.test(e.nodeValue)))) {
			e = next(e);
		}
		return e;
	}

	function skipWhitespaceNodesBackwards(e) {
		return skipWhitespaceNodes(e, function(e) {
			return e.previousSibling;
		});
	}

	function skipWhitespaceNodesForwards(e) {
		return skipWhitespaceNodes(e, function(e) {
			return e.nextSibling;
		});
	}

	function hasParentInList(ed, e, list) {
		return ed.dom.getParent(e, function(p) {
			return tinymce.inArray(list, p) !== -1;
		});
	}

	function isList(e) {
		return e && (e.tagName === 'OL' || e.tagName === 'UL');
	}

	function splitNestedLists(element, dom) {
		var tmp, nested, wrapItem;
		tmp = skipWhitespaceNodesBackwards(element.lastChild);
		while (isList(tmp)) {
			nested = tmp;
			tmp = skipWhitespaceNodesBackwards(nested.previousSibling);
		}
		if (nested) {
			wrapItem = dom.create('li', { style: 'list-style-type: none;'});
			dom.split(element, nested);
			dom.insertAfter(wrapItem, nested);
			wrapItem.appendChild(nested);
			wrapItem.appendChild(nested);
			element = wrapItem.previousSibling;
		}
		return element;
	}

	function attemptMergeWithAdjacent(e, allowDifferentListStyles, mergeParagraphs) {
		e = attemptMergeWithPrevious(e, allowDifferentListStyles, mergeParagraphs);
		return attemptMergeWithNext(e, allowDifferentListStyles, mergeParagraphs);
	}

	function attemptMergeWithPrevious(e, allowDifferentListStyles, mergeParagraphs) {
		var prev = skipWhitespaceNodesBackwards(e.previousSibling);
		if (prev) {
			return attemptMerge(prev, e, allowDifferentListStyles ? prev : false, mergeParagraphs);
		} else {
			return e;
		}
	}

	function attemptMergeWithNext(e, allowDifferentListStyles, mergeParagraphs) {
		var next = skipWhitespaceNodesForwards(e.nextSibling);
		if (next) {
			return attemptMerge(e, next, allowDifferentListStyles ? next : false, mergeParagraphs);
		} else {
			return e;
		}
	}

	function attemptMerge(e1, e2, differentStylesMasterElement, mergeParagraphs) {
		if (canMerge(e1, e2, !!differentStylesMasterElement, mergeParagraphs)) {
			return merge(e1, e2, differentStylesMasterElement);
		} else if (e1 && e1.tagName === 'LI' && isList(e2)) {
			// Fix invalidly nested lists.
			e1.appendChild(e2);
		}
		return e2;
	}

	function canMerge(e1, e2, allowDifferentListStyles, mergeParagraphs) {
		if (!e1 || !e2) {
			return false;
		} else if (e1.tagName === 'LI' && e2.tagName === 'LI') {
			return e2.style.listStyleType === 'none' || containsOnlyAList(e2);
		} else if (isList(e1)) {
			return (e1.tagName === e2.tagName && (allowDifferentListStyles || e1.style.listStyleType === e2.style.listStyleType)) || isListForIndent(e2);
		} else if (mergeParagraphs && e1.tagName === 'P' && e2.tagName === 'P') {
			return true;
		} else {
			return false;
		}
	}

	function isListForIndent(e) {
		var firstLI = skipWhitespaceNodesForwards(e.firstChild), lastLI = skipWhitespaceNodesBackwards(e.lastChild);
		return firstLI && lastLI && isList(e) && firstLI === lastLI && (isList(firstLI) || firstLI.style.listStyleType === 'none' || containsOnlyAList(firstLI));
	}

	function containsOnlyAList(e) {
		var firstChild = skipWhitespaceNodesForwards(e.firstChild), lastChild = skipWhitespaceNodesBackwards(e.lastChild);
		return firstChild && lastChild && firstChild === lastChild && isList(firstChild);
	}

	function merge(e1, e2, masterElement) {
		var lastOriginal = skipWhitespaceNodesBackwards(e1.lastChild), firstNew = skipWhitespaceNodesForwards(e2.firstChild);
		if (e1.tagName === 'P') {
			e1.appendChild(e1.ownerDocument.createElement('br'));
		}
		while (e2.firstChild) {
			e1.appendChild(e2.firstChild);
		}
		if (masterElement) {
			e1.style.listStyleType = masterElement.style.listStyleType;
		}
		e2.parentNode.removeChild(e2);
		attemptMerge(lastOriginal, firstNew, false);
		return e1;
	}

	function findItemToOperateOn(e, dom) {
		var item;
		if (!dom.is(e, 'li,ol,ul')) {
			item = dom.getParent(e, 'li');
			if (item) {
				e = item;
			}
		}
		return e;
	}

	tinymce.create('tinymce.plugins.Lists', {
		init: function(ed, url) {
			var LIST_TABBING = 0;
			var LIST_EMPTY_ITEM = 1;
			var LIST_ESCAPE = 2;
			var LIST_UNKNOWN = 3;
			var state = LIST_UNKNOWN;

			function isTabInList(e) {
				return e.keyCode === 9 && (ed.queryCommandState('InsertUnorderedList') || ed.queryCommandState('InsertOrderedList'));
			}

			function isOnLastListItem() {
				var li = getLi();
				var grandParent = li.parentNode.parentNode;
				var isLastItem = li.parentNode.lastChild === li;
				return isLastItem && !isNestedList(grandParent) && isEmptyListItem(li);
			}

			function isNestedList(grandParent) {
				if (isList(grandParent)) {
					return grandParent.parentNode && grandParent.parentNode.tagName === 'LI';
				} else {
					return  grandParent.tagName === 'LI';
				}
			}

			function isInEmptyListItem() {
				return ed.selection.isCollapsed() && isEmptyListItem(getLi());
			}

			function getLi() {
				var n = ed.selection.getStart();
				// Get start will return BR if the LI only contains a BR or an empty element as we use these to fix caret position
				return ((n.tagName == 'BR' || n.tagName == '') && n.parentNode.tagName == 'LI') ? n.parentNode : n;
			}

			function isEmptyListItem(li) {
				var numChildren = li.childNodes.length;
				if (li.tagName === 'LI') {
					return numChildren == 0 ? true : numChildren == 1 && (li.firstChild.tagName == '' || isEmptyWebKitLi(li) || isEmptyIE9Li(li));
				}
				return false;
			}

			function isEmptyWebKitLi(li) {
				// Check for empty LI or a LI with just a child that is a BR since Gecko and WebKit uses BR elements to place the caret
				return tinymce.isWebKit && li.firstChild.nodeName == 'BR';
			}

			function isEmptyIE9Li(li) {
				// only consider this to be last item if there is no list item content or that content is nbsp or space since IE9 creates these
				var lis = tinymce.grep(li.parentNode.childNodes, function(n) {return n.nodeName == 'LI'});
				var isLastLi = li == lis[lis.length - 1];
				var child = li.firstChild;
				return tinymce.isIE9 && isLastLi && (child.nodeValue == String.fromCharCode(160) || child.nodeValue == String.fromCharCode(32));
			}

			function isEnter(e) {
				return e.keyCode === 13;
			}

			function getListKeyState(e) {
				if (isTabInList(e)) {
					return LIST_TABBING;
				} else if (isEnter(e) && isOnLastListItem()) {
					return LIST_ESCAPE;
				} else if (isEnter(e) && isInEmptyListItem()) {
					return LIST_EMPTY_ITEM;
				} else {
					return LIST_UNKNOWN;
				}
			}

			function cancelEnterAndTab(_, e) {
				if (state == LIST_TABBING || state == LIST_EMPTY_ITEM) {
					return Event.cancel(e);
				}
			}

			function imageJoiningListItem(ed, e) {
				var prevSibling;

				if (!tinymce.isGecko)
					return;

				var n = ed.selection.getStart();
				if (e.keyCode != 8 || n.tagName !== 'IMG')
					return;

				function lastLI(node) {
					var child = node.firstChild;
					var li = null;
					do {
						if (!child)
							break;

						if (child.tagName === 'LI')
							li = child;
					} while (child = child.nextSibling);

					return li;
				}

				function addChildren(parentNode, destination) {
					while (parentNode.childNodes.length > 0)
						destination.appendChild(parentNode.childNodes[0]);
				}

				// Check if there is a previous sibling
				prevSibling = n.parentNode.previousSibling;
				if (!prevSibling)
					return;

				var ul;
				if (prevSibling.tagName === 'UL' || prevSibling.tagName === 'OL')
					ul = prevSibling;
				else if (prevSibling.previousSibling && (prevSibling.previousSibling.tagName === 'UL' || prevSibling.previousSibling.tagName === 'OL'))
					ul = prevSibling.previousSibling;
				else
					return;

				var li = lastLI(ul);

				// move the caret to the end of the list item
				var rng = ed.dom.createRng();
				rng.setStart(li, 1);
				rng.setEnd(li, 1);
				ed.selection.setRng(rng);
				ed.selection.collapse(true);

				// save a bookmark at the end of the list item
				var bookmark = ed.selection.getBookmark();

				// copy the image an its text to the list item
				var clone = n.parentNode.cloneNode(true);
				if (clone.tagName === 'P' || clone.tagName === 'DIV')
					addChildren(clone, li);
				else
					li.appendChild(clone);

				// remove the old copy of the image
				n.parentNode.parentNode.removeChild(n.parentNode);

				// move the caret where we saved the bookmark
				ed.selection.moveToBookmark(bookmark);
			}

			// fix the cursor position to ensure it is correct in IE
			function setCursorPositionToOriginalLi(li) {
				var list = ed.dom.getParent(li, 'ol,ul');
				if (list != null) {
					var lastLi = list.lastChild;
					lastLi.appendChild(ed.getDoc().createElement(''));
					ed.selection.setCursorLocation(lastLi, 0);
				}
			}

			this.ed = ed;
			ed.addCommand('Indent', this.indent, this);
			ed.addCommand('Outdent', this.outdent, this);
			ed.addCommand('InsertUnorderedList', function() {
				this.applyList('UL', 'OL');
			}, this);
			ed.addCommand('InsertOrderedList', function() {
				this.applyList('OL', 'UL');
			}, this);

			ed.onInit.add(function() {
				ed.editorCommands.addCommands({
					'outdent': function() {
						var sel = ed.selection, dom = ed.dom;

						function hasStyleIndent(n) {
							n = dom.getParent(n, dom.isBlock);
							return n && (parseInt(ed.dom.getStyle(n, 'margin-left') || 0, 10) + parseInt(ed.dom.getStyle(n, 'padding-left') || 0, 10)) > 0;
						}

						return hasStyleIndent(sel.getStart()) || hasStyleIndent(sel.getEnd()) || ed.queryCommandState('InsertOrderedList') || ed.queryCommandState('InsertUnorderedList');
					}
				}, 'state');
			});

			ed.onKeyUp.add(function(ed, e) {
				if (state == LIST_TABBING) {
					ed.execCommand(e.shiftKey ? 'Outdent' : 'Indent', true, null);
					state = LIST_UNKNOWN;
					return Event.cancel(e);
				} else if (state == LIST_EMPTY_ITEM) {
					var li = getLi();
					var shouldOutdent =  ed.settings.list_outdent_on_enter === true || e.shiftKey;
					ed.execCommand(shouldOutdent ? 'Outdent' : 'Indent', true, null);
					if (tinymce.isIE) {
						setCursorPositionToOriginalLi(li);
					}
					return Event.cancel(e);
				} else if (state == LIST_ESCAPE) {
					if (tinymce.isIE8) {
						// append a zero sized nbsp so that caret is positioned correctly in IE8 after escaping and applying formatting.
						// if there is no text then applying formatting for e.g a H1 to the P tag immediately following list after
						// escaping from it will cause the caret to be positioned on the last li instead of staying the in P tag.
						var n = ed.getDoc().createTextNode('\uFEFF');
						ed.selection.getNode().appendChild(n);
					} else if (tinymce.isIE9) {
						// IE9 does not escape the list so we use outdent to do this and cancel the default behaviour
						ed.execCommand('Outdent');
						return Event.cancel(e);
					}
				}
			});
			ed.onKeyDown.add(function(_, e) { state = getListKeyState(e); });
			ed.onKeyDown.add(cancelEnterAndTab);
			ed.onKeyDown.add(imageJoiningListItem);
			ed.onKeyPress.add(cancelEnterAndTab);
		},

		applyList: function(targetListType, oppositeListType) {
			var t = this, ed = t.ed, dom = ed.dom, applied = [], hasSameType = false, hasOppositeType = false, hasNonList = false, actions,
					selectedBlocks = ed.selection.getSelectedBlocks();

			function cleanupBr(e) {
				if (e && e.tagName === 'BR') {
					dom.remove(e);
				}
			}

			function makeList(element) {
				var list = dom.create(targetListType), li;

				function adjustIndentForNewList(element) {
					// If there's a margin-left, outdent one level to account for the extra list margin.
					if (element.style.marginLeft || element.style.paddingLeft) {
						t.adjustPaddingFunction(false)(element);
					}
				}

				if (element.tagName === 'LI') {
					// No change required.
				} else if (element.tagName === 'P' || element.tagName === 'DIV' || element.tagName === 'BODY') {
					processBrs(element, function(startSection, br, previousBR) {
						doWrapList(startSection, br, element.tagName === 'BODY' ? null : startSection.parentNode);
						li = startSection.parentNode;
						adjustIndentForNewList(li);
						cleanupBr(br);
					});
					if (element.tagName === 'P' || selectedBlocks.length > 1) {
						dom.split(li.parentNode.parentNode, li.parentNode);
					}
					attemptMergeWithAdjacent(li.parentNode, true);
					return;
				} else {
					// Put the list around the element.
					li = dom.create('li');
					dom.insertAfter(li, element);
					li.appendChild(element);
					adjustIndentForNewList(element);
					element = li;
				}
				dom.insertAfter(list, element);
				list.appendChild(element);
				attemptMergeWithAdjacent(list, true);
				applied.push(element);
			}

			function doWrapList(start, end, template) {
				var li, n = start, tmp, i;
				while (!dom.isBlock(start.parentNode) && start.parentNode !== dom.getRoot()) {
					start = dom.split(start.parentNode, start.previousSibling);
					start = start.nextSibling;
					n = start;
				}
				if (template) {
					li = template.cloneNode(true);
					start.parentNode.insertBefore(li, start);
					while (li.firstChild) dom.remove(li.firstChild);
					li = dom.rename(li, 'li');
				} else {
					li = dom.create('li');
					start.parentNode.insertBefore(li, start);
				}
				while (n && n != end) {
					tmp = n.nextSibling;
					li.appendChild(n);
					n = tmp;
				}
				if (li.childNodes.length === 0) {
					li.innerHTML = '<br _mce_bogus="1" />';
				}
				makeList(li);
			}

			function processBrs(element, callback) {
				var startSection, previousBR, END_TO_START = 3, START_TO_END = 1,
						breakElements = 'br,ul,ol,p,div,h1,h2,h3,h4,h5,h6,table,blockquote,address,pre,form,center,dl';

				function isAnyPartSelected(start, end) {
					var r = dom.createRng(), sel;
					bookmark.keep = true;
					ed.selection.moveToBookmark(bookmark);
					bookmark.keep = false;
					sel = ed.selection.getRng(true);
					if (!end) {
						end = start.parentNode.lastChild;
					}
					r.setStartBefore(start);
					r.setEndAfter(end);
					return !(r.compareBoundaryPoints(END_TO_START, sel) > 0 || r.compareBoundaryPoints(START_TO_END, sel) <= 0);
				}

				function nextLeaf(br) {
					if (br.nextSibling)
						return br.nextSibling;
					if (!dom.isBlock(br.parentNode) && br.parentNode !== dom.getRoot())
						return nextLeaf(br.parentNode);
				}

				// Split on BRs within the range and process those.
				startSection = element.firstChild;
				// First mark the BRs that have any part of the previous section selected.
				var trailingContentSelected = false;
				each(dom.select(breakElements, element), function(br) {
					var b;
					if (br.hasAttribute && br.hasAttribute('_mce_bogus')) {
						return true; // Skip the bogus Brs that are put in to appease Firefox and Safari.
					}
					if (isAnyPartSelected(startSection, br)) {
						dom.addClass(br, '_mce_tagged_br');
						startSection = nextLeaf(br);
					}
				});
				trailingContentSelected = (startSection && isAnyPartSelected(startSection, undefined));
				startSection = element.firstChild;
				each(dom.select(breakElements, element), function(br) {
					// Got a section from start to br.
					var tmp = nextLeaf(br);
					if (br.hasAttribute && br.hasAttribute('_mce_bogus')) {
						return true; // Skip the bogus Brs that are put in to appease Firefox and Safari.
					}
					if (dom.hasClass(br, '_mce_tagged_br')) {
						callback(startSection, br, previousBR);
						previousBR = null;
					} else {
						previousBR = br;
					}
					startSection = tmp;
				});
				if (trailingContentSelected) {
					callback(startSection, undefined, previousBR);
				}
			}

			function wrapList(element) {
				processBrs(element, function(startSection, br, previousBR) {
					// Need to indent this part
					doWrapList(startSection, br);
					cleanupBr(br);
					cleanupBr(previousBR);
				});
			}

			function changeList(element) {
				if (tinymce.inArray(applied, element) !== -1) {
					return;
				}
				if (element.parentNode.tagName === oppositeListType) {
					dom.split(element.parentNode, element);
					makeList(element);
					attemptMergeWithNext(element.parentNode, false);
				}
				applied.push(element);
			}

			function convertListItemToParagraph(element) {
				var child, nextChild, mergedElement, splitLast;
				if (tinymce.inArray(applied, element) !== -1) {
					return;
				}
				element = splitNestedLists(element, dom);
				while (dom.is(element.parentNode, 'ol,ul,li')) {
					dom.split(element.parentNode, element);
				}
				// Push the original element we have from the selection, not the renamed one.
				applied.push(element);
				element = dom.rename(element, 'p');
				mergedElement = attemptMergeWithAdjacent(element, false, ed.settings.force_br_newlines);
				if (mergedElement === element) {
					// Now split out any block elements that can't be contained within a P.
					// Manually iterate to ensure we handle modifications correctly (doesn't work with tinymce.each)
					child = element.firstChild;
					while (child) {
						if (dom.isBlock(child)) {
							child = dom.split(child.parentNode, child);
							splitLast = true;
							nextChild = child.nextSibling && child.nextSibling.firstChild;
						} else {
							nextChild = child.nextSibling;
							if (splitLast && child.tagName === 'BR') {
								dom.remove(child);
							}
							splitLast = false;
						}
						child = nextChild;
					}
				}
			}

			each(selectedBlocks, function(e) {
				e = findItemToOperateOn(e, dom);
				if (e.tagName === oppositeListType || (e.tagName === 'LI' && e.parentNode.tagName === oppositeListType)) {
					hasOppositeType = true;
				} else if (e.tagName === targetListType || (e.tagName === 'LI' && e.parentNode.tagName === targetListType)) {
					hasSameType = true;
				} else {
					hasNonList = true;
				}
			});

			if (hasNonList || hasOppositeType || selectedBlocks.length === 0) {
				actions = {
					'LI': changeList,
					'H1': makeList,
					'H2': makeList,
					'H3': makeList,
					'H4': makeList,
					'H5': makeList,
					'H6': makeList,
					'P': makeList,
					'BODY': makeList,
					'DIV': selectedBlocks.length > 1 ? makeList : wrapList,
					defaultAction: wrapList
				};
			} else {
				actions = {
					defaultAction: convertListItemToParagraph
				};
			}
			this.process(actions);
		},

		indent: function() {
			var ed = this.ed, dom = ed.dom, indented = [];

			function createWrapItem(element) {
				var wrapItem = dom.create('li', { style: 'list-style-type: none;'});
				dom.insertAfter(wrapItem, element);
				return wrapItem;
			}

			function createWrapList(element) {
				var wrapItem = createWrapItem(element),
						list = dom.getParent(element, 'ol,ul'),
						listType = list.tagName,
						listStyle = dom.getStyle(list, 'list-style-type'),
						attrs = {},
						wrapList;
				if (listStyle !== '') {
					attrs.style = 'list-style-type: ' + listStyle + ';';
				}
				wrapList = dom.create(listType, attrs);
				wrapItem.appendChild(wrapList);
				return wrapList;
			}

			function indentLI(element) {
				if (!hasParentInList(ed, element, indented)) {
					element = splitNestedLists(element, dom);
					var wrapList = createWrapList(element);
					wrapList.appendChild(element);
					attemptMergeWithAdjacent(wrapList.parentNode, false);
					attemptMergeWithAdjacent(wrapList, false);
					indented.push(element);
				}
			}

			this.process({
				'LI': indentLI,
				defaultAction: this.adjustPaddingFunction(true)
			});

		},

		outdent: function() {
			var t = this, ed = t.ed, dom = ed.dom, outdented = [];

			function outdentLI(element) {
				var listElement, targetParent, align;
				if (!hasParentInList(ed, element, outdented)) {
					if (dom.getStyle(element, 'margin-left') !== '' || dom.getStyle(element, 'padding-left') !== '') {
						return t.adjustPaddingFunction(false)(element);
					}
					align = dom.getStyle(element, 'text-align', true);
					if (align === 'center' || align === 'right') {
						dom.setStyle(element, 'text-align', 'left');
						return;
					}
					element = splitNestedLists(element, dom);
					listElement = element.parentNode;
					targetParent = element.parentNode.parentNode;
					if (targetParent.tagName === 'P') {
						dom.split(targetParent, element.parentNode);
					} else {
						dom.split(listElement, element);
						if (targetParent.tagName === 'LI') {
							// Nested list, need to split the LI and go back out to the OL/UL element.
							dom.split(targetParent, element);
						} else if (!dom.is(targetParent, 'ol,ul')) {
							dom.rename(element, 'p');
						}
					}
					outdented.push(element);
				}
			}

			this.process({
				'LI': outdentLI,
				defaultAction: this.adjustPaddingFunction(false)
			});

			each(outdented, attemptMergeWithAdjacent);
		},

		process: function(actions) {
			var t = this, sel = t.ed.selection, dom = t.ed.dom, selectedBlocks, r;

			function processElement(element) {
				dom.removeClass(element, '_mce_act_on');
				if (!element || element.nodeType !== 1) {
					return;
				}
				element = findItemToOperateOn(element, dom);
				var action = actions[element.tagName];
				if (!action) {
					action = actions.defaultAction;
				}
				action(element);
			}

			function recurse(element) {
				t.splitSafeEach(element.childNodes, processElement);
			}

			function brAtEdgeOfSelection(container, offset) {
				return offset >= 0 && container.hasChildNodes() && offset < container.childNodes.length &&
						container.childNodes[offset].tagName === 'BR';
			}

			selectedBlocks = sel.getSelectedBlocks();
			if (selectedBlocks.length === 0) {
				selectedBlocks = [ dom.getRoot() ];
			}

			r = sel.getRng(true);
			if (!r.collapsed) {
				if (brAtEdgeOfSelection(r.endContainer, r.endOffset - 1)) {
					r.setEnd(r.endContainer, r.endOffset - 1);
					sel.setRng(r);
				}
				if (brAtEdgeOfSelection(r.startContainer, r.startOffset)) {
					r.setStart(r.startContainer, r.startOffset + 1);
					sel.setRng(r);
				}
			}


			if (tinymce.isIE8) {
				// append a zero sized nbsp so that caret is restored correctly using bookmark
				var s = t.ed.selection.getNode();
				if (s.tagName === 'LI' && !(s.parentNode.lastChild === s)) {
					var i = t.ed.getDoc().createTextNode('\uFEFF');
					s.appendChild(i);
				}
			}

			bookmark = sel.getBookmark();
			actions.OL = actions.UL = recurse;
			t.splitSafeEach(selectedBlocks, processElement);
			sel.moveToBookmark(bookmark);
			bookmark = null;
			// Avoids table or image handles being left behind in Firefox.
			t.ed.execCommand('mceRepaint');
		},

		splitSafeEach: function(elements, f) {
			if (tinymce.isGecko && (/Firefox\/[12]\.[0-9]/.test(navigator.userAgent) ||
					/Firefox\/3\.[0-4]/.test(navigator.userAgent))) {
				this.classBasedEach(elements, f);
			} else {
				each(elements, f);
			}
		},

		classBasedEach: function(elements, f) {
			var dom = this.ed.dom, nodes, element;
			// Mark nodes
			each(elements, function(element) {
				dom.addClass(element, '_mce_act_on');
			});
			nodes = dom.select('._mce_act_on');
			while (nodes.length > 0) {
				element = nodes.shift();
				dom.removeClass(element, '_mce_act_on');
				f(element);
				nodes = dom.select('._mce_act_on');
			}
		},

		adjustPaddingFunction: function(isIndent) {
			var indentAmount, indentUnits, ed = this.ed;
			indentAmount = ed.settings.indentation;
			indentUnits = /[a-z%]+/i.exec(indentAmount);
			indentAmount = parseInt(indentAmount, 10);
			return function(element) {
				var currentIndent, newIndentAmount;
				currentIndent = parseInt(ed.dom.getStyle(element, 'margin-left') || 0, 10) + parseInt(ed.dom.getStyle(element, 'padding-left') || 0, 10);
				if (isIndent) {
					newIndentAmount = currentIndent + indentAmount;
				} else {
					newIndentAmount = currentIndent - indentAmount;
				}
				ed.dom.setStyle(element, 'padding-left', '');
				ed.dom.setStyle(element, 'margin-left', newIndentAmount > 0 ? newIndentAmount + indentUnits : '');
			};
		},

		getInfo: function() {
			return {
				longname : 'Lists',
				author : 'Moxiecode Systems AB',
				authorurl : 'http://tinymce.moxiecode.com',
				infourl : 'http://wiki.moxiecode.com/index.php/TinyMCE:Plugins/lists',
				version : tinymce.majorVersion + "." + tinymce.minorVersion
			};
		}
	});
	tinymce.PluginManager.add("lists", tinymce.plugins.Lists);
}());
/**
 * editor_plugin_src.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function() {
	tinymce.create('tinymce.plugins.PageBreakPlugin', {
		init : function(ed, url) {
			var pb = '<img src="' + ed.theme.url + '/img/trans.gif" class="mcePageBreak mceItemNoResize" />', cls = 'mcePageBreak', sep = ed.getParam('pagebreak_separator', '<!-- pagebreak -->'), pbRE;

			pbRE = new RegExp(sep.replace(/[\?\.\*\[\]\(\)\{\}\+\^\$\:]/g, function(a) {return '\\' + a;}), 'g');

			// Register commands
			ed.addCommand('mcePageBreak', function() {
				ed.execCommand('mceInsertContent', 0, pb);
			});

			// Register buttons
			ed.addButton('pagebreak', {title : 'pagebreak.desc', cmd : cls});

			ed.onInit.add(function() {
				if (ed.theme.onResolveName) {
					ed.theme.onResolveName.add(function(th, o) {
						if (o.node.nodeName == 'IMG' && ed.dom.hasClass(o.node, cls))
							o.name = 'pagebreak';
					});
				}
			});

			ed.onClick.add(function(ed, e) {
				e = e.target;

				if (e.nodeName === 'IMG' && ed.dom.hasClass(e, cls))
					ed.selection.select(e);
			});

			ed.onNodeChange.add(function(ed, cm, n) {
				cm.setActive('pagebreak', n.nodeName === 'IMG' && ed.dom.hasClass(n, cls));
			});

			ed.onBeforeSetContent.add(function(ed, o) {
				o.content = o.content.replace(pbRE, pb);
			});

			ed.onPostProcess.add(function(ed, o) {
				if (o.get)
					o.content = o.content.replace(/<img[^>]+>/g, function(im) {
						if (im.indexOf('class="mcePageBreak') !== -1)
							im = sep;

						return im;
					});
			});
		},

		getInfo : function() {
			return {
				longname : 'PageBreak',
				author : 'Moxiecode Systems AB',
				authorurl : 'http://tinymce.moxiecode.com',
				infourl : 'http://wiki.moxiecode.com/index.php/TinyMCE:Plugins/pagebreak',
				version : tinymce.majorVersion + "." + tinymce.minorVersion
			};
		}
	});

	// Register plugin
	tinymce.PluginManager.add('pagebreak', tinymce.plugins.PageBreakPlugin);
})();/**
 * editor_plugin_src.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var each = tinymce.each;

	// Checks if the selection/caret is at the start of the specified block element
	function isAtStart(rng, par) {
		var doc = par.ownerDocument, rng2 = doc.createRange(), elm;

		rng2.setStartBefore(par);
		rng2.setEnd(rng.endContainer, rng.endOffset);

		elm = doc.createElement('body');
		elm.appendChild(rng2.cloneContents());

		// Check for text characters of other elements that should be treated as content
		return elm.innerHTML.replace(/<(br|img|object|embed|input|textarea)[^>]*>/gi, '-').replace(/<[^>]+>/g, '').length == 0;
	};

	function getSpanVal(td, name) {
		return parseInt(td.getAttribute(name) || 1);
	}

	/**
	 * Table Grid class.
	 */
	function TableGrid(table, dom, selection) {
		var grid, startPos, endPos, selectedCell;

		buildGrid();
		selectedCell = dom.getParent(selection.getStart(), 'th,td');
		if (selectedCell) {
			startPos = getPos(selectedCell);
			endPos = findEndPos();
			selectedCell = getCell(startPos.x, startPos.y);
		}

		function cloneNode(node, children) {
			node = node.cloneNode(children);
			node.removeAttribute('id');

			return node;
		}

		function buildGrid() {
			var startY = 0;

			grid = [];

			each(['thead', 'tbody', 'tfoot'], function(part) {
				var rows = dom.select('> ' + part + ' tr', table);

				each(rows, function(tr, y) {
					y += startY;

					each(dom.select('> td, > th', tr), function(td, x) {
						var x2, y2, rowspan, colspan;

						// Skip over existing cells produced by rowspan
						if (grid[y]) {
							while (grid[y][x])
								x++;
						}

						// Get col/rowspan from cell
						rowspan = getSpanVal(td, 'rowspan');
						colspan = getSpanVal(td, 'colspan');

						// Fill out rowspan/colspan right and down
						for (y2 = y; y2 < y + rowspan; y2++) {
							if (!grid[y2])
								grid[y2] = [];

							for (x2 = x; x2 < x + colspan; x2++) {
								grid[y2][x2] = {
									part : part,
									real : y2 == y && x2 == x,
									elm : td,
									rowspan : rowspan,
									colspan : colspan
								};
							}
						}
					});
				});

				startY += rows.length;
			});
		};

		function getCell(x, y) {
			var row;

			row = grid[y];
			if (row)
				return row[x];
		};

		function setSpanVal(td, name, val) {
			if (td) {
				val = parseInt(val);

				if (val === 1)
					td.removeAttribute(name, 1);
				else
					td.setAttribute(name, val, 1);
			}
		}

		function isCellSelected(cell) {
			return cell && (dom.hasClass(cell.elm, 'mceSelected') || cell == selectedCell);
		};

		function getSelectedRows() {
			var rows = [];

			each(table.rows, function(row) {
				each(row.cells, function(cell) {
					if (dom.hasClass(cell, 'mceSelected') || cell == selectedCell.elm) {
						rows.push(row);
						return false;
					}
				});
			});

			return rows;
		};

		function deleteTable() {
			var rng = dom.createRng();

			rng.setStartAfter(table);
			rng.setEndAfter(table);

			selection.setRng(rng);

			dom.remove(table);
		};

		function cloneCell(cell) {
			var formatNode;

			// Clone formats
			tinymce.walk(cell, function(node) {
				var curNode;

				if (node.nodeType == 3) {
					each(dom.getParents(node.parentNode, null, cell).reverse(), function(node) {
						node = cloneNode(node, false);

						if (!formatNode)
							formatNode = curNode = node;
						else if (curNode)
							curNode.appendChild(node);

						curNode = node;
					});

					// Add something to the inner node
					if (curNode)
						curNode.innerHTML = tinymce.isIE ? '&nbsp;' : '<br data-mce-bogus="1" />';

					return false;
				}
			}, 'childNodes');

			cell = cloneNode(cell, false);
			setSpanVal(cell, 'rowSpan', 1);
			setSpanVal(cell, 'colSpan', 1);

			if (formatNode) {
				cell.appendChild(formatNode);
			} else {
				if (!tinymce.isIE)
					cell.innerHTML = '<br data-mce-bogus="1" />';
			}

			return cell;
		};

		function cleanup() {
			var rng = dom.createRng();

			// Empty rows
			each(dom.select('tr', table), function(tr) {
				if (tr.cells.length == 0)
					dom.remove(tr);
			});

			// Empty table
			if (dom.select('tr', table).length == 0) {
				rng.setStartAfter(table);
				rng.setEndAfter(table);
				selection.setRng(rng);
				dom.remove(table);
				return;
			}

			// Empty header/body/footer
			each(dom.select('thead,tbody,tfoot', table), function(part) {
				if (part.rows.length == 0)
					dom.remove(part);
			});

			// Restore selection to start position if it still exists
			buildGrid();

			// Restore the selection to the closest table position
			row = grid[Math.min(grid.length - 1, startPos.y)];
			if (row) {
				selection.select(row[Math.min(row.length - 1, startPos.x)].elm, true);
				selection.collapse(true);
			}
		};

		function fillLeftDown(x, y, rows, cols) {
			var tr, x2, r, c, cell;

			tr = grid[y][x].elm.parentNode;
			for (r = 1; r <= rows; r++) {
				tr = dom.getNext(tr, 'tr');

				if (tr) {
					// Loop left to find real cell
					for (x2 = x; x2 >= 0; x2--) {
						cell = grid[y + r][x2].elm;

						if (cell.parentNode == tr) {
							// Append clones after
							for (c = 1; c <= cols; c++)
								dom.insertAfter(cloneCell(cell), cell);

							break;
						}
					}

					if (x2 == -1) {
						// Insert nodes before first cell
						for (c = 1; c <= cols; c++)
							tr.insertBefore(cloneCell(tr.cells[0]), tr.cells[0]);
					}
				}
			}
		};

		function split() {
			each(grid, function(row, y) {
				each(row, function(cell, x) {
					var colSpan, rowSpan, newCell, i;

					if (isCellSelected(cell)) {
						cell = cell.elm;
						colSpan = getSpanVal(cell, 'colspan');
						rowSpan = getSpanVal(cell, 'rowspan');

						if (colSpan > 1 || rowSpan > 1) {
							setSpanVal(cell, 'rowSpan', 1);
							setSpanVal(cell, 'colSpan', 1);

							// Insert cells right
							for (i = 0; i < colSpan - 1; i++)
								dom.insertAfter(cloneCell(cell), cell);

							fillLeftDown(x, y, rowSpan - 1, colSpan);
						}
					}
				});
			});
		};

		function merge(cell, cols, rows) {
			var startX, startY, endX, endY, x, y, startCell, endCell, cell, children, count;

			// Use specified cell and cols/rows
			if (cell) {
				pos = getPos(cell);
				startX = pos.x;
				startY = pos.y;
				endX = startX + (cols - 1);
				endY = startY + (rows - 1);
			} else {
				// Use selection
				startX = startPos.x;
				startY = startPos.y;
				endX = endPos.x;
				endY = endPos.y;
			}

			// Find start/end cells
			startCell = getCell(startX, startY);
			endCell = getCell(endX, endY);

			// Check if the cells exists and if they are of the same part for example tbody = tbody
			if (startCell && endCell && startCell.part == endCell.part) {
				// Split and rebuild grid
				split();
				buildGrid();

				// Set row/col span to start cell
				startCell = getCell(startX, startY).elm;
				setSpanVal(startCell, 'colSpan', (endX - startX) + 1);
				setSpanVal(startCell, 'rowSpan', (endY - startY) + 1);

				// Remove other cells and add it's contents to the start cell
				for (y = startY; y <= endY; y++) {
					for (x = startX; x <= endX; x++) {
						if (!grid[y] || !grid[y][x])
							continue;

						cell = grid[y][x].elm;

						if (cell != startCell) {
							// Move children to startCell
							children = tinymce.grep(cell.childNodes);
							each(children, function(node) {
								startCell.appendChild(node);
							});

							// Remove bogus nodes if there is children in the target cell
							if (children.length) {
								children = tinymce.grep(startCell.childNodes);
								count = 0;
								each(children, function(node) {
									if (node.nodeName == 'BR' && dom.getAttrib(node, 'data-mce-bogus') && count++ < children.length - 1)
										startCell.removeChild(node);
								});
							}

							// Remove cell
							dom.remove(cell);
						}
					}
				}

				// Remove empty rows etc and restore caret location
				cleanup();
			}
		};

		function insertRow(before) {
			var posY, cell, lastCell, x, rowElm, newRow, newCell, otherCell, rowSpan;

			// Find first/last row
			each(grid, function(row, y) {
				each(row, function(cell, x) {
					if (isCellSelected(cell)) {
						cell = cell.elm;
						rowElm = cell.parentNode;
						newRow = cloneNode(rowElm, false);
						posY = y;

						if (before)
							return false;
					}
				});

				if (before)
					return !posY;
			});

			for (x = 0; x < grid[0].length; x++) {
				// Cell not found could be because of an invalid table structure
				if (!grid[posY][x])
					continue;

				cell = grid[posY][x].elm;

				if (cell != lastCell) {
					if (!before) {
						rowSpan = getSpanVal(cell, 'rowspan');
						if (rowSpan > 1) {
							setSpanVal(cell, 'rowSpan', rowSpan + 1);
							continue;
						}
					} else {
						// Check if cell above can be expanded
						if (posY > 0 && grid[posY - 1][x]) {
							otherCell = grid[posY - 1][x].elm;
							rowSpan = getSpanVal(otherCell, 'rowSpan');
							if (rowSpan > 1) {
								setSpanVal(otherCell, 'rowSpan', rowSpan + 1);
								continue;
							}
						}
					}

					// Insert new cell into new row
					newCell = cloneCell(cell);
					setSpanVal(newCell, 'colSpan', cell.colSpan);

					newRow.appendChild(newCell);

					lastCell = cell;
				}
			}

			if (newRow.hasChildNodes()) {
				if (!before)
					dom.insertAfter(newRow, rowElm);
				else
					rowElm.parentNode.insertBefore(newRow, rowElm);
			}
		};

		function insertCol(before) {
			var posX, lastCell;

			// Find first/last column
			each(grid, function(row, y) {
				each(row, function(cell, x) {
					if (isCellSelected(cell)) {
						posX = x;

						if (before)
							return false;
					}
				});

				if (before)
					return !posX;
			});

			each(grid, function(row, y) {
				var cell, rowSpan, colSpan;

				if (!row[posX])
					return;

				cell = row[posX].elm;
				if (cell != lastCell) {
					colSpan = getSpanVal(cell, 'colspan');
					rowSpan = getSpanVal(cell, 'rowspan');

					if (colSpan == 1) {
						if (!before) {
							dom.insertAfter(cloneCell(cell), cell);
							fillLeftDown(posX, y, rowSpan - 1, colSpan);
						} else {
							cell.parentNode.insertBefore(cloneCell(cell), cell);
							fillLeftDown(posX, y, rowSpan - 1, colSpan);
						}
					} else
						setSpanVal(cell, 'colSpan', cell.colSpan + 1);

					lastCell = cell;
				}
			});
		};

		function deleteCols() {
			var cols = [];

			// Get selected column indexes
			each(grid, function(row, y) {
				each(row, function(cell, x) {
					if (isCellSelected(cell) && tinymce.inArray(cols, x) === -1) {
						each(grid, function(row) {
							var cell = row[x].elm, colSpan;

							colSpan = getSpanVal(cell, 'colSpan');

							if (colSpan > 1)
								setSpanVal(cell, 'colSpan', colSpan - 1);
							else
								dom.remove(cell);
						});

						cols.push(x);
					}
				});
			});

			cleanup();
		};

		function deleteRows() {
			var rows;

			function deleteRow(tr) {
				var nextTr, pos, lastCell;

				nextTr = dom.getNext(tr, 'tr');

				// Move down row spanned cells
				each(tr.cells, function(cell) {
					var rowSpan = getSpanVal(cell, 'rowSpan');

					if (rowSpan > 1) {
						setSpanVal(cell, 'rowSpan', rowSpan - 1);
						pos = getPos(cell);
						fillLeftDown(pos.x, pos.y, 1, 1);
					}
				});

				// Delete cells
				pos = getPos(tr.cells[0]);
				each(grid[pos.y], function(cell) {
					var rowSpan;

					cell = cell.elm;

					if (cell != lastCell) {
						rowSpan = getSpanVal(cell, 'rowSpan');

						if (rowSpan <= 1)
							dom.remove(cell);
						else
							setSpanVal(cell, 'rowSpan', rowSpan - 1);

						lastCell = cell;
					}
				});
			};

			// Get selected rows and move selection out of scope
			rows = getSelectedRows();

			// Delete all selected rows
			each(rows.reverse(), function(tr) {
				deleteRow(tr);
			});

			cleanup();
		};

		function cutRows() {
			var rows = getSelectedRows();

			dom.remove(rows);
			cleanup();

			return rows;
		};

		function copyRows() {
			var rows = getSelectedRows();

			each(rows, function(row, i) {
				rows[i] = cloneNode(row, true);
			});

			return rows;
		};

		function pasteRows(rows, before) {
			var selectedRows = getSelectedRows(),
				targetRow = selectedRows[before ? 0 : selectedRows.length - 1],
				targetCellCount = targetRow.cells.length;

			// Calc target cell count
			each(grid, function(row) {
				var match;

				targetCellCount = 0;
				each(row, function(cell, x) {
					if (cell.real)
						targetCellCount += cell.colspan;

					if (cell.elm.parentNode == targetRow)
						match = 1;
				});

				if (match)
					return false;
			});

			if (!before)
				rows.reverse();

			each(rows, function(row) {
				var cellCount = row.cells.length, cell;

				// Remove col/rowspans
				for (i = 0; i < cellCount; i++) {
					cell = row.cells[i];
					setSpanVal(cell, 'colSpan', 1);
					setSpanVal(cell, 'rowSpan', 1);
				}

				// Needs more cells
				for (i = cellCount; i < targetCellCount; i++)
					row.appendChild(cloneCell(row.cells[cellCount - 1]));

				// Needs less cells
				for (i = targetCellCount; i < cellCount; i++)
					dom.remove(row.cells[i]);

				// Add before/after
				if (before)
					targetRow.parentNode.insertBefore(row, targetRow);
				else
					dom.insertAfter(row, targetRow);
			});
		};

		function getPos(target) {
			var pos;

			each(grid, function(row, y) {
				each(row, function(cell, x) {
					if (cell.elm == target) {
						pos = {x : x, y : y};
						return false;
					}
				});

				return !pos;
			});

			return pos;
		};

		function setStartCell(cell) {
			startPos = getPos(cell);
		};

		function findEndPos() {
			var pos, maxX, maxY;

			maxX = maxY = 0;

			each(grid, function(row, y) {
				each(row, function(cell, x) {
					var colSpan, rowSpan;

					if (isCellSelected(cell)) {
						cell = grid[y][x];

						if (x > maxX)
							maxX = x;

						if (y > maxY)
							maxY = y;

						if (cell.real) {
							colSpan = cell.colspan - 1;
							rowSpan = cell.rowspan - 1;

							if (colSpan) {
								if (x + colSpan > maxX)
									maxX = x + colSpan;
							}

							if (rowSpan) {
								if (y + rowSpan > maxY)
									maxY = y + rowSpan;
							}
						}
					}
				});
			});

			return {x : maxX, y : maxY};
		};

		function setEndCell(cell) {
			var startX, startY, endX, endY, maxX, maxY, colSpan, rowSpan;

			endPos = getPos(cell);

			if (startPos && endPos) {
				// Get start/end positions
				startX = Math.min(startPos.x, endPos.x);
				startY = Math.min(startPos.y, endPos.y);
				endX = Math.max(startPos.x, endPos.x);
				endY = Math.max(startPos.y, endPos.y);

				// Expand end positon to include spans
				maxX = endX;
				maxY = endY;

				// Expand startX
				for (y = startY; y <= maxY; y++) {
					cell = grid[y][startX];

					if (!cell.real) {
						if (startX - (cell.colspan - 1) < startX)
							startX -= cell.colspan - 1;
					}
				}

				// Expand startY
				for (x = startX; x <= maxX; x++) {
					cell = grid[startY][x];

					if (!cell.real) {
						if (startY - (cell.rowspan - 1) < startY)
							startY -= cell.rowspan - 1;
					}
				}

				// Find max X, Y
				for (y = startY; y <= endY; y++) {
					for (x = startX; x <= endX; x++) {
						cell = grid[y][x];

						if (cell.real) {
							colSpan = cell.colspan - 1;
							rowSpan = cell.rowspan - 1;

							if (colSpan) {
								if (x + colSpan > maxX)
									maxX = x + colSpan;
							}

							if (rowSpan) {
								if (y + rowSpan > maxY)
									maxY = y + rowSpan;
							}
						}
					}
				}

				// Remove current selection
				dom.removeClass(dom.select('td.mceSelected,th.mceSelected'), 'mceSelected');

				// Add new selection
				for (y = startY; y <= maxY; y++) {
					for (x = startX; x <= maxX; x++) {
						if (grid[y][x])
							dom.addClass(grid[y][x].elm, 'mceSelected');
					}
				}
			}
		};

		// Expose to public
		tinymce.extend(this, {
			deleteTable : deleteTable,
			split : split,
			merge : merge,
			insertRow : insertRow,
			insertCol : insertCol,
			deleteCols : deleteCols,
			deleteRows : deleteRows,
			cutRows : cutRows,
			copyRows : copyRows,
			pasteRows : pasteRows,
			getPos : getPos,
			setStartCell : setStartCell,
			setEndCell : setEndCell
		});
	};

	tinymce.create('tinymce.plugins.TablePlugin', {
		init : function(ed, url) {
			var winMan, clipboardRows, hasCellSelection = true; // Might be selected cells on reload

			function createTableGrid(node) {
				var selection = ed.selection, tblElm = ed.dom.getParent(node || selection.getNode(), 'table');

				if (tblElm)
					return new TableGrid(tblElm, ed.dom, selection);
			};

			function cleanup() {
				// Restore selection possibilities
				ed.getBody().style.webkitUserSelect = '';

				if (hasCellSelection) {
					ed.dom.removeClass(ed.dom.select('td.mceSelected,th.mceSelected'), 'mceSelected');
					hasCellSelection = false;
				}
			};

			// Register buttons
			each([
				['table', 'table.desc', 'mceInsertTable', true],
				['delete_table', 'table.del', 'mceTableDelete'],
				['delete_col', 'table.delete_col_desc', 'mceTableDeleteCol'],
				['delete_row', 'table.delete_row_desc', 'mceTableDeleteRow'],
				['col_after', 'table.col_after_desc', 'mceTableInsertColAfter'],
				['col_before', 'table.col_before_desc', 'mceTableInsertColBefore'],
				['row_after', 'table.row_after_desc', 'mceTableInsertRowAfter'],
				['row_before', 'table.row_before_desc', 'mceTableInsertRowBefore'],
				['row_props', 'table.row_desc', 'mceTableRowProps', true],
				['cell_props', 'table.cell_desc', 'mceTableCellProps', true],
				['split_cells', 'table.split_cells_desc', 'mceTableSplitCells', true],
				['merge_cells', 'table.merge_cells_desc', 'mceTableMergeCells', true]
			], function(c) {
				ed.addButton(c[0], {title : c[1], cmd : c[2], ui : c[3]});
			});

			// Select whole table is a table border is clicked
			if (!tinymce.isIE) {
				ed.onClick.add(function(ed, e) {
					e = e.target;

					if (e.nodeName === 'TABLE') {
						ed.selection.select(e);
						ed.nodeChanged();
					}
				});
			}

			ed.onPreProcess.add(function(ed, args) {
				var nodes, i, node, dom = ed.dom, value;

				nodes = dom.select('table', args.node);
				i = nodes.length;
				while (i--) {
					node = nodes[i];
					dom.setAttrib(node, 'data-mce-style', '');

					if ((value = dom.getAttrib(node, 'width'))) {
						dom.setStyle(node, 'width', value);
						dom.setAttrib(node, 'width', '');
					}

					if ((value = dom.getAttrib(node, 'height'))) {
						dom.setStyle(node, 'height', value);
						dom.setAttrib(node, 'height', '');
					}
				}
			});

			// Handle node change updates
			ed.onNodeChange.add(function(ed, cm, n) {
				var p;

				n = ed.selection.getStart();
				p = ed.dom.getParent(n, 'td,th,caption');
				cm.setActive('table', n.nodeName === 'TABLE' || !!p);

				// Disable table tools if we are in caption
				if (p && p.nodeName === 'CAPTION')
					p = 0;

				cm.setDisabled('delete_table', !p);
				cm.setDisabled('delete_col', !p);
				cm.setDisabled('delete_table', !p);
				cm.setDisabled('delete_row', !p);
				cm.setDisabled('col_after', !p);
				cm.setDisabled('col_before', !p);
				cm.setDisabled('row_after', !p);
				cm.setDisabled('row_before', !p);
				cm.setDisabled('row_props', !p);
				cm.setDisabled('cell_props', !p);
				cm.setDisabled('split_cells', !p);
				cm.setDisabled('merge_cells', !p);
			});

			ed.onInit.add(function(ed) {
				var startTable, startCell, dom = ed.dom, tableGrid;

				winMan = ed.windowManager;

				// Add cell selection logic
				ed.onMouseDown.add(function(ed, e) {
					if (e.button != 2) {
						cleanup();

						startCell = dom.getParent(e.target, 'td,th');
						startTable = dom.getParent(startCell, 'table');
					}
				});

				dom.bind(ed.getDoc(), 'mouseover', function(e) {
					var sel, table, target = e.target;

					if (startCell && (tableGrid || target != startCell) && (target.nodeName == 'TD' || target.nodeName == 'TH')) {
						table = dom.getParent(target, 'table');
						if (table == startTable) {
							if (!tableGrid) {
								tableGrid = createTableGrid(table);
								tableGrid.setStartCell(startCell);

								ed.getBody().style.webkitUserSelect = 'none';
							}

							tableGrid.setEndCell(target);
							hasCellSelection = true;
						}

						// Remove current selection
						sel = ed.selection.getSel();

						try {
							if (sel.removeAllRanges)
								sel.removeAllRanges();
							else
								sel.empty();
						} catch (ex) {
							// IE9 might throw errors here
						}

						e.preventDefault();
					}
				});

				ed.onMouseUp.add(function(ed, e) {
					var rng, sel = ed.selection, selectedCells, nativeSel = sel.getSel(), walker, node, lastNode, endNode;

					// Move selection to startCell
					if (startCell) {
						if (tableGrid)
							ed.getBody().style.webkitUserSelect = '';

						function setPoint(node, start) {
							var walker = new tinymce.dom.TreeWalker(node, node);

							do {
								// Text node
								if (node.nodeType == 3 && tinymce.trim(node.nodeValue).length != 0) {
									if (start)
										rng.setStart(node, 0);
									else
										rng.setEnd(node, node.nodeValue.length);

									return;
								}

								// BR element
								if (node.nodeName == 'BR') {
									if (start)
										rng.setStartBefore(node);
									else
										rng.setEndBefore(node);

									return;
								}
							} while (node = (start ? walker.next() : walker.prev()));
						}

						// Try to expand text selection as much as we can only Gecko supports cell selection
						selectedCells = dom.select('td.mceSelected,th.mceSelected');
						if (selectedCells.length > 0) {
							rng = dom.createRng();
							node = selectedCells[0];
							endNode = selectedCells[selectedCells.length - 1];
							rng.setStartBefore(node);
							rng.setEndAfter(node);

							setPoint(node, 1);
							walker = new tinymce.dom.TreeWalker(node, dom.getParent(selectedCells[0], 'table'));

							do {
								if (node.nodeName == 'TD' || node.nodeName == 'TH') {
									if (!dom.hasClass(node, 'mceSelected'))
										break;

									lastNode = node;
								}
							} while (node = walker.next());

							setPoint(lastNode);

							sel.setRng(rng);
						}

						ed.nodeChanged();
						startCell = tableGrid = startTable = null;
					}
				});

				ed.onKeyUp.add(function(ed, e) {
					cleanup();
				});

				ed.onKeyDown.add(function (ed, e) {
					fixTableCellSelection(ed);
				});

				ed.onMouseDown.add(function (ed, e) {
					if (e.button != 2) {
						fixTableCellSelection(ed);
					}
				});
				function tableCellSelected(ed, rng, n, currentCell) {
					// The decision of when a table cell is selected is somewhat involved.  The fact that this code is
					// required is actually a pointer to the root cause of this bug. A cell is selected when the start
					// and end offsets are 0, the start container is a text, and the selection node is either a TR (most cases)
					// or the parent of the table (in the case of the selection containing the last cell of a table).
					var TEXT_NODE = 3, table = ed.dom.getParent(rng.startContainer, 'TABLE'),
					tableParent, allOfCellSelected, tableCellSelection;
					if (table)
					tableParent = table.parentNode;
					allOfCellSelected =rng.startContainer.nodeType == TEXT_NODE &&
						rng.startOffset == 0 &&
						rng.endOffset == 0 &&
						currentCell &&
						(n.nodeName=="TR" || n==tableParent);
					tableCellSelection = (n.nodeName=="TD"||n.nodeName=="TH")&& !currentCell;
					return  allOfCellSelected || tableCellSelection;
					// return false;
				}

				// this nasty hack is here to work around some WebKit selection bugs.
				function fixTableCellSelection(ed) {
					if (!tinymce.isWebKit)
						return;

					var rng = ed.selection.getRng();
					var n = ed.selection.getNode();
					var currentCell = ed.dom.getParent(rng.startContainer, 'TD');

					if (!tableCellSelected(ed, rng, n, currentCell))
						return;
						if (!currentCell) {
							currentCell=n;
						}

					// Get the very last node inside the table cell
					var end = currentCell.lastChild;
					while (end.lastChild)
						end = end.lastChild;

					// Select the entire table cell. Nothing outside of the table cell should be selected.
					rng.setEnd(end, end.nodeValue.length);
					ed.selection.setRng(rng);
				}
				ed.plugins.table.fixTableCellSelection=fixTableCellSelection;

				// Add context menu
				if (ed && ed.plugins.contextmenu) {
					ed.plugins.contextmenu.onContextMenu.add(function(th, m, e) {
						var sm, se = ed.selection, el = se.getNode() || ed.getBody();

						if (ed.dom.getParent(e, 'td') || ed.dom.getParent(e, 'th') || ed.dom.select('td.mceSelected,th.mceSelected').length) {
							m.removeAll();

							if (el.nodeName == 'A' && !ed.dom.getAttrib(el, 'name')) {
								m.add({title : 'advanced.link_desc', icon : 'link', cmd : ed.plugins.advlink ? 'mceAdvLink' : 'mceLink', ui : true});
								m.add({title : 'advanced.unlink_desc', icon : 'unlink', cmd : 'UnLink'});
								m.addSeparator();
							}

							if (el.nodeName == 'IMG' && el.className.indexOf('mceItem') == -1) {
								m.add({title : 'advanced.image_desc', icon : 'image', cmd : ed.plugins.advimage ? 'mceAdvImage' : 'mceImage', ui : true});
								m.addSeparator();
							}

							m.add({title : 'table.desc', icon : 'table', cmd : 'mceInsertTable', value : {action : 'insert'}});
							m.add({title : 'table.props_desc', icon : 'table_props', cmd : 'mceInsertTable'});
							m.add({title : 'table.del', icon : 'delete_table', cmd : 'mceTableDelete'});
							m.addSeparator();

							// Cell menu
							sm = m.addMenu({title : 'table.cell'});
							sm.add({title : 'table.cell_desc', icon : 'cell_props', cmd : 'mceTableCellProps'});
							sm.add({title : 'table.split_cells_desc', icon : 'split_cells', cmd : 'mceTableSplitCells'});
							sm.add({title : 'table.merge_cells_desc', icon : 'merge_cells', cmd : 'mceTableMergeCells'});

							// Row menu
							sm = m.addMenu({title : 'table.row'});
							sm.add({title : 'table.row_desc', icon : 'row_props', cmd : 'mceTableRowProps'});
							sm.add({title : 'table.row_before_desc', icon : 'row_before', cmd : 'mceTableInsertRowBefore'});
							sm.add({title : 'table.row_after_desc', icon : 'row_after', cmd : 'mceTableInsertRowAfter'});
							sm.add({title : 'table.delete_row_desc', icon : 'delete_row', cmd : 'mceTableDeleteRow'});
							sm.addSeparator();
							sm.add({title : 'table.cut_row_desc', icon : 'cut', cmd : 'mceTableCutRow'});
							sm.add({title : 'table.copy_row_desc', icon : 'copy', cmd : 'mceTableCopyRow'});
							sm.add({title : 'table.paste_row_before_desc', icon : 'paste', cmd : 'mceTablePasteRowBefore'}).setDisabled(!clipboardRows);
							sm.add({title : 'table.paste_row_after_desc', icon : 'paste', cmd : 'mceTablePasteRowAfter'}).setDisabled(!clipboardRows);

							// Column menu
							sm = m.addMenu({title : 'table.col'});
							sm.add({title : 'table.col_before_desc', icon : 'col_before', cmd : 'mceTableInsertColBefore'});
							sm.add({title : 'table.col_after_desc', icon : 'col_after', cmd : 'mceTableInsertColAfter'});
							sm.add({title : 'table.delete_col_desc', icon : 'delete_col', cmd : 'mceTableDeleteCol'});
						} else
							m.add({title : 'table.desc', icon : 'table', cmd : 'mceInsertTable'});
					});
				}

				// Fix to allow navigating up and down in a table in WebKit browsers.
				if (tinymce.isWebKit) {
					function moveSelection(ed, e) {

						function moveCursorToStartOfElement(n) {
							ed.selection.setCursorLocation(n, 0);
						}

						function getSibling(event, element) {
							return event.keyCode == UP_ARROW ? element.previousSibling : element.nextSibling;
						}

						function getNextRow(e, row) {
							var sibling = getSibling(e, row);
							return sibling !== null && sibling.tagName === 'TR' ? sibling : null;
						}

						function getTable(ed, currentRow) {
							return ed.dom.getParent(currentRow, 'table');
						}

						function getTableSibling(currentRow) {
							var table = getTable(ed, currentRow);
							return getSibling(e, table);
						}

						function isVerticalMovement(event) {
							return event.keyCode == UP_ARROW || event.keyCode == DOWN_ARROW;
						}

						function isInTable(ed) {
							var node = ed.selection.getNode();
							var currentRow = ed.dom.getParent(node, 'tr');
							return currentRow !== null;
						}

						function columnIndex(column) {
							var colIndex = 0;
							var c = column;
							while (c.previousSibling) {
								c = c.previousSibling;
								colIndex = colIndex + getSpanVal(c, "colspan");
							}
							return colIndex;
						}

						function findColumn(rowElement, columnIndex) {
							var c = 0;
							var r = 0;
							each(rowElement.children, function(cell, i) {
								c = c + getSpanVal(cell, "colspan");
								r = i;
								if (c > columnIndex)
									return false;
							});
							return r;
						}

						function moveCursorToRow(ed, node, row) {
							var srcColumnIndex = columnIndex(ed.dom.getParent(node, 'td,th'));
							var tgtColumnIndex = findColumn(row, srcColumnIndex)
							var tgtNode = row.childNodes[tgtColumnIndex];
							moveCursorToStartOfElement(tgtNode);
						}

						function escapeTable(currentRow, e) {
							var tableSiblingElement = getTableSibling(currentRow);
							if (tableSiblingElement !== null) {
								moveCursorToStartOfElement(tableSiblingElement);
								return tinymce.dom.Event.cancel(e);
							} else {
								var element = e.keyCode == UP_ARROW ? currentRow.firstChild : currentRow.lastChild;
								// rely on default behaviour to escape table after we are in the last cell of the last row
								moveCursorToStartOfElement(element);
								return true;
							}
						}

						var UP_ARROW = 38;
						var DOWN_ARROW = 40;

						if (isVerticalMovement(e) && isInTable(ed)) {
							var node = ed.selection.getNode();
							var currentRow = ed.dom.getParent(node, 'tr');
							var nextRow = getNextRow(e, currentRow);

							// If we're at the first or last row in the table, we should move the caret outside of the table
							if (nextRow == null) {
								return escapeTable(currentRow, e);
							} else {
								moveCursorToRow(ed, node, nextRow);
								tinymce.dom.Event.cancel(e);
								return true;
							}
						}
					}

					ed.onKeyDown.add(moveSelection);
				}

				// Fixes an issue on Gecko where it's impossible to place the caret behind a table
				// This fix will force a paragraph element after the table but only when the forced_root_block setting is enabled
				if (!tinymce.isIE) {
					function fixTableCaretPos() {
						var last;

						// Skip empty text nodes form the end
						for (last = ed.getBody().lastChild; last && last.nodeType == 3 && !last.nodeValue.length; last = last.previousSibling) ;

						if (last && last.nodeName == 'TABLE')
							ed.dom.add(ed.getBody(), 'p', null, '<br mce_bogus="1" />');
					};

					// Fixes an bug where it's impossible to place the caret before a table in Gecko
					// this fix solves it by detecting when the caret is at the beginning of such a table
					// and then manually moves the caret infront of the table
					if (tinymce.isGecko) {
						ed.onKeyDown.add(function(ed, e) {
							var rng, table, dom = ed.dom;

							// On gecko it's not possible to place the caret before a table
							if (e.keyCode == 37 || e.keyCode == 38) {
								rng = ed.selection.getRng();
								table = dom.getParent(rng.startContainer, 'table');

								if (table && ed.getBody().firstChild == table) {
									if (isAtStart(rng, table)) {
										rng = dom.createRng();

										rng.setStartBefore(table);
										rng.setEndBefore(table);

										ed.selection.setRng(rng);

										e.preventDefault();
									}
								}
							}
						});
					}

					ed.onKeyUp.add(fixTableCaretPos);
					ed.onSetContent.add(fixTableCaretPos);
					ed.onVisualAid.add(fixTableCaretPos);

					ed.onPreProcess.add(function(ed, o) {
						var last = o.node.lastChild;

						if (last && last.childNodes.length == 1 && last.firstChild.nodeName == 'BR')
							ed.dom.remove(last);
					});

					fixTableCaretPos();
					ed.startContent = ed.getContent({format : 'raw'});
				}
			});

			// Register action commands
			each({
				mceTableSplitCells : function(grid) {
					grid.split();
				},

				mceTableMergeCells : function(grid) {
					var rowSpan, colSpan, cell;

					cell = ed.dom.getParent(ed.selection.getNode(), 'th,td');
					if (cell) {
						rowSpan = cell.rowSpan;
						colSpan = cell.colSpan;
					}

					if (!ed.dom.select('td.mceSelected,th.mceSelected').length) {
						winMan.open({
							url : url + '/merge_cells.htm',
							width : 240 + parseInt(ed.getLang('table.merge_cells_delta_width', 0)),
							height : 110 + parseInt(ed.getLang('table.merge_cells_delta_height', 0)),
							inline : 1
						}, {
							rows : rowSpan,
							cols : colSpan,
							onaction : function(data) {
								grid.merge(cell, data.cols, data.rows);
							},
							plugin_url : url
						});
					} else
						grid.merge();
				},

				mceTableInsertRowBefore : function(grid) {
					grid.insertRow(true);
				},

				mceTableInsertRowAfter : function(grid) {
					grid.insertRow();
				},

				mceTableInsertColBefore : function(grid) {
					grid.insertCol(true);
				},

				mceTableInsertColAfter : function(grid) {
					grid.insertCol();
				},

				mceTableDeleteCol : function(grid) {
					grid.deleteCols();
				},

				mceTableDeleteRow : function(grid) {
					grid.deleteRows();
				},

				mceTableCutRow : function(grid) {
					clipboardRows = grid.cutRows();
				},

				mceTableCopyRow : function(grid) {
					clipboardRows = grid.copyRows();
				},

				mceTablePasteRowBefore : function(grid) {
					grid.pasteRows(clipboardRows, true);
				},

				mceTablePasteRowAfter : function(grid) {
					grid.pasteRows(clipboardRows);
				},

				mceTableDelete : function(grid) {
					grid.deleteTable();
				}
			}, function(func, name) {
				ed.addCommand(name, function() {
					var grid = createTableGrid();

					if (grid) {
						func(grid);
						ed.execCommand('mceRepaint');
						cleanup();
					}
				});
			});

			// Register dialog commands
			each({
				mceInsertTable : function(val) {
					winMan.open({
						url : url + '/table.htm',
						width : 400 + parseInt(ed.getLang('table.table_delta_width', 0)),
						height : 320 + parseInt(ed.getLang('table.table_delta_height', 0)),
						inline : 1
					}, {
						plugin_url : url,
						action : val ? val.action : 0
					});
				},

				mceTableRowProps : function() {
					winMan.open({
						url : url + '/row.htm',
						width : 400 + parseInt(ed.getLang('table.rowprops_delta_width', 0)),
						height : 295 + parseInt(ed.getLang('table.rowprops_delta_height', 0)),
						inline : 1
					}, {
						plugin_url : url
					});
				},

				mceTableCellProps : function() {
					winMan.open({
						url : url + '/cell.htm',
						width : 400 + parseInt(ed.getLang('table.cellprops_delta_width', 0)),
						height : 295 + parseInt(ed.getLang('table.cellprops_delta_height', 0)),
						inline : 1
					}, {
						plugin_url : url
					});
				}
			}, function(func, name) {
				ed.addCommand(name, function(ui, val) {
					func(val);
				});
			});
		}
	});

	// Register plugin
	tinymce.PluginManager.add('table', tinymce.plugins.TablePlugin);
})(tinymce);
/**
 * editor_plugin_src.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function() {
	var each = tinymce.each,
		defs = {
			paste_auto_cleanup_on_paste : true,
			paste_auto_process_on_paste : true,
			paste_enable_default_filters : true,
			paste_block_drop : false,
			paste_retain_style_properties : "none",
			paste_strip_class_attributes : "mso",
			paste_remove_spans : false,
			paste_remove_styles : false,
			paste_remove_styles_if_webkit : true,
			paste_convert_middot_lists : true,
			paste_convert_headers_to_strong : false,
			paste_dialog_width : "450",
			paste_dialog_height : "400",
			paste_text_use_dialog : false,
			paste_text_sticky : false,
			paste_text_sticky_default : false,
			paste_text_notifyalways : false,
			paste_text_linebreaktype : "combined",
			paste_text_replacements : [
				[/\u2026/g, "..."],
				[/[\x93\x94\u201c\u201d]/g, '"'],
				[/[\x60\x91\x92\u2018\u2019]/g, "'"]
			]
		};

	function getParam(ed, name) {
		return ed.getParam(name, defs[name]);
	}

	tinymce.create('tinymce.plugins.PastePlugin', {
		init : function(ed, url) {
			var t = this;

			t.editor = ed;
			t.url = url;

			// Setup plugin events
			t.onPreProcess = new tinymce.util.Dispatcher(t);
			t.onPostProcess = new tinymce.util.Dispatcher(t);

			// Register default handlers
			t.onPreProcess.add(t._preProcess);
			t.onPostProcess.add(t._postProcess);

			// Register optional preprocess handler
			t.onPreProcess.add(function(pl, o) {
				ed.execCallback('paste_preprocess', pl, o);
			});

			// Register optional postprocess
			t.onPostProcess.add(function(pl, o) {
				ed.execCallback('paste_postprocess', pl, o);
			});

			ed.onKeyDown.addToTop(function(ed, e) {
				// Block ctrl+v from adding an undo level since the default logic in tinymce.Editor will add that
				if (((tinymce.isMac ? e.metaKey : e.ctrlKey) && e.keyCode == 86) || (e.shiftKey && e.keyCode == 45))
					return false; // Stop other listeners
			});

			// Initialize plain text flag
			ed.pasteAsPlainText = getParam(ed, 'paste_text_sticky_default');

			// This function executes the process handlers and inserts the contents
			// force_rich overrides plain text mode set by user, important for pasting with execCommand
			function process(o, force_rich) {
				var dom = ed.dom, rng;

				// Execute pre process handlers
				t.onPreProcess.dispatch(t, o);

				if (getParam(ed, "paste_auto_process_on_paste")) {
					// Create DOM structure
					o.node = dom.create('div', 0, o.content);

					// If pasting inside the same element and the contents is only one block
					// remove the block and keep the text since Firefox will copy parts of pre and h1-h6 as a pre element
					if (tinymce.isGecko) {
						rng = ed.selection.getRng(true);
						if (rng.startContainer == rng.endContainer && rng.startContainer.nodeType == 3) {
							// Is only one block node and it doesn't contain word stuff
							if (o.node.childNodes.length === 1 && /^(p|h[1-6]|pre)$/i.test(o.node.firstChild.nodeName) && o.content.indexOf('__MCE_ITEM__') === -1)
								dom.remove(o.node.firstChild, true);
						}
					}

					// Execute post process handlers
					t.onPostProcess.dispatch(t, o);

					// Serialize content
					o.content = ed.serializer.serialize(o.node, {getInner : 1, forced_root_block : ''});
				}

				// Plain text option active?
				if ((!force_rich) && (ed.pasteAsPlainText)) {
					t._insertPlainText(o.content);

					if (!getParam(ed, "paste_text_sticky")) {
						ed.pasteAsPlainText = false;
						ed.controlManager.setActive("pastetext", false);
					}
				} else {
					t._insert(o.content);
				}
			}

			// Add command for external usage
			ed.addCommand('mceInsertClipboardContent', function(u, o) {
				process(o, true);
			});

			if (!getParam(ed, "paste_text_use_dialog")) {
				ed.addCommand('mcePasteText', function(u, v) {
					var cookie = tinymce.util.Cookie;

					ed.pasteAsPlainText = !ed.pasteAsPlainText;
					ed.controlManager.setActive('pastetext', ed.pasteAsPlainText);

					if ((ed.pasteAsPlainText) && (!cookie.get("tinymcePasteText"))) {
						if (getParam(ed, "paste_text_sticky")) {
							ed.windowManager.alert(ed.translate('paste.plaintext_mode_sticky'));
						} else {
							ed.windowManager.alert(ed.translate('paste.plaintext_mode'));
						}

						if (!getParam(ed, "paste_text_notifyalways")) {
							cookie.set("tinymcePasteText", "1", new Date(new Date().getFullYear() + 1, 12, 31))
						}
					}
				});
			}

			ed.addButton('pastetext', {title: 'paste.paste_text_desc', cmd: 'mcePasteText'});
			ed.addButton('selectall', {title: 'paste.selectall_desc', cmd: 'selectall'});

			// This function grabs the contents from the clipboard by adding a
			// hidden div and placing the caret inside it and after the browser paste
			// is done it grabs that contents and processes that
			function grabContent(e) {
				var n, or, rng, oldRng, sel = ed.selection, dom = ed.dom, body = ed.getBody(), posY, textContent;

				// Check if browser supports direct plaintext access
				if (e.clipboardData || dom.doc.dataTransfer) {
					textContent = (e.clipboardData || dom.doc.dataTransfer).getData('Text');

					if (ed.pasteAsPlainText) {
						e.preventDefault();
						process({content : dom.encode(textContent).replace(/\r?\n/g, '<br />')});
						return;
					}
				}

				if (dom.get('_mcePaste'))
					return;

				// Create container to paste into
				n = dom.add(body, 'div', {id : '_mcePaste', 'class' : 'mcePaste', 'data-mce-bogus' : '1'}, '\uFEFF\uFEFF');

				// If contentEditable mode we need to find out the position of the closest element
				if (body != ed.getDoc().body)
					posY = dom.getPos(ed.selection.getStart(), body).y;
				else
					posY = body.scrollTop + dom.getViewPort(ed.getWin()).y;

				// Styles needs to be applied after the element is added to the document since WebKit will otherwise remove all styles
				// If also needs to be in view on IE or the paste would fail
				dom.setStyles(n, {
					position : 'absolute',
					left : tinymce.isGecko ? -40 : 0, // Need to move it out of site on Gecko since it will othewise display a ghost resize rect for the div
					top : posY - 25,
					width : 1,
					height : 1,
					overflow : 'hidden'
				});

				if (tinymce.isIE) {
					// Store away the old range
					oldRng = sel.getRng();

					// Select the container
					rng = dom.doc.body.createTextRange();
					rng.moveToElementText(n);
					rng.execCommand('Paste');

					// Remove container
					dom.remove(n);

					// Check if the contents was changed, if it wasn't then clipboard extraction failed probably due
					// to IE security settings so we pass the junk though better than nothing right
					if (n.innerHTML === '\uFEFF\uFEFF') {
						ed.execCommand('mcePasteWord');
						e.preventDefault();
						return;
					}

					// Restore the old range and clear the contents before pasting
					sel.setRng(oldRng);
					sel.setContent('');

					// For some odd reason we need to detach the the mceInsertContent call from the paste event
					// It's like IE has a reference to the parent element that you paste in and the selection gets messed up
					// when it tries to restore the selection
					setTimeout(function() {
						// Process contents
						process({content : n.innerHTML});
					}, 0);

					// Block the real paste event
					return tinymce.dom.Event.cancel(e);
				} else {
					function block(e) {
						e.preventDefault();
					};

					// Block mousedown and click to prevent selection change
					dom.bind(ed.getDoc(), 'mousedown', block);
					dom.bind(ed.getDoc(), 'keydown', block);

					or = ed.selection.getRng();

					// Move select contents inside DIV
					n = n.firstChild;
					rng = ed.getDoc().createRange();
					rng.setStart(n, 0);
					rng.setEnd(n, 2);
					var y = ed.getBody().scrollTop;
					sel.setRng(rng);

					// Wait a while and grab the pasted contents
//					berkel: Jump editor in Chrome
					window.setTimeout(function() {
						var h = '', nl;

						// Paste divs duplicated in paste divs seems to happen when you paste plain text so lets first look for that broken behavior in WebKit
						if (!dom.select('div.mcePaste > div.mcePaste').length) {
							nl = dom.select('div.mcePaste');

							// WebKit will split the div into multiple ones so this will loop through then all and join them to get the whole HTML string
							each(nl, function(n) {
								var child = n.firstChild;

								// WebKit inserts a DIV container with lots of odd styles
								if (child && child.nodeName == 'DIV' && child.style.marginTop && child.style.backgroundColor) {
									dom.remove(child, 1);
								}

								// Remove apply style spans
								each(dom.select('span.Apple-style-span', n), function(n) {
									dom.remove(n, 1);
								});

								// Remove bogus br elements
								each(dom.select('br[data-mce-bogus]', n), function(n) {
									dom.remove(n);
								});

								// WebKit will make a copy of the DIV for each line of plain text pasted and insert them into the DIV
								if (n.parentNode.className != 'mcePaste')
									h += n.innerHTML;
							});
						} else {
							// Found WebKit weirdness so force the content into paragraphs this seems to happen when you paste plain text from Nodepad etc
							// So this logic will replace double enter with paragraphs and single enter with br so it kind of looks the same
							h = '<p>' + dom.encode(textContent).replace(/\r?\n\r?\n/g, '</p><p>').replace(/\r?\n/g, '<br />') + '</p>';
						}

						// Remove the nodes
						each(dom.select('div.mcePaste'), function(n) {
							dom.remove(n);
						});

						// Restore the old selection
						if (or)
							sel.setRng(or);

						process({content : h});

						var markerId = '___marker';
						sel.getRng().insertNode(dom.create('div', {id : markerId}, ''));

						var marker = dom.get(markerId), markerYPos = dom.getPos(marker).y, vpHeight = dom.getViewPort(ed.getWin()).h;
						dom.remove(marker);

						if (markerYPos > y + vpHeight) {
							y = markerYPos - vpHeight;
						}

						ed.getWin().scrollTo(0, y);

						// Unblock events ones we got the contents
						dom.unbind(ed.getDoc(), 'mousedown', block);
						dom.unbind(ed.getDoc(), 'keydown', block);
					}, 0);
				}
			}

			// Check if we should use the new auto process method
			if (getParam(ed, "paste_auto_cleanup_on_paste")) {
				// Is it's Opera or older FF use key handler
				if (tinymce.isOpera || /Firefox\/2/.test(navigator.userAgent)) {
					ed.onKeyDown.addToTop(function(ed, e) {
						if (((tinymce.isMac ? e.metaKey : e.ctrlKey) && e.keyCode == 86) || (e.shiftKey && e.keyCode == 45))
							grabContent(e);
					});
				} else {
					// Grab contents on paste event on Gecko and WebKit
					ed.onPaste.addToTop(function(ed, e) {
						return grabContent(e);
					});
				}
			}

			ed.onInit.add(function() {
				ed.controlManager.setActive("pastetext", ed.pasteAsPlainText);

				// Block all drag/drop events
				if (getParam(ed, "paste_block_drop")) {
					ed.dom.bind(ed.getBody(), ['dragend', 'dragover', 'draggesture', 'dragdrop', 'drop', 'drag'], function(e) {
						e.preventDefault();
						e.stopPropagation();

						return false;
					});
				}
			});

			// Add legacy support
			t._legacySupport();
		},

		getInfo : function() {
			return {
				longname : 'Paste text/word',
				author : 'Moxiecode Systems AB',
				authorurl : 'http://tinymce.moxiecode.com',
				infourl : 'http://wiki.moxiecode.com/index.php/TinyMCE:Plugins/paste',
				version : tinymce.majorVersion + "." + tinymce.minorVersion
			};
		},

		_preProcess : function(pl, o) {
			var ed = this.editor,
				h = o.content,
				grep = tinymce.grep,
				explode = tinymce.explode,
				trim = tinymce.trim,
				len, stripClass;

			//console.log('Before preprocess:' + o.content);

			function process(items) {
				each(items, function(v) {
					// Remove or replace
					if (v.constructor == RegExp)
						h = h.replace(v, '');
					else
						h = h.replace(v[0], v[1]);
				});
			}

			if (ed.settings.paste_enable_default_filters == false) {
				return;
			}

			// IE9 adds BRs before/after block elements when contents is pasted from word or for example another browser
			if (tinymce.isIE && document.documentMode >= 9) {
				// IE9 adds BRs before/after block elements when contents is pasted from word or for example another browser
				process([[/(?:<br>&nbsp;[\s\r\n]+|<br>)*(<\/?(h[1-6r]|p|div|address|pre|form|table|tbody|thead|tfoot|th|tr|td|li|ol|ul|caption|blockquote|center|dl|dt|dd|dir|fieldset)[^>]*>)(?:<br>&nbsp;[\s\r\n]+|<br>)*/g, '$1']]);

				// IE9 also adds an extra BR element for each soft-linefeed and it also adds a BR for each word wrap break
				process([
					[/<br><br>/g, '<BR><BR>'], // Replace multiple BR elements with uppercase BR to keep them intact
					[/<br>/g, ' '], // Replace single br elements with space since they are word wrap BR:s
					[/<BR><BR>/g, '<br>'] // Replace back the double brs but into a single BR
				]);
			}

			// Detect Word content and process it more aggressive
			if (/class="?Mso|style="[^"]*\bmso-|w:WordDocument/i.test(h) || o.wordContent) {
				o.wordContent = true;			// Mark the pasted contents as word specific content
				//console.log('Word contents detected.');

				// Process away some basic content
				process([
					/^\s*(&nbsp;)+/gi,				// &nbsp; entities at the start of contents
					/(&nbsp;|<br[^>]*>)+\s*$/gi		// &nbsp; entities at the end of contents
				]);

				if (getParam(ed, "paste_convert_headers_to_strong")) {
					h = h.replace(/<p [^>]*class="?MsoHeading"?[^>]*>(.*?)<\/p>/gi, "<p><strong>$1</strong></p>");
				}

				if (getParam(ed, "paste_convert_middot_lists")) {
					process([
						[/<!--\[if !supportLists\]-->/gi, '$&__MCE_ITEM__'],					// Convert supportLists to a list item marker
						[/(<span[^>]+(?:mso-list:|:\s*symbol)[^>]+>)/gi, '$1__MCE_ITEM__'],		// Convert mso-list and symbol spans to item markers
						[/(<p[^>]+(?:MsoListParagraph)[^>]+>)/gi, '$1__MCE_ITEM__']				// Convert mso-list and symbol paragraphs to item markers (FF)
					]);
				}

				process([
					// Word comments like conditional comments etc
					/<!--[\s\S]+?-->/gi,

					// Remove comments, scripts (e.g., msoShowComment), XML tag, VML content, MS Office namespaced tags, and a few other tags
					/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi,

					// Convert <s> into <strike> for line-though
					[/<(\/?)s>/gi, "<$1strike>"],

					// Replace nsbp entites to char since it's easier to handle
					[/&nbsp;/gi, "\u00a0"]
				]);

				// Remove bad attributes, with or without quotes, ensuring that attribute text is really inside a tag.
				// If JavaScript had a RegExp look-behind, we could have integrated this with the last process() array and got rid of the loop. But alas, it does not, so we cannot.
				do {
					len = h.length;
					h = h.replace(/(<[a-z][^>]*\s)(?:id|name|language|type|on\w+|\w+:\w+)=(?:"[^"]*"|\w+)\s?/gi, "$1");
				} while (len != h.length);

				// Remove all spans if no styles is to be retained
				if (getParam(ed, "paste_retain_style_properties").replace(/^none$/i, "").length == 0) {
					h = h.replace(/<\/?span[^>]*>/gi, "");
				} else {
					// We're keeping styles, so at least clean them up.
					// CSS Reference: http://msdn.microsoft.com/en-us/library/aa155477.aspx

					process([
						// Convert <span style="mso-spacerun:yes">___</span> to string of alternating breaking/non-breaking spaces of same length
						[/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi,
							function(str, spaces) {
								return (spaces.length > 0)? spaces.replace(/./, " ").slice(Math.floor(spaces.length/2)).split("").join("\u00a0") : "";
							}
						],

						// Examine all styles: delete junk, transform some, and keep the rest
						[/(<[a-z][^>]*)\sstyle="([^"]*)"/gi,
							function(str, tag, style) {
								var n = [],
									i = 0,
									s = explode(trim(style).replace(/&quot;/gi, "'"), ";");

								// Examine each style definition within the tag's style attribute
								each(s, function(v) {
									var name, value,
										parts = explode(v, ":");

									function ensureUnits(v) {
										return v + ((v !== "0") && (/\d$/.test(v)))? "px" : "";
									}

									if (parts.length == 2) {
										name = parts[0].toLowerCase();
										value = parts[1].toLowerCase();

										// Translate certain MS Office styles into their CSS equivalents
										switch (name) {
											case "mso-padding-alt":
											case "mso-padding-top-alt":
											case "mso-padding-right-alt":
											case "mso-padding-bottom-alt":
											case "mso-padding-left-alt":
											case "mso-margin-alt":
											case "mso-margin-top-alt":
											case "mso-margin-right-alt":
											case "mso-margin-bottom-alt":
											case "mso-margin-left-alt":
											case "mso-table-layout-alt":
											case "mso-height":
											case "mso-width":
											case "mso-vertical-align-alt":
												n[i++] = name.replace(/^mso-|-alt$/g, "") + ":" + ensureUnits(value);
												return;

											case "horiz-align":
												n[i++] = "text-align:" + value;
												return;

											case "vert-align":
												n[i++] = "vertical-align:" + value;
												return;

											case "font-color":
											case "mso-foreground":
												n[i++] = "color:" + value;
												return;

											case "mso-background":
											case "mso-highlight":
												n[i++] = "background:" + value;
												return;

											case "mso-default-height":
												n[i++] = "min-height:" + ensureUnits(value);
												return;

											case "mso-default-width":
												n[i++] = "min-width:" + ensureUnits(value);
												return;

											case "mso-padding-between-alt":
												n[i++] = "border-collapse:separate;border-spacing:" + ensureUnits(value);
												return;

											case "text-line-through":
												if ((value == "single") || (value == "double")) {
													n[i++] = "text-decoration:line-through";
												}
												return;

											case "mso-zero-height":
												if (value == "yes") {
													n[i++] = "display:none";
												}
												return;
										}

										// Eliminate all MS Office style definitions that have no CSS equivalent by examining the first characters in the name
										if (/^(mso|column|font-emph|lang|layout|line-break|list-image|nav|panose|punct|row|ruby|sep|size|src|tab-|table-border|text-(?!align|decor|indent|trans)|top-bar|version|vnd|word-break)/.test(name)) {
											return;
										}

										// If it reached this point, it must be a valid CSS style
										n[i++] = name + ":" + parts[1];		// Lower-case name, but keep value case
									}
								});

								// If style attribute contained any valid styles the re-write it; otherwise delete style attribute.
								if (i > 0) {
									return tag + ' style="' + n.join(';') + '"';
								} else {
									return tag;
								}
							}
						]
					]);
				}
			}

			// Replace headers with <strong>
			if (getParam(ed, "paste_convert_headers_to_strong")) {
				process([
					[/<h[1-6][^>]*>/gi, "<p><strong>"],
					[/<\/h[1-6][^>]*>/gi, "</strong></p>"]
				]);
			}

			process([
				// Copy paste from Java like Open Office will produce this junk on FF
				[/Version:[\d.]+\nStartHTML:\d+\nEndHTML:\d+\nStartFragment:\d+\nEndFragment:\d+/gi, '']
			]);

			// Class attribute options are: leave all as-is ("none"), remove all ("all"), or remove only those starting with mso ("mso").
			// Note:-  paste_strip_class_attributes: "none", verify_css_classes: true is also a good variation.
			stripClass = getParam(ed, "paste_strip_class_attributes");

			if (stripClass !== "none") {
				function removeClasses(match, g1) {
						if (stripClass === "all")
							return '';

						var cls = grep(explode(g1.replace(/^(["'])(.*)\1$/, "$2"), " "),
							function(v) {
								return (/^(?!mso)/i.test(v));
							}
						);

						return cls.length ? ' class="' + cls.join(" ") + '"' : '';
				};

				h = h.replace(/ class="([^"]+)"/gi, removeClasses);
				h = h.replace(/ class=([\-\w]+)/gi, removeClasses);
			}

			// Remove spans option
			if (getParam(ed, "paste_remove_spans")) {
				h = h.replace(/<\/?span[^>]*>/gi, "");
			}

			//console.log('After preprocess:' + h);

			o.content = h;
		},

		/**
		 * Various post process items.
		 */
		_postProcess : function(pl, o) {
			var t = this, ed = t.editor, dom = ed.dom, styleProps;

			if (ed.settings.paste_enable_default_filters == false) {
				return;
			}

			if (o.wordContent) {
				// Remove named anchors or TOC links
				each(dom.select('a', o.node), function(a) {
					if (!a.href || a.href.indexOf('#_Toc') != -1)
						dom.remove(a, 1);
				});

				if (getParam(ed, "paste_convert_middot_lists")) {
					t._convertLists(pl, o);
				}

				// Process styles
				styleProps = getParam(ed, "paste_retain_style_properties"); // retained properties

				// Process only if a string was specified and not equal to "all" or "*"
				if ((tinymce.is(styleProps, "string")) && (styleProps !== "all") && (styleProps !== "*")) {
					styleProps = tinymce.explode(styleProps.replace(/^none$/i, ""));

					// Retains some style properties
					each(dom.select('*', o.node), function(el) {
						var newStyle = {}, npc = 0, i, sp, sv;

						// Store a subset of the existing styles
						if (styleProps) {
							for (i = 0; i < styleProps.length; i++) {
								sp = styleProps[i];
								sv = dom.getStyle(el, sp);

								if (sv) {
									newStyle[sp] = sv;
									npc++;
								}
							}
						}

						// Remove all of the existing styles
						dom.setAttrib(el, 'style', '');

						if (styleProps && npc > 0)
							dom.setStyles(el, newStyle); // Add back the stored subset of styles
						else // Remove empty span tags that do not have class attributes
							if (el.nodeName == 'SPAN' && !el.className)
								dom.remove(el, true);
					});
				}
			}

			// Remove all style information or only specifically on WebKit to avoid the style bug on that browser
			if (getParam(ed, "paste_remove_styles") || (getParam(ed, "paste_remove_styles_if_webkit") && tinymce.isWebKit)) {
				each(dom.select('*[style]', o.node), function(el) {
					el.removeAttribute('style');
					el.removeAttribute('data-mce-style');
				});
			} else {
				if (tinymce.isWebKit) {
					// We need to compress the styles on WebKit since if you paste <img border="0" /> it will become <img border="0" style="... lots of junk ..." />
					// Removing the mce_style that contains the real value will force the Serializer engine to compress the styles
					each(dom.select('*', o.node), function(el) {
						el.removeAttribute('data-mce-style');
					});
				}
			}
		},

		/**
		 * Converts the most common bullet and number formats in Office into a real semantic UL/LI list.
		 */
		_convertLists : function(pl, o) {
			var dom = pl.editor.dom, listElm, li, lastMargin = -1, margin, levels = [], lastType, html;

			// Convert middot lists into real semantic lists
			each(dom.select('p', o.node), function(p) {
				var sib, val = '', type, html, idx, parents;

				// Get text node value at beginning of paragraph
				for (sib = p.firstChild; sib && sib.nodeType == 3; sib = sib.nextSibling)
					val += sib.nodeValue;

				val = p.innerHTML.replace(/<\/?\w+[^>]*>/gi, '').replace(/&nbsp;/g, '\u00a0');

				// Detect unordered lists look for bullets
				if (/^(__MCE_ITEM__)+[\u2022\u00b7\u00a7\u00d8o\u25CF]\s*\u00a0*/.test(val))
					type = 'ul';

				// Detect ordered lists 1., a. or ixv.
				if (/^__MCE_ITEM__\s*\w+\.\s*\u00a0+/.test(val))
					type = 'ol';

				// Check if node value matches the list pattern: o&nbsp;&nbsp;
				if (type) {
					margin = parseFloat(p.style.marginLeft || 0);

					if (margin > lastMargin)
						levels.push(margin);

					if (!listElm || type != lastType) {
						listElm = dom.create(type);
						dom.insertAfter(listElm, p);
					} else {
						// Nested list element
						if (margin > lastMargin) {
							listElm = li.appendChild(dom.create(type));
						} else if (margin < lastMargin) {
							// Find parent level based on margin value
							idx = tinymce.inArray(levels, margin);
							parents = dom.getParents(listElm.parentNode, type);
							listElm = parents[parents.length - 1 - idx] || listElm;
						}
					}

					// Remove middot or number spans if they exists
					each(dom.select('span', p), function(span) {
						var html = span.innerHTML.replace(/<\/?\w+[^>]*>/gi, '');

						// Remove span with the middot or the number
						if (type == 'ul' && /^__MCE_ITEM__[\u2022\u00b7\u00a7\u00d8o\u25CF]/.test(html))
							dom.remove(span);
						else if (/^__MCE_ITEM__[\s\S]*\w+\.(&nbsp;|\u00a0)*\s*/.test(html))
							dom.remove(span);
					});

					html = p.innerHTML;

					// Remove middot/list items
					if (type == 'ul')
						html = p.innerHTML.replace(/__MCE_ITEM__/g, '').replace(/^[\u2022\u00b7\u00a7\u00d8o\u25CF]\s*(&nbsp;|\u00a0)+\s*/, '');
					else
						html = p.innerHTML.replace(/__MCE_ITEM__/g, '').replace(/^\s*\w+\.(&nbsp;|\u00a0)+\s*/, '');

					// Create li and add paragraph data into the new li
					li = listElm.appendChild(dom.create('li', 0, html));
					dom.remove(p);

					lastMargin = margin;
					lastType = type;
				} else
					listElm = lastMargin = 0; // End list element
			});

			// Remove any left over makers
			html = o.node.innerHTML;
			if (html.indexOf('__MCE_ITEM__') != -1)
				o.node.innerHTML = html.replace(/__MCE_ITEM__/g, '');
		},

		/**
		 * Inserts the specified contents at the caret position.
		 */
		_insert : function(h, skip_undo) {
			var ed = this.editor, r = ed.selection.getRng();

			// First delete the contents seems to work better on WebKit when the selection spans multiple list items or multiple table cells.
			if (!ed.selection.isCollapsed() && r.startContainer != r.endContainer)
				ed.getDoc().execCommand('Delete', false, null);

			ed.execCommand('mceInsertContent', false, h, {skip_undo : skip_undo});
		},

		/**
		 * Instead of the old plain text method which tried to re-create a paste operation, the
		 * new approach adds a plain text mode toggle switch that changes the behavior of paste.
		 * This function is passed the same input that the regular paste plugin produces.
		 * It performs additional scrubbing and produces (and inserts) the plain text.
		 * This approach leverages all of the great existing functionality in the paste
		 * plugin, and requires minimal changes to add the new functionality.
		 * Speednet - June 2009
		 */
		_insertPlainText : function(content) {
			var ed = this.editor,
				linebr = getParam(ed, "paste_text_linebreaktype"),
				rl = getParam(ed, "paste_text_replacements"),
				is = tinymce.is;

			function process(items) {
				each(items, function(v) {
					if (v.constructor == RegExp)
						content = content.replace(v, "");
					else
						content = content.replace(v[0], v[1]);
				});
			};

			if ((typeof(content) === "string") && (content.length > 0)) {
				// If HTML content with line-breaking tags, then remove all cr/lf chars because only tags will break a line
				if (/<(?:p|br|h[1-6]|ul|ol|dl|table|t[rdh]|div|blockquote|fieldset|pre|address|center)[^>]*>/i.test(content)) {
					process([
						/[\n\r]+/g
					]);
				} else {
					// Otherwise just get rid of carriage returns (only need linefeeds)
					process([
						/\r+/g
					]);
				}

				process([
					[/<\/(?:p|h[1-6]|ul|ol|dl|table|div|blockquote|fieldset|pre|address|center)>/gi, "\n\n"],		// Block tags get a blank line after them
					[/<br[^>]*>|<\/tr>/gi, "\n"],				// Single linebreak for <br /> tags and table rows
					[/<\/t[dh]>\s*<t[dh][^>]*>/gi, "\t"],		// Table cells get tabs betweem them
					/<[a-z!\/?][^>]*>/gi,						// Delete all remaining tags
					[/&nbsp;/gi, " "],							// Convert non-break spaces to regular spaces (remember, *plain text*)
					[/(?:(?!\n)\s)*(\n+)(?:(?!\n)\s)*/gi, "$1"],// Cool little RegExp deletes whitespace around linebreak chars.
					[/\n{3,}/g, "\n\n"]							// Max. 2 consecutive linebreaks
				]);

				content = ed.dom.decode(tinymce.html.Entities.encodeRaw(content));

				// Perform default or custom replacements
				if (is(rl, "array")) {
					process(rl);
				} else if (is(rl, "string")) {
					process(new RegExp(rl, "gi"));
				}

				// Treat paragraphs as specified in the config
				if (linebr == "none") {
					// Convert all line breaks to space
					process([
						[/\n+/g, " "]
					]);
				} else if (linebr == "br") {
					// Convert all line breaks to <br />
					process([
						[/\n/g, "<br />"]
					]);
				} else if (linebr == "p") {
					// Convert all line breaks to <p>...</p>
					process([
						[/\n+/g, "</p><p>"],
						[/^(.*<\/p>)(<p>)$/, '<p>$1']
					]);
				} else {
					// defaults to "combined"
					// Convert single line breaks to <br /> and double line breaks to <p>...</p>
					process([
						[/\n\n/g, "</p><p>"],
						[/^(.*<\/p>)(<p>)$/, '<p>$1'],
						[/\n/g, "<br />"]
					]);
				}

				ed.execCommand('mceInsertContent', false, content);
			}
		},

		/**
		 * This method will open the old style paste dialogs. Some users might want the old behavior but still use the new cleanup engine.
		 */
		_legacySupport : function() {
			var t = this, ed = t.editor;

			// Register command(s) for backwards compatibility
			ed.addCommand("mcePasteWord", function() {
				ed.windowManager.open({
					file: t.url + "/pasteword.htm",
					width: parseInt(getParam(ed, "paste_dialog_width")),
					height: parseInt(getParam(ed, "paste_dialog_height")),
					inline: 1
				});
			});

			if (getParam(ed, "paste_text_use_dialog")) {
				ed.addCommand("mcePasteText", function() {
					ed.windowManager.open({
						file : t.url + "/pastetext.htm",
						width: parseInt(getParam(ed, "paste_dialog_width")),
						height: parseInt(getParam(ed, "paste_dialog_height")),
						inline : 1
					});
				});
			}

			// Register button for backwards compatibility
			ed.addButton("pasteword", {title : "paste.paste_word_desc", cmd : "mcePasteWord"});
		}
	});

	// Register plugin
	tinymce.PluginManager.add("paste", tinymce.plugins.PastePlugin);
})();/**
 * editor_template_src.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http://tinymce.moxiecode.com/license
 * Contributing: http://tinymce.moxiecode.com/contributing
 */

(function(tinymce) {
	var DOM = tinymce.DOM, Event = tinymce.dom.Event, extend = tinymce.extend, each = tinymce.each, Cookie = tinymce.util.Cookie, lastExtID, explode = tinymce.explode;

	// Tell it to load theme specific language pack(s)
//	tinymce.ThemeManager.requireLangPack('compose');

	tinymce.create('tinymce.themes.ComposeTheme', {
		sizes : [10, 12, 16, 20, 24, 30, 48],

		// Control name lookup, format: title, command
		controls : {
			bold : ['bold_desc', 'Bold'],
			italic : ['italic_desc', 'Italic'],
			underline : ['underline_desc', 'Underline'],
			strikethrough : ['striketrough_desc', 'Strikethrough'],
			justifyleft : ['justifyleft_desc', 'JustifyLeft'],
			justifycenter : ['justifycenter_desc', 'JustifyCenter'],
			justifyright : ['justifyright_desc', 'JustifyRight'],
			justifyfull : ['justifyfull_desc', 'JustifyFull'],
			bullist : ['bullist_desc', 'InsertUnorderedList'],
			numlist : ['numlist_desc', 'InsertOrderedList'],
			outdent : ['outdent_desc', 'Outdent'],
			indent : ['indent_desc', 'Indent'],
			cut : ['cut_desc', 'Cut'],
			copy : ['copy_desc', 'Copy'],
			paste : ['paste_desc', 'Paste'],
			undo : ['undo_desc', 'Undo'],
			redo : ['redo_desc', 'Redo'],
			addlink : ['link_desc', 'mceLink'],
			unlink : ['unlink_desc', 'unlink'],
			image : ['image_desc', 'mceImage'],
			cleanup : ['cleanup_desc', 'mceCleanup'],
			help : ['help_desc', 'mceHelp'],
			code : ['code_desc', 'mceCodeEditor'],
			hr : ['hr_desc', 'InsertHorizontalRule'],
			removeformat : ['removeformat_desc', 'RemoveFormat'],
			sub : ['sub_desc', 'subscript'],
			sup : ['sup_desc', 'superscript'],
			forecolor : ['forecolor_desc', 'ForeColor'],
			forecolorpicker : ['forecolor_desc', 'mceForeColor'],
			backcolor : ['backcolor_desc', 'HiliteColor'],
			backcolorpicker : ['backcolor_desc', 'mceBackColor'],
			charmap : ['charmap_desc', 'mceCharMap'],
			visualaid : ['visualaid_desc', 'mceToggleVisualAid'],
			anchor : ['anchor_desc', 'mceInsertAnchor'],
			newdocument : ['newdocument_desc', 'mceNewDocument'],
			blockquote : ['blockquote_desc', 'mceBlockQuote'],

            justifyselect: ['justifyselect_desc', 'JustifySelect'],
            moreactions: ['moreactions_desc', 'MoreActions'],
            fontactions: ['fontactions_desc', 'FontActions'],
            textindentactions: ['textindentactions_desc', 'TextIndentActions'],
            bullistactions: ['bullistactions_desc', 'bullistActions'],
            signature: ['signature_desc', 'mceSignature'],
            design: ['design_desc', 'mceDesign'],
            cards: ['cards_desc', 'mceCards'],

            apptransfer: ['apptransfer_desc', 'mceAppTransfer'],
            appkeyboard: ['appkeyboard_desc', 'mceAppKeyboard'],
            apptranslit: ['apptranslit_desc', 'mceAppTranslit'],
            appspelling: ['appspelling_desc', 'mceAppSpelling'],

            apptransfer2: ['apptransfer_desc', 'mceAppTransfer'],
            appkeyboard2: ['appkeyboard_desc', 'mceAppKeyboard'],
            apptranslit2: ['apptranslit_desc', 'mceAppTranslit'],
            appspelling2: ['appspelling_desc', 'mceAppSpelling'],

            moreapps: ['appmoreapps_desc', 'moreApps'],
            enableTextEditor: ['enabletexteditor_desc', 'mceEnableTextEditor'],
            enableHTMLEditor: ['enablehtmleditor_desc', 'mceEnableHTMLEditor']
		},

		stateControls : ['bold', 'italic', 'underline', 'strikethrough', 'bullist', 'numlist', 'justifyleft', 'justifycenter', 'justifyright', 'justifyfull', 'sub', 'sup', 'blockquote'],

		init : function(ed, url) {
			var t = this, s, v, o;

			t.editor = ed;
			t.url = url;
			t.onResolveName = new tinymce.util.Dispatcher(this);

			// Default settings
			t.settings = s = extend({
				theme_compose_path : true,
				theme_compose_toolbar_location : 'bottom',
				theme_compose_buttons1 : "bold,italic,underline,strikethrough,|,justifyleft,justifycenter,justifyright,justifyfull,|,styleselect,formatselect",
				theme_compose_buttons2 : "bullist,numlist,|,outdent,indent,|,undo,redo,|,link,unlink,anchor,image,cleanup,help,code",
				theme_compose_buttons3 : "hr,removeformat,visualaid,|,sub,sup,|,charmap",
				theme_compose_blockformats : "p,address,pre,h1,h2,h3,h4,h5,h6",
				theme_compose_toolbar_align : "center",
				theme_compose_fonts : "Andale Mono=andale mono,times;Arial=arial,helvetica,sans-serif;Arial Black=arial black,avant garde;Book Antiqua=book antiqua,palatino;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier;Georgia=georgia,palatino;Helvetica=helvetica;Impact=impact,chicago;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Times New Roman=times new roman,times;Trebuchet MS=trebuchet ms,geneva;Verdana=verdana,geneva;Webdings=webdings;Wingdings=wingdings,zapf dingbats",
				theme_compose_more_colors : 1,
				theme_compose_row_height : 23,
				theme_compose_resize_horizontal : 1,
				theme_compose_resizing_use_cookie : false,
				theme_compose_font_sizes : "1,2,3,4,5,6,7",
				readonly : ed.settings.readonly
			}, ed.settings);

			// Setup default font_size_style_values
			if (!s.font_size_style_values)
				s.font_size_style_values = "8pt,10pt,12pt,14pt,18pt,24pt,36pt";

			if (tinymce.is(s.theme_compose_font_sizes, 'string')) {
				s.font_size_style_values = tinymce.explode(s.font_size_style_values);
				s.font_size_classes = tinymce.explode(s.font_size_classes || '');

				// Parse string value
				o = {};
				ed.settings.theme_compose_font_sizes = s.theme_compose_font_sizes;

				each(ed.getParam('theme_compose_font_sizes', '', 'hash'), function(v, k) {
					var cl;

					if (k == v && v >= 1 && v <= 7) {
						k = v;
						cl = s.font_size_classes[v - 1];
						v = s.font_size_style_values[v - 1] || (t.sizes[v - 1] + 'pt');
					}

					if (/^\s*\./.test(v))
						cl = v.replace(/\./g, '');

					o[k] = cl ? {'class' : cl} : {fontSize : v};


				});

				s.theme_compose_font_sizes = o;
			}

			if ((v = s.theme_compose_path_location) && v != 'none')
				s.theme_compose_statusbar_location = s.theme_compose_path_location;

			if (s.theme_compose_statusbar_location == 'none')
				s.theme_compose_statusbar_location = 0;

			// Init editor
			ed.onInit.add(function() {
				if (!ed.settings.readonly)
					ed.onNodeChange.add(t._nodeChanged, t);

				if (ed.settings.content_css !== false)
					ed.dom.loadCSS(ed.baseURI.toAbsolute("themes/compose/skins/" + ed.settings.skin + "/content.css"));
			});

			ed.onSetProgressState.add(function(ed, b, ti) {
				var co, id = ed.id, tb;

				if (b) {
					t.progressTimer = setTimeout(function() {
						co = ed.getContainer();
						co = co.insertBefore(DOM.create('DIV', {style : 'position:relative'}), co.firstChild);
						tb = DOM.get(ed.id + '_tbl');

						DOM.add(co, 'div', {id : id + '_blocker', 'class' : 'mceBlocker', style : {width : tb.clientWidth + 2, height : tb.clientHeight + 2}});
						DOM.add(co, 'div', {id : id + '_progress', 'class' : 'mceProgress', style : {left : tb.clientWidth / 2, top : tb.clientHeight / 2}});
					}, ti || 0);
				} else {
					DOM.remove(id + '_blocker');
					DOM.remove(id + '_progress');
					clearTimeout(t.progressTimer);
				}
			});

			ed.onKeyPress.add(function(ed, e) {

				if (!e.ctrlKey && e.keyCode == 13)
				{
					var se = ed.selection, dom = ed.dom, markerId = '__';
					var parentBlock = dom.getParent(se.getNode(), 'blockquote');
					if (parentBlock)
					{
						// MAIL-3694
						var y = ed.getBody().scrollTop;
						se.setContent('<br id="' + markerId + '" /> ', {format : 'raw'});
						var marker = dom.get(markerId);
						dom.split(parentBlock, marker);
						marker.removeAttribute('id');
						se.select(marker);
						se.collapse(1);
						ed.getWin().scrollTo(0, y);
						return Event.cancel(e);
					}
				}
			});
		},

		createControl : function(n, cf, tb) {
			var cd, c;

			if (c = cf.createControl(n))
				return c;

			switch (n) {
				case "styleselect":
					return this._createStyleSelect();

				case "formatselect":
					return this._createBlockFormats();

				case "fontselect":
					return this._createFontSelect();

				case "fontsizeselect":
					return this._createFontSizeSelect();

				case "forecolor":
					return this._createForeColorMenu();

				case "emotions":
					return this._createEmotionsMenu();

				case "backcolor":
					return this._createBackColorMenu();

				case "justifyselect":
					return this._createJustifySelectMenu();

				case "moreactions":
					return this._createMoreActionsMenu(tb);

				case "fontactions":
					return this._createFontActionsMenu();

				case "textindentactions":
					return this._createTextIndentActionsMenu();

				case "bullistactions":
					return this._createBullistActionsMenu();

				case "signature":
					return this._createSignatureButton();

				case "design":
				case "cards":
					if ((cd = this.controls[n])) {
						return cf.createButton(n, {title : "compose." + cd[0], cmd : cd[1], ui : cd[2], value : cd[3], link: this.editor.getLang("compose." + cd[0])});
					}
					break;

				case "enableTextEditor":
					if ((cd = this.controls[n])) {
						return cf.createButton(n, {title : "compose." + cd[0], cmd : cd[1], ui : cd[2], value : cd[3], link: this.editor.getLang("compose." + cd[0]), linkPosition: 'left', linkAlign: 'left'});
					}
					break;

				case "enableHTMLEditor":
					if ((cd = this.controls[n])) {
						return cf.createButton(n, {title : "compose." + cd[0], cmd : cd[1], ui : cd[2], value : cd[3], link: this.editor.getLang("compose." + cd[0]), linkPosition: 'right', linkAlign: 'right'});
					}
					break;
			}

			if ((cd = this.controls[n]))
				return cf.createButton(n, {title : "compose." + cd[0], cmd : cd[1], ui : cd[2], value : cd[3]});
		},

		execCommand : function(cmd, ui, val) {
			var f = this['_' + cmd];

			if (f) {
				f.call(this, ui, val);
				return true;
			}

			return false;
		},

		_importClasses : function(e) {
			var ed = this.editor, ctrl = ed.controlManager.get('styleselect');

			if (ctrl.getLength() == 0) {
				each(ed.dom.getClasses(), function(o, idx) {
					var name = 'style_' + idx;

					ed.formatter.register(name, {
						inline : 'span',
						attributes : {'class' : o['class']},
						selector : '*'
					});

					ctrl.add(o['class'], name);
				});
			}
		},

		_createStyleSelect : function(n) {
			var t = this, ed = t.editor, ctrlMan = ed.controlManager, ctrl;

			// Setup style select box
			ctrl = ctrlMan.createListBox('styleselect', {
				title : 'compose.style_select',
				onselect : function(name) {
					var matches, formatNames = [];

					each(ctrl.items, function(item) {
						formatNames.push(item.value);
					});

					ed.focus();
					ed.undoManager.add();

					// Toggle off the current format
					matches = ed.formatter.matchAll(formatNames);
					if (!name || matches[0] == name) {
						if (matches[0])
						ed.formatter.remove(matches[0]);
					} else
						ed.formatter.apply(name);

					ed.undoManager.add();
					ed.nodeChanged();

					return false; // No auto select
				}
			});

			// Handle specified format
			ed.onInit.add(function() {
				var counter = 0, formats = ed.getParam('style_formats');

				if (formats) {
					each(formats, function(fmt) {
						var name, keys = 0;

						each(fmt, function() {keys++;});

						if (keys > 1) {
							name = fmt.name = fmt.name || 'style_' + (counter++);
							ed.formatter.register(name, fmt);
							ctrl.add(fmt.title, name);
						} else
							ctrl.add(fmt.title);
					});
				} else {
					each(ed.getParam('theme_compose_styles', '', 'hash'), function(val, key) {
						var name;

						if (val) {
							name = 'style_' + (counter++);

							ed.formatter.register(name, {
								inline : 'span',
								classes : val,
								selector : '*'
							});

							ctrl.add(t.editor.translate(key), name);
						}
					});
				}
			});

			// Auto import classes if the ctrl box is empty
			if (ctrl.getLength() == 0) {
				ctrl.onPostRender.add(function(ed, n) {
					if (!ctrl.NativeListBox) {
						Event.add(n.id + '_text', 'focus', t._importClasses, t);
						Event.add(n.id + '_text', 'mousedown', t._importClasses, t);
						Event.add(n.id + '_open', 'focus', t._importClasses, t);
						Event.add(n.id + '_open', 'mousedown', t._importClasses, t);
					} else
						Event.add(n.id, 'focus', t._importClasses, t);
				});
			}

			return ctrl;
		},

		_createFontSelect : function() {
			var c, t = this, ed = t.editor;

			c = ed.controlManager.createListBox('fontselect', {
				title : 'compose.fontdefault',
				onselect : function(v) {
					var cur = c.items[c.selectedIndex];

					if (!v && cur) {
						ed.execCommand('FontName', false, cur.value);
						return null;
					}

					ed.execCommand('FontName', false, v);

					// Fake selection, execCommand will fire a nodeChange and update the selection
					c.select(function(sv) {
						return v == sv;
					});

					return false; // No auto select
				}
			});

			if (c) {
				each(ed.getParam('theme_compose_fonts', t.settings.theme_compose_fonts, 'hash'), function(v, k) {
					c.add(ed.translate(k), v, {style : v.indexOf('dings') == -1 ? 'font-family:' + v : ''});
				});
			}

			return c;
		},

		_createFontSizeSelect : function() {
			var t = this, ed = t.editor, c, i = 0, cl = [];

			c = ed.controlManager.createListBox('fontsizeselect', {title : 'compose.font_size', onselect : function(v) {
				var cur = c.items[c.selectedIndex];

				if (!v && cur) {
					cur = cur.value;

					if (cur['class']) {
						ed.formatter.toggle('fontsize_class', {value : cur['class']});
						ed.undoManager.add();
						ed.nodeChanged();
					} else {
						ed.execCommand('FontSize', false, cur.fontSize);
					}

					return null;
				}

				if (v['class']) {
					ed.focus();
					ed.undoManager.add();
					ed.formatter.toggle('fontsize_class', {value : v['class']});
					ed.undoManager.add();
					ed.nodeChanged();
				} else
					ed.execCommand('FontSize', false, v.fontSize);

				// Fake selection, execCommand will fire a nodeChange and update the selection
				c.select(function(sv) {
					return v == sv;
				});

				return false; // No auto select
			}});

			if (c) {
				each(t.settings.theme_compose_font_sizes, function(v, k) {
					var fz = v.fontSize;

					if (fz >= 1 && fz <= 7)
						fz = t.sizes[parseInt(fz) - 1] + 'pt';

					c.add(k, v, {'style' : 'font-size:' + fz, 'class' : 'mceFontSize' + (i++) + (' ' + (v['class'] || ''))});
				});
			}

			return c;
		},

		_createBlockFormats : function() {
			var c, fmts = {
				p : 'compose.paragraph',
				address : 'compose.address',
				pre : 'compose.pre',
				h1 : 'compose.h1',
				h2 : 'compose.h2',
				h3 : 'compose.h3',
				h4 : 'compose.h4',
				h5 : 'compose.h5',
				h6 : 'compose.h6',
				div : 'compose.div',
				blockquote : 'compose.blockquote',
				code : 'compose.code',
				dt : 'compose.dt',
				dd : 'compose.dd',
				samp : 'compose.samp'
			}, t = this;

			c = t.editor.controlManager.createListBox('formatselect', {title : 'compose.block', cmd : 'FormatBlock'});
			if (c) {
				each(t.editor.getParam('theme_compose_blockformats', t.settings.theme_compose_blockformats, 'hash'), function(v, k) {
					c.add(t.editor.translate(k != v ? k : fmts[v]), v, {'class' : 'mce_formatPreview mce_' + v});
				});
			}

			return c;
		},

		_createFontActionsMenu : function() {
			var c, t = this, s = t.settings, i = 0, o = {}, v, ed = t.editor;
			o.title = 'compose.fontactions_desc';
			o.scope = this;

			var fss = ed.controlManager.createDropMenu('fontsizeselect', {
				menu_line : 1,
//				'class' : 'mceFontSizeSelectMenu mceNoIcons',
				id: 'fontsizeselect',
				relative: true,
//				max_width : 101,
//				max_height : 190,
				title : ed.getLang('compose.font_size')
			});

			fss.select = function(va)
			{
				each(fss.items, function(v)
				{
					v.setSelected(false);
				});

				if (va)
				{
					each(fss.items, function(v)
					{
						if (va(v.settings.value))
						{
							v.setSelected(true);
							return false;
						}
					});
				}
			};

			each(t.settings.theme_compose_font_sizes, function(v, k) {

				var fz = v.fontSize;
				if (fz >= 1 && fz <= 7)
					fz = t.sizes[parseInt(fz) - 1] + 'px';

				if (i == 2)
					k += ' ' + ed.getLang('compose.font_normal_label');

				var o = {
					title: k,
					value: v,
					style: 'font-size:' + fz,
					'class': 'mceFontSize' + (i++) + (' ' + (v['class'] || ''))
				};

				o.id = DOM.uniqueId();
				o.onclick = function(q1) {

					each(fss.items, function(v)
					{
						v.setSelected(false);
					});

					var id = q1.getAttribute('id');
					var item = fss.items[id];
					item.setSelected(true);

					ed.execCommand('FontSize', false, item.settings.value.fontSize);

					fss.select(function(sv) {
						return v == sv;
					});

					return false;
				};

				fss.add(o);
			});

			var fs = ed.controlManager.createDropMenu('fontselect', {
				menu_line : 1,
//				'class' : 'mceFontSelectMenu mceNoIcons',
				id: 'fontselect',
				relative: true,
//				max_width : 129,
//				max_height : 190,
				title : ed.getLang('compose.fontdefault')
			});

			fs.select = function(va)
			{
				each(fs.items, function(v)
				{
					v.setSelected(false);
				});

				if (va)
				{
					each(fs.items, function(v)
					{
						if (va(v.settings.value))
						{
							v.setSelected(true);
							return false;
						}
					});
				}
			};

			each(t.editor.getParam('theme_compose_fonts', t.settings.theme_compose_fonts, 'hash'), function(v, k) {

				var o = {
					title: ed.translate(k),
					value: v,
					style: v.indexOf('dings') == -1 ? 'font-family:' + v : ''
				};

				o.id = DOM.uniqueId();
				o.onclick = function(q1) {

					each(fs.items, function(v)
					{
						v.setSelected(false);
					});

					var id = q1.getAttribute('id');
					var item = fs.items[id];
					item.setSelected(true);
					ed.execCommand('FontName', false, item.settings.value);

					fs.select(function(sv) {
						return v == sv;
					});

					return false;
				};

				fs.add(o);
			});

            o.controls = [fss, fs];
			c = ed.controlManager.createFontButton('fontactions', o);
			return c;
		},

		_createTextIndentActionsMenu: function()
		{
			var c, t = this, s = t.settings, o = {}, v;
			o.title = 'compose.textindentactions_desc';
			o.scope = this;
            o.controls = ['outdent', 'indent'];
			c = t.editor.controlManager.createControlsButton('textindentactions', o);
			return c;
		},

		_createSignatureButton: function() {
			var c, t = this, s = t.settings, o = {}, v;
			o.title = 'compose.signature_desc';
			o.link = t.editor.getLang(o.title);
			o.cmd = 'mceSignature';
			o.scope = this;

			o.onclick = function(){
//				c.setActive(!c.isActive());
				this.execCommand(o.cmd, false, c.isActive());
			};

			c = t.editor.controlManager.createSignatureButton('signature', o);
			return c;
		},

		_createBullistActionsMenu: function()
		{
			var c, t = this, s = t.settings, o = {}, v;
			o.title = 'compose.bullistactions_desc';
			o.scope = this;
            o.controls = ['numlist', 'bullist'];
			c = t.editor.controlManager.createControlsButton('bullistactions', o);
			return c;
		},

		_createMoreActionsMenu: function(tb) {
			var c, t = this, s = t.settings, o = {}, v;
			o.title = 'compose.moreactions_desc';
			o.link = t.editor.getLang('compose.more');
			o.scope = this;
			o.linkPosition = 'right';
            o.expandControls = [];
            o.controls = [];

			if (s.moreactions_controls) {
				o.expandControls = s.moreactions_controls.expand_controls;
				o.controls = s.moreactions_controls.controls;
			}

			c = t.editor.controlManager.createControlsButton('moreactions', o);
			return c;
		},

		_createJustifySelectMenu : function() {
			var c, t = this, o = {};
			o.title = 'compose.justifyselect_desc';
			o.scope = this;
            o.controls = ['justifyleft', 'justifycenter', 'justifyright'];
			c = t.editor.controlManager.createControlsButton('justifyselect', o);
			return c;
		},

		_createEmotionsMenu: function()
		{
			var c, t = this, s = t.settings, o = {}, v;
			o.title = 'compose.emotions_desc';
			o.cmd = 'ForeColor';
			o.scope = this;
			c = t.editor.controlManager.createEmotionsSplitButton('emotions', o);
			return c;
		},

		_createForeColorMenu : function() {
			var c, t = this, s = t.settings, o = {}, v;

			if (s.theme_compose_more_colors) {
				o.more_colors_func = function() {
					t._mceColorPicker(0, {
						color : c.value,
						func : function(co) {
							c.setColor(co);
						}
					});
				};
			}

			if (v = s.theme_compose_text_colors)
				o.colors = v;

			if (s.theme_compose_default_foreground_color)
				o.default_color = s.theme_compose_default_foreground_color;

			o.title = 'compose.forecolor_desc';
			o.cmd = 'ForeColor';
			o.scope = this;

			c = t.editor.controlManager.createColorSplitButton('forecolor', o);

			return c;
		},

		_createBackColorMenu : function() {
			var c, t = this, s = t.settings, o = {}, v;
			if (v = s.theme_compose_background_colors)
				o.colors = v;

			if (s.theme_compose_default_background_color)
				o.default_color = s.theme_compose_default_background_color;

			o.title = 'compose.backcolor_desc';
			o.cmd = 'HiliteColor';
			o.scope = this;

			c = t.editor.controlManager.createColorSplitButton('backcolor', o);

			return c;
		},

		renderUI : function(o) {
			var n, ic, tb, t = this, ed = t.editor, s = t.settings, sc, p, nl;

			n = p = DOM.create('span', {id : ed.id + '_parent', 'class' : 'mceEditor ' + ed.settings.skin + 'Skin' + (s.skin_variant ? ' ' + ed.settings.skin + 'Skin' + t._ufirst(s.skin_variant) : '')});

			if (!DOM.boxModel)
				n = DOM.add(n, 'div', {'class' : 'mceOldBoxModel'});

			n = sc = DOM.add(n, 'table', {id : ed.id + '_tbl', 'class' : 'mceLayout', cellSpacing : 0, cellPadding : 0});
			n = tb = DOM.add(n, 'tbody');

			switch ((s.theme_compose_layout_manager || '').toLowerCase()) {
				case "rowlayout":
					ic = t._rowLayout(s, tb, o);
					break;

				case "customlayout":
					ic = ed.execCallback("theme_compose_custom_layout", s, tb, o, p);
					break;

				default:
					ic = t._simpleLayout(s, tb, o, p);
			}

			n = o.targetNode;

			// Add classes to first and last TRs
			nl = DOM.stdMode ? sc.getElementsByTagName('tr') : sc.rows; // Quick fix for IE 8
			DOM.addClass(nl[0], 'mceFirst');
			DOM.addClass(nl[nl.length - 1], 'mceLast');

			// Add classes to first and last TDs
			each(DOM.select('tr', tb), function(n) {
				DOM.addClass(n.firstChild, 'mceFirst');
				DOM.addClass(n.childNodes[n.childNodes.length - 1], 'mceLast');
			});

			if (DOM.get(s.theme_compose_toolbar_container))
				DOM.get(s.theme_compose_toolbar_container).appendChild(p);
			else
				DOM.insertAfter(p, n);

			Event.add(ed.id + '_path_row', 'click', function(e) {
				e = e.target;

				if (e.nodeName == 'A') {
					t._sel(e.className.replace(/^.*mcePath_([0-9]+).*$/, '$1'));

					return Event.cancel(e);
				}
			});
/*
			if (DOM.get(ed.id + '_path_row')) {
				Event.add(ed.id + '_tbl', 'mouseover', function(e) {
					var re;

					e = e.target;

					if (e.nodeName == 'SPAN' && DOM.hasClass(e.parentNode, 'mceButton')) {
						re = DOM.get(ed.id + '_path_row');
						t.lastPath = re.innerHTML;
						DOM.setHTML(re, e.parentNode.title);
					}
				});

				Event.add(ed.id + '_tbl', 'mouseout', function(e) {
					if (t.lastPath) {
						DOM.setHTML(ed.id + '_path_row', t.lastPath);
						t.lastPath = 0;
					}
				});
			}
*/

			if (!ed.getParam('accessibility_focus'))
				Event.add(DOM.add(p, 'a', {href : '#'}, '<!-- IE -->'), 'focus', function() {tinyMCE.get(ed.id).focus();});

			if (s.theme_compose_toolbar_location == 'external')
				o.deltaHeight = 0;

			t.deltaHeight = o.deltaHeight;
			o.targetNode = null;

			return {
				iframeContainer : ic,
				editorContainer : ed.id + '_parent',
				sizeContainer : sc,
				deltaHeight : o.deltaHeight
			};
		},

		resizeBy : function(dw, dh) {
			var e = DOM.get(this.editor.id + '_tbl');

			this.resizeTo(e.clientWidth + dw, e.clientHeight + dh);
		},

		resizeTo : function(w, h) {
			var ed = this.editor, s = this.settings, e = DOM.get(ed.id + '_tbl'), ifr = DOM.get(ed.id + '_ifr');

			// Boundery fix box
			w = Math.max(s.theme_compose_resizing_min_width || 100, w);
			h = Math.max(s.theme_compose_resizing_min_height || 100, h);
			w = Math.min(s.theme_compose_resizing_max_width || 0xFFFF, w);
			h = Math.min(s.theme_compose_resizing_max_height || 0xFFFF, h);

			// Resize iframe and container
			DOM.setStyle(e, 'height', '');
			DOM.setStyle(ifr, 'height', h);

			if (s.theme_compose_resize_horizontal) {
				DOM.setStyle(e, 'width', '');
				DOM.setStyle(ifr, 'width', w);

				// Make sure that the size is never smaller than the over all ui
				if (w < e.clientWidth)
					DOM.setStyle(ifr, 'width', e.clientWidth);
			}
		},

		destroy : function() {
			var id = this.editor.id;

			Event.clear(id + '_resize');
			Event.clear(id + '_path_row');
			Event.clear(id + '_external_close');
		},

		// Internal functions

		_simpleLayout : function(s, tb, o, p) {
			var t = this, ed = t.editor, lo = s.theme_compose_toolbar_location, sl = s.theme_compose_statusbar_location, n, ic, etb, c;

			if (s.readonly) {
				n = DOM.add(tb, 'tr');
				n = ic = DOM.add(n, 'td', {'class' : 'mceIframeContainer'});
				return ic;
			}

			// Create toolbar container at top
			if (lo == 'top')
				t._addToolbars(tb, o);

			// Create external toolbar
			if (lo == 'external') {

                if (s.theme_compose_toolbar_external_id)
                {
                    n = c = DOM.get(s.theme_compose_toolbar_external_id);
                    DOM.addClass(n, 'defaultSkin');
                    n = DOM.add(n, 'div', {id : ed.id + '_external', 'class' : 'mceExternalToolbar', style : 'position:relative;display:block'});
                }
                else
                {
                    n = c = DOM.create('div', {style : 'position:relative'});
                    n = DOM.add(n, 'div', {id : ed.id + '_external', 'class' : 'mceExternalToolbar'});
                    DOM.add(n, 'a', {id : ed.id + '_external_close', href : 'javascript:;', 'class' : 'mceExternalClose'});
                }

				n = DOM.add(n, 'table', {id : ed.id + '_tblext', cellSpacing : 0, cellPadding : 0, 'style': 'width:100%;'});
				etb = DOM.add(n, 'tbody');

                 if (!s.theme_compose_toolbar_external_id)
                 {
                    if (p.firstChild.className == 'mceOldBoxModel')
                        p.firstChild.appendChild(c);
                    else
                        p.insertBefore(c, p.firstChild);
                 }

                t._addToolbars(etb, o);

                if (!s.theme_compose_toolbar_external_id)
                {
                    ed.onMouseUp.add(function() {
                        var e = DOM.get(ed.id + '_external');
                        DOM.show(e);

                        DOM.hide(lastExtID);

                        var f = Event.add(ed.id + '_external_close', 'click', function() {
                            DOM.hide(ed.id + '_external');
                            Event.remove(ed.id + '_external_close', 'click', f);
                        });

                        DOM.show(e);
                        DOM.setStyle(e, 'top', 0 - DOM.getRect(ed.id + '_tblext').h - 1);

                        // Fixes IE rendering bug
                        DOM.hide(e);
                        DOM.show(e);
                        e.style.filter = '';

                        lastExtID = ed.id + '_external';

                        e = null;
                    });
                 }
			}

			if (sl == 'top')
				t._addStatusBar(tb, o);

			// Create iframe container
			if (!s.theme_compose_toolbar_container) {
				n = DOM.add(tb, 'tr');
				n = ic = DOM.add(n, 'td', {'class' : 'mceIframeContainer'});
			}

			// Create toolbar container at bottom
			if (lo == 'bottom')
				t._addToolbars(tb, o);

			if (sl == 'bottom')
				t._addStatusBar(tb, o);

			return ic;
		},

		_rowLayout : function(s, tb, o) {
			var t = this, ed = t.editor, dc, da, cf = ed.controlManager, n, ic, to, a;

			dc = s.theme_compose_containers_default_class || '';
			da = s.theme_compose_containers_default_align || 'center';

			each(explode(s.theme_compose_containers || ''), function(c, i) {
				var v = s['theme_compose_container_' + c] || '';

				switch (v.toLowerCase()) {
					case 'mceeditor':
						n = DOM.add(tb, 'tr');
						n = ic = DOM.add(n, 'td', {'class' : 'mceIframeContainer'});
						break;

					case 'mceelementpath':
						t._addStatusBar(tb, o);
						break;

					default:
						a = (s['theme_compose_container_' + c + '_align'] || da).toLowerCase();
						a = 'mce' + t._ufirst(a);

						n = DOM.add(DOM.add(tb, 'tr'), 'td', {
							'class' : 'mceToolbar ' + (s['theme_compose_container_' + c + '_class'] || dc) + ' ' + a || da
						});

						to = cf.createToolbar("toolbar" + i);
						t._addControls(v, to);
						DOM.setHTML(n, to.renderHTML());
						o.deltaHeight -= s.theme_compose_row_height;
				}
			});

			return ic;
		},

		_addControls : function(v, tb) {
			var t = this, s = t.settings, di, cf = t.editor.controlManager;

			if (s.theme_compose_disable && !t._disabled) {
				di = {};

				each(explode(s.theme_compose_disable), function(v) {
					di[v] = 1;
				});

				t._disabled = di;
			} else
				di = t._disabled;

			each(explode(v), function(n) {
				var c;

				if (di && di[n])
					return;

				// Compatiblity with 2.x
				if (n == 'tablecontrols') {
					each(["table","|","row_props","cell_props","|","row_before","row_after","delete_row","|","col_before","col_after","delete_col","|","split_cells","merge_cells"], function(n) {
						n = t.createControl(n, cf);

						if (n)
							tb.add(n);
					});

					return;
				}

				c = t.createControl(n, cf, tb);

				if (c)
					tb.add(c);
			});
		},

		_addToolbars : function(c, o) {
			var t = this, i, tb, ed = t.editor, s = t.settings, v, cf = ed.controlManager, di, n, h = [], a;

			a = s.theme_compose_toolbar_align.toLowerCase();
			a = 'mce' + t._ufirst(a);

			n = DOM.add(DOM.add(c, 'tr'), 'td', {'class' : 'mceToolbar ' + a});

			if (!ed.getParam('accessibility_focus'))
				h.push(DOM.createHTML('a', {href : '#', onfocus : 'tinyMCE.get(\'' + ed.id + '\').focus();'}, '<!-- IE -->'));

//			h.push(DOM.createHTML('a', {href : '#', accesskey : 'q', title : ed.getLang("compose.toolbar_focus")}, '<!-- IE -->'));

			// Create toolbar and add the controls
			for (i=1; (v = s['theme_compose_buttons' + i]); i++) {
				tb = cf.createToolbar("toolbar" + i, {'class' : 'mceToolbarRow' + i});

				if (s['theme_compose_buttons' + i + '_add'])
					v += ',' + s['theme_compose_buttons' + i + '_add'];

				if (s['theme_compose_buttons' + i + '_add_before'])
					v = s['theme_compose_buttons' + i + '_add_before'] + ',' + v;

				t._addControls(v, tb);

				//n.appendChild(n = tb.render());
				h.push(tb.renderHTML());

				o.deltaHeight -= s.theme_compose_row_height;
			}

//			h.push(DOM.createHTML('a', {href : '#', accesskey : 'z', title : ed.getLang("compose.toolbar_focus"), onfocus : 'tinyMCE.getInstanceById(\'' + ed.id + '\').focus();'}, '<!-- IE -->'));
			DOM.setHTML(n, h.join(''));
		},

		_addStatusBar : function(tb, o) {
			var n, t = this, ed = t.editor, s = t.settings, r, mf, me, td;

			n = DOM.add(tb, 'tr');
			n = td = DOM.add(n, 'td', {'class' : 'mceStatusbar'});
			n = DOM.add(n, 'div', {id : ed.id + '_path_row'}, s.theme_compose_path ? ed.translate('compose.path') + ': ' : '&#160;');
			DOM.add(n, 'a', {href : '#', accesskey : 'x'});

			if (s.theme_compose_resizing) {
				DOM.add(td, 'a', {id : ed.id + '_resize', href : 'javascript:;', onclick : "return false;", 'class' : 'mceResize'});

				if (s.theme_compose_resizing_use_cookie) {
					ed.onPostRender.add(function() {
						var o = Cookie.getHash("TinyMCE_" + ed.id + "_size"), c = DOM.get(ed.id + '_tbl');

						if (!o)
							return;

						t.resizeTo(o.cw, o.ch);
					});
				}

				ed.onPostRender.add(function() {
					Event.add(ed.id + '_resize', 'mousedown', function(e) {
						var mouseMoveHandler1, mouseMoveHandler2,
							mouseUpHandler1, mouseUpHandler2,
							startX, startY, startWidth, startHeight, width, height, ifrElm;

						function resizeOnMove(e) {
							width = startWidth + (e.screenX - startX);
							height = startHeight + (e.screenY - startY);

							t.resizeTo(width, height);
						};

						function endResize(e) {
							// Stop listening
							Event.remove(DOM.doc, 'mousemove', mouseMoveHandler1);
							Event.remove(ed.getDoc(), 'mousemove', mouseMoveHandler2);
							Event.remove(DOM.doc, 'mouseup', mouseUpHandler1);
							Event.remove(ed.getDoc(), 'mouseup', mouseUpHandler2);

							// Store away the size
							if (s.theme_compose_resizing_use_cookie) {
								Cookie.setHash("TinyMCE_" + ed.id + "_size", {
									cw : width,
									ch : height
								});
							}
						};

						e.preventDefault();

						// Get the current rect size
						startX = e.screenX;
						startY = e.screenY;
						ifrElm = DOM.get(t.editor.id + '_ifr');
						startWidth = width = ifrElm.clientWidth;
						startHeight = height = ifrElm.clientHeight;

						// Register envent handlers
						mouseMoveHandler1 = Event.add(DOM.doc, 'mousemove', resizeOnMove);
						mouseMoveHandler2 = Event.add(ed.getDoc(), 'mousemove', resizeOnMove);
						mouseUpHandler1 = Event.add(DOM.doc, 'mouseup', endResize);
						mouseUpHandler2 = Event.add(ed.getDoc(), 'mouseup', endResize);
					});
				});
			}

			o.deltaHeight -= 21;
			n = tb = null;
		},

		_nodeChanged : function(ed, cm, n, co, ob) {
			var t = this, p, de = 0, v, c, s = t.settings, cl, fz, fn, formatNames, matches;

			tinymce.each(t.stateControls, function(c) {
				cm.setActive(c, ed.queryCommandState(t.controls[c][1]));
			});

			function getParent(name) {
				var i, parents = ob.parents, func = name;

				if (typeof(name) == 'string') {
					func = function(node) {
						return node.nodeName == name;
					};
				}

				for (i = 0; i < parents.length; i++) {
					if (func(parents[i]))
						return parents[i];
				}
			};

			cm.setActive('visualaid', ed.hasVisual);
			cm.setDisabled('undo', !ed.undoManager.hasUndo() && !ed.typing);
			cm.setDisabled('redo', !ed.undoManager.hasRedo());
			cm.setDisabled('outdent', !ed.queryCommandState('Outdent'));

			p = getParent('A');
			if (c = cm.get('link')) {
				if (!p || !p.name) {
					c.setDisabled(!p && co);
					c.setActive(!!p);
				}
			}

			if (c = cm.get('unlink')) {
				c.setDisabled(!p && co);
				c.setActive(!!p && !p.name);
			}

			if (c = cm.get('anchor')) {
				c.setActive(!!p && p.name);
			}

			p = getParent('IMG');
			if (c = cm.get('image'))
				c.setActive(!!p && n.className.indexOf('mceItem') == -1);

			if (c = cm.get('styleselect')) {
				t._importClasses();

				formatNames = [];
				each(c.items, function(item) {
					formatNames.push(item.value);
				});

				matches = ed.formatter.matchAll(formatNames);
				c.select(matches[0]);
			}

			if (c = cm.get('formatselect')) {
				p = getParent(DOM.isBlock);

				if (p)
					c.select(p.nodeName.toLowerCase());
			}

			// Find out current fontSize, fontFamily and fontClass
			getParent(function(n) {
				if (n.nodeName === 'SPAN') {
					if (!cl && n.className)
						cl = n.className;

					if (!fz && n.style.fontSize)
						fz = n.style.fontSize;

					if (!fn && n.style.fontFamily)
						fn = n.style.fontFamily.replace(/[\"\']+/g, '').replace(/^([^,]+).*/, '$1').toLowerCase();
				}

				return false;
			});

			if (c = cm.get('fontselect')) {
				c.select(function(v) {
					return v.replace(/^([^,]+).*/, '$1').toLowerCase() == fn;
				});
			}

			// Select font size
			if (c = cm.get('fontsizeselect')) {
				// Use computed style
				if (s.theme_compose_runtime_fontsize && !fz && !cl)
					fz = ed.dom.getStyle(n, 'fontSize', true);

				c.select(function(v) {
					if (v.fontSize && v.fontSize === fz)
						return true;

					if (v['class'] && v['class'] === cl)
						return true;
				});
			}

			if (s.theme_compose_path && s.theme_compose_statusbar_location) {
				p = DOM.get(ed.id + '_path') || DOM.add(ed.id + '_path_row', 'span', {id : ed.id + '_path'});
				DOM.setHTML(p, '');

				getParent(function(n) {
					var na = n.nodeName.toLowerCase(), u, pi, ti = '';

					// Ignore non element and hidden elements
					if (n.nodeType != 1 || n.nodeName === 'BR' || (DOM.hasClass(n, 'mceItemHidden') || DOM.hasClass(n, 'mceItemRemoved')))
						return;

					// Fake name
					if (v = DOM.getAttrib(n, 'mce_name'))
						na = v;

					// Handle prefix
					if (tinymce.isIE && n.scopeName !== 'HTML')
						na = n.scopeName + ':' + na;

					// Remove internal prefix
					na = na.replace(/mce\:/g, '');

					// Handle node name
					switch (na) {
						case 'b':
							na = 'strong';
							break;

						case 'i':
							na = 'em';
							break;

						case 'img':
							if (v = DOM.getAttrib(n, 'src'))
								ti += 'src: ' + v + ' ';

							break;

						case 'a':
							if (v = DOM.getAttrib(n, 'name')) {
								ti += 'name: ' + v + ' ';
								na += '#' + v;
							}

							if (v = DOM.getAttrib(n, 'href'))
								ti += 'href: ' + v + ' ';

							break;

						case 'font':
							if (v = DOM.getAttrib(n, 'face'))
								ti += 'font: ' + v + ' ';

							if (v = DOM.getAttrib(n, 'size'))
								ti += 'size: ' + v + ' ';

							if (v = DOM.getAttrib(n, 'color'))
								ti += 'color: ' + v + ' ';

							break;

						case 'span':
							if (v = DOM.getAttrib(n, 'style'))
								ti += 'style: ' + v + ' ';

							break;
					}

					if (v = DOM.getAttrib(n, 'id'))
						ti += 'id: ' + v + ' ';

					if (v = n.className) {
						v = v.replace(/\b\s*(webkit|mce|Apple-)\w+\s*\b/g, '');

						if (v) {
							ti += 'class: ' + v + ' ';

							if (DOM.isBlock(n) || na == 'img' || na == 'span')
								na += '.' + v;
						}
					}

					na = na.replace(/(html:)/g, '');
					na = {name : na, node : n, title : ti};
					t.onResolveName.dispatch(t, na);
					ti = na.title;
					na = na.name;

					//u = "javascript:tinymce.EditorManager.get('" + ed.id + "').theme._sel('" + (de++) + "');";
					pi = DOM.create('a', {'href' : "javascript:;", onmousedown : "return false;", title : ti, 'class' : 'mcePath_' + (de++)}, na);

					if (p.hasChildNodes()) {
						p.insertBefore(DOM.doc.createTextNode(' \u00bb '), p.firstChild);
						p.insertBefore(pi, p.firstChild);
					} else
						p.appendChild(pi);
				}, ed.getBody());
			}
		},

		// Commands gets called by execCommand

		_sel : function(v) {
			this.editor.execCommand('mceSelectNodeDepth', false, v);
		},

		_mceLink: function(ui, val){

			this.linkMenu = this.linkMenu || new tinymce.ui.AddLinkMenu(this.editor);
			this.linkMenu.bm = this.editor.selection.getBookmark(1);
			this.linkMenu.showMenu();
		},

		_mceForeColor : function() {
			var t = this;
			this._mceColorPicker(0, {
				color: t.fgColor,
				func : function(co) {
					t.fgColor = co;
					t.editor.execCommand('ForeColor', false, co);
				}
			});
		},

 		_mceBackColor : function() {
			var t = this;
			this._mceColorPicker(0, {
				color: t.bgColor,
				func : function(co) {
					t.bgColor = co;
					t.editor.execCommand('HiliteColor', false, co);
				}
			});
		},

		_ufirst : function(s) {
			return s.substring(0, 1).toUpperCase() + s.substring(1);
		},

		_mceDesign: function() {
			var t = this, ed = t.editor, control = ed.controlManager.get('design');
			if (control.isActive()) {
				ed.execCommand('mceHideTemplates');
			} else {
				ed.execCommand('mceShowTemplates');
			}
		},

		_mceCards: function() {
			var t = this, ed = t.editor, control = ed.controlManager.get('cards');
			if (control.isActive()) {
				ed.execCommand('mceHideCards');
			} else {
				ed.execCommand('mceShowCards');
			}
		},

		_mceSignature: function(){},
		_mceSetSignature: function(){},
		_mceAppKeyboard: function(){},
		_mceAppTransfer: function(){},
		_mceAppTranslit: function(){},
		_mceAppSpelling: function(){},
		_mceShowTemplates: function(){},
		_mceHideTemplates: function(){},
		_mceShowCards: function(){},
		_mceHideCards: function(){},
		_mceEnableTextEditor: function(){},
		_mceEnableHTMLEditor: function(){}
	});

	tinymce.ThemeManager.add('compose', tinymce.themes.ComposeTheme);
}(tinymce));
jsLoader.loaded('{tiny_mce_modern}tiny_mce', 1);

// data/ru/images/js/ru/tiny_mce_modern/tiny_mce.js end

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.Form.js start


// data/ru/images/js/ru/jsCore/plugins/AjaxCall.js start


(function($)
	{
		/**
		 * @class AjaxCall
		 */
		jsClass
		.create('AjaxCall')
		.statics({

			redirect: function(url)
			{
				AjaxCall.triggerHandler('beforeredirect');
				window.location.href = url;
			},

			parseArray: function(a)
			{
				var result = null;

				if ($.isArray(a))
				{
					var status = a[1];
					if (status === 'Redirect')
					{
						AjaxCall.redirect(a[2]);
					}
					else if (status === 'OK')
					{
						result = a.slice(2);

						if (result.length == 1)
							result = result.shift();
					}
				}

				return result;
			},

			parseResponse: function(responseText)
			{
				var response;

				try
				{
					response = $.parseJSON(responseText, { 'url': 'AjaxCall.parseResponse' });
				}
				catch(e){}

				return AjaxCall.parseArray(response);
			},

			send: function(url, funcName, data, success, error)
			{
				for (var a=[], v, i=0, l=data.length; i<l; i++)
				{
					v = data[i];
					if (typeof v === 'string')
					{
						v = v.replace(/\\/g, '\\\\')
							.replace(/"/g, '\\"')
							.replace(/\t/g, '\\t')
							.replace(/\n/g, '\\n')
							.replace(/\f/g, '\\f')
							.replace(/\r/g, '\\r');
					}
					a.push(v);
				}

				return $.ajax({
					url: url,
					type: 'post',
					data: {
						ajax_call: 1,
						func_name: funcName,
						data: '["' + a.join('","') + '"]'
					},
					dataType: 'json',
					complete: (function(success, error)
					{
						return function(xhr)
						{
							var response, result;

							try
							{
								response = $.parseJSON(xhr.responseText, { 'url': url });
							}
							catch(e){}

							if ($.isArray(response))
							{
								var status = response[1];
								if (status === 'Redirect')
								{
									AjaxCall.redirect(response[2]);
								}
								else if (status === 'OK')
								{
									result = response.slice(2);

									if (result.length == 1)
										result = result.shift();

									success.call(xhr, result);
								}
								else
								{
									error.call(xhr);
								}
							}
							else
							{
								error.call(xhr);
							}
						};
					})(success || $.noop, error || $.noop)
				});
			}
		});

		$.extend(AjaxCall, new jQueryEvent());

	})(jQuery);

	jsLoader.loaded('{plugins}AjaxCall', 1);

// data/ru/images/js/ru/jsCore/plugins/AjaxCall.js end

// data/ru/images/js/ru/ui/mailru.ui.FileSearch.js start


// ./data/common/js/waypoints/waypoints.min.js start

define('waypoints/waypoints.min', function() {

/*
jQuery Waypoints - v1.1.7
Copyright (c) 2011-2012 Caleb Troughton
Dual licensed under the MIT license and GPL license.
https://github.com/imakewebthings/jquery-waypoints/blob/master/MIT-license.txt
https://github.com/imakewebthings/jquery-waypoints/blob/master/GPL-license.txt
*/
(function($,k,m,i,d){var e=$(i),g="waypoint.reached",b=function(o,n){o.element.trigger(g,n);if(o.options.triggerOnce){o.element[k]("destroy")}},h=function(p,o){if(!o){return -1}var n=o.waypoints.length-1;while(n>=0&&o.waypoints[n].element[0]!==p[0]){n-=1}return n},f=[],l=function(n){$.extend(this,{element:$(n),oldScroll:0,waypoints:[],didScroll:false,didResize:false,doScroll:$.proxy(function(){var q=this.element.scrollTop(),p=q>this.oldScroll,s=this,r=$.grep(this.waypoints,function(u,t){return p?(u.offset>s.oldScroll&&u.offset<=q):(u.offset<=s.oldScroll&&u.offset>q)}),o=r.length;if(!this.oldScroll||!q){$[m]("refresh")}this.oldScroll=q;if(!o){return}if(!p){r.reverse()}$.each(r,function(u,t){if(t.options.continuous||u===o-1){b(t,[p?"down":"up"])}})},this)});$(n).bind("scroll.waypoints",$.proxy(function(){if(!this.didScroll){this.didScroll=true;i.setTimeout($.proxy(function(){this.doScroll();this.didScroll=false},this),$[m].settings.scrollThrottle)}},this)).bind("resize.waypoints",$.proxy(function(){if(!this.didResize){this.didResize=true;i.setTimeout($.proxy(function(){$[m]("refresh");this.didResize=false},this),$[m].settings.resizeThrottle)}},this));e.load($.proxy(function(){this.doScroll()},this))},j=function(n){var o=null;$.each(f,function(p,q){if(q.element[0]===n){o=q;return false}});return o},c={init:function(o,n){this.each(function(){var u=$.fn[k].defaults.context,q,t=$(this);if(n&&n.context){u=n.context}if(!$.isWindow(u)){u=t.closest(u)[0]}q=j(u);if(!q){q=new l(u);f.push(q)}var p=h(t,q),s=p<0?$.fn[k].defaults:q.waypoints[p].options,r=$.extend({},s,n);r.offset=r.offset==="bottom-in-view"?function(){var v=$.isWindow(u)?$[m]("viewportHeight"):$(u).height();return v-$(this).outerHeight()}:r.offset;if(p<0){q.waypoints.push({element:t,offset:null,options:r})}else{q.waypoints[p].options=r}if(o){t.bind(g,o)}if(n&&n.handler){t.bind(g,n.handler)}});$[m]("refresh");return this},remove:function(){return this.each(function(o,p){var n=$(p);$.each(f,function(r,s){var q=h(n,s);if(q>=0){s.waypoints.splice(q,1);if(!s.waypoints.length){s.element.unbind("scroll.waypoints resize.waypoints");f.splice(r,1)}}})})},destroy:function(){return this.unbind(g)[k]("remove")}},a={refresh:function(){$.each(f,function(r,s){var q=$.isWindow(s.element[0]),n=q?0:s.element.offset().top,p=q?$[m]("viewportHeight"):s.element.height(),o=q?0:s.element.scrollTop();$.each(s.waypoints,function(u,x){if(!x){return}var t=x.options.offset,w=x.offset;if(typeof x.options.offset==="function"){t=x.options.offset.apply(x.element)}else{if(typeof x.options.offset==="string"){var v=parseFloat(x.options.offset);t=x.options.offset.indexOf("%")?Math.ceil(p*(v/100)):v}}x.offset=x.element.offset().top-n+o-t;if(x.options.onlyOnScroll){return}if(w!==null&&s.oldScroll>w&&s.oldScroll<=x.offset){b(x,["up"])}else{if(w!==null&&s.oldScroll<w&&s.oldScroll>=x.offset){b(x,["down"])}else{if(!w&&s.element.scrollTop()>x.offset){b(x,["down"])}}}});s.waypoints.sort(function(u,t){return u.offset-t.offset})})},viewportHeight:function(){return(i.innerHeight?i.innerHeight:e.height())},aggregate:function(){var n=$();$.each(f,function(o,p){$.each(p.waypoints,function(q,r){n=n.add(r.element)})});return n}};$.fn[k]=function(n){if(c[n]){return c[n].apply(this,Array.prototype.slice.call(arguments,1))}else{if(typeof n==="function"||!n){return c.init.apply(this,arguments)}else{if(typeof n==="object"){return c.init.apply(this,[null,n])}else{$.error("Method "+n+" does not exist on jQuery "+k)}}}};$.fn[k].defaults={continuous:true,offset:0,triggerOnce:false,context:i};$[m]=function(n){if(a[n]){return a[n].apply(this)}else{return a.aggregate()}};$[m].settings={resizeThrottle:200,scrollThrottle:100};e.load(function(){$[m]("refresh")})})(jQuery,"waypoint","waypoints",window);

});

// ./data/common/js/waypoints/waypoints.min.js end

/**
	 * @class mailru.Compose.FileSearch
	 */
	jsClass
	.create('mailru.ui.FileSearch')
	.extend(jQueryEvent)
	.statics({
		defaultOptions: {

			templateExpandId: '#AttachViewer__list__thumbnail_ejs',
			templateCompactId: '#files-search__messageline_ejs',

			waypoint: {
				context: '.js-wrapper',
				offset: '150%'
			},

			loadData: {
				name_needle: '',
				folder_id: 0,
				content_type_id: -1,
				offset: 0,
				limit: 12
			},

			spaceLeft: 0,
			filesLimit:0,
			filesCount:0

		}
	})
	.methods({

		__construct: function(options) {

			this.options = $.extend({}, mailru.ui.FileSearch.defaultOptions, options);
			this.loadData = $.extend({}, this.options.loadData);

			this.files = [];
			this.filesMap = {};
			this.checkedFilesMap = {};

			this.utils = mailru.FullAttachViewer.Utils;

			this.waypointTickObserver = this._waypointTick.bind(this);

			this.listClickObserver = this._listClick.bind(this);
			this.listMouseWheelObserver = this._listMouseWheel.bind(this);

			this.resizeObserver = this._resize.bind(this);

			this.searchButtonClickObserver = this._searchButtonClick.bind(this);

			this.switcherClickObserver = this._switcherClick.bind(this);
		},

		_initialize: function () {

			this.$searchField = this.layer.$div.find('.js-search-field');
			this.$searchButton = this.layer.$div.find('.js-search-button');

			this.$switcher = this.layer.$div.find('.js-switcher');
			this.$waypoint = this.layer.$div.find('.js-waypoint');
			this.$list = this.layer.$div.find('.js-list');
			this.$wrapper = this.layer.$div.find('.js-wrapper');
			this.$loading = $('<p>' + Lang.get('notify.load') + '&#133;</p>');
			this.$notFound = $('<p>' + Lang.get('filesearch.not_found') + '</p>');
			this.$error = this.layer.$div.find('.js-error');

			this.layer.$div.find('#filesearch__folders')
								.tpl('#filesearch__folders_ejs', {
									folders: mailru.Folders.getAll()
								});

			this.$dropdownSelectFolder = $('.js-dropdown-select-folder', this.layer.$div).dropdown({
				link: '.dropdown__button-inline',
				container: '.dropdown__list',
				orientation: 'auto',
				onToggle: function(isOpen, dropdown) {
					Counter.sb(1345762);
				},
				onClick: function (evt, dropdown) {
					var $prefix = $('.js-prefix', this.layer.$div);
					var $item = $(evt.target).closest('.dropdown__list__item', dropdown.$container);
					var $mainLink = $('.dropdown__button-inline__text', dropdown.$link);
					var type = $item.data('id'), value = $item.data('value'), prefix = $item.data('prefix');
					if ($item.length) {
						$mainLink.text(value);
						$prefix.text(prefix);
						if (this.loadData.folder_id != type) {
							this.loadData.folder_id = type;
							this._reload();
						}
					}
					dropdown.hide();
				}.bind(this)
			});

			this.$dropdownSelectType = $('.js-dropdown-select-type', this.layer.$div).dropdown({
				link: '.dropdown__button',
				container: '.dropdown__list',
				orientation: 'auto',
				onClick: function (evt, dropdown) {
					var $item = $(evt.target).closest('.dropdown__list__item', dropdown.$container);
					var $link = $('.dropdown__list__item__link__text', $item);
					var $mainLink = $('.dropdown__button__text', dropdown.$link);
					var type = $item.data('type');
					if ($item.length) {
						$mainLink.text($link.text());
						if (this.loadData.content_type_id != type) {
							this.loadData.content_type_id = type;
							this._reload();
						}
					}

					if (type == '1') // mail-11956
						Counter.sb(1345752);
					else if (type == '4')
						Counter.sb(1345753);
					else if (type == '2')
						Counter.sb(1345754);
					else if (type == '3')
						Counter.sb(1345755);
					else if (type == '0')
						Counter.sb(1345756);
					else if (type == '-1')
						Counter.sb(1345759);

					dropdown.hide();
				}.bind(this)
			});

			this.$switcher.bind('click', this.switcherClickObserver);
			this.$list.bind('click', this.listClickObserver);
			this.$searchButton.bind('click', this.searchButtonClickObserver);

			this.wrapperMaxHeight = this.layer.$div.height() - this.$wrapper[0].offsetHeight;
		},

		show: function (spaceLeft, filesCount) {
			if(spaceLeft) {
				this.options.spaceLeft = spaceLeft;
			}
			if(filesCount) {
				this.options.filesCount = filesCount;
			}

			if (this.layer) {

				this.layer.show();

			} else if (!this.layerloading) {

				this.layerloading = true;

				Layer.get('filesearch', function (layer) {

					this.layer = layer;

					layer.bind({
						callback: function (evt, status) {
							if (status) {
								var files = this._getSelectedFiles();
								this.triggerHandler('select', [files]);
								Counter.sb(1345771);
							}
							else if (status === false) {
								Counter.sb(1345772);
							}
						}.bind(this),
						show: function () {
							this._show();
						}.bind(this),
						hide: function () {
							this._hide();
						}.bind(this)
					});

					this._initialize();

					layer.show();

				}.bind(this));
			}
		},

		hide: function () {
			this.layer.hide();
		},

		reset: function () {
			// reset all saved params
			$.extend(this.options.loadData, mailru.ui.FileSearch.defaultOptions.loadData); // reset selected folder id
			if (this.$dropdownSelectFolder)
				this.$dropdownSelectFolder.find('.js-default').click(); // reset folder dropdown

		},

		_show: function () {

			$.extend(this.loadData, this.options.loadData);

			this.$dropdownSelectType.find('.js-default').click();
//			this.$dropdownSelectFolder.find('.js-default').click(); // do not reset folder

			this.$switcher.toggleClass('attachlist__header__mode_short', !!mailru.MailFilesViewStyle);

			this.layer.mainDiv.$innerDiv.css('width', 722);

			this.$waypoint.waypoint(this.waypointTickObserver, this.options.waypoint);
//			this.$list.bind('DOMMouseScroll mousewheel', this.listMouseWheelObserver);
			$(window).bind('resize', this.resizeObserver).triggerHandler('resize');

			$Scroll.css('overflow', 'hidden');

			this.$searchField.val('');
		},

		_hide: function () {

			this.isDataLoad = false;

			this._clearData();

			this.layer.mainDiv.$innerDiv.css('width', '');
			this.$waypoint.waypoint('destroy');
//			this.$list.unbind('DOMMouseScroll mousewheel', this.listMouseWheelObserver);
			$(window).unbind('resize', this.resizeObserver);

			$Scroll.css('overflow', '');

			//save folder id
			this.options.loadData.folder_id = this.loadData.folder_id;
		},

		_getSelectedFiles: function () {
			var files = [];
			$.each(this.checkedFilesMap, function (k) {
				files.push(this.filesMap[k]);
			}.bind(this));
			return files;
		},

		_listMouseWheel: function (evt) {
			if (this.total && this.loadData.offset < this.total && this.$wrapper[0].scrollHeight - this.$wrapper[0].scrollTop - this.$wrapper[0].offsetHeight <= 0) {
				evt.preventDefault();
			}
		},

		_resize: function() {
			var resized = this._update();
			this.triggerHandler('resize');
			if (resized)
				this.layer.mainDiv._resize(); // update popup position
		},

		_update: function () { // MAIL-11300
			var windowHeight = ajs.windowHeight();
			var divHeight = this.layer.$div.height();
			var wrapperHeight = this.$wrapper[0].offsetHeight;

			var wrapperOffset = divHeight - wrapperHeight // div height - wrapper height
			var maxHeight = this.wrapperMaxHeight || 464;
			var minHeight = 175;
			var	 divOffset = 20; // popup's offset from top and bottom window boundaries


			var newHeight = Math.min(windowHeight - divOffset - wrapperOffset, maxHeight);
			if (newHeight < minHeight) newHeight = minHeight;

			var resized = false;
			if(newHeight != wrapperHeight) {
				this.$wrapper.css('height', newHeight+'px');
				resized = true;
			}
			return resized;
		},

		_waypointTick: function (event, direction) {
			this.$waypoint.waypoint('remove');
			if (!this.isDataLoad || this.loadData.offset < this.total) {
				this.isDataLoad = true;
				this._load();
			}
		},

		_clearData: function () {
			this.$list.empty();
			this.files = [];
			this.filesMap = {};
			this.checkedFilesMap = {};
			this.total = this.loadData.offset = 0;
		},

		_reload: function () {
			this._clearData();
			this._load();
		},

		_load: function () {
			this.$notFound.detach();
			this.$list.append(this.$loading);
			mailru.Ajax({
				url: '/cgi-bin/filesearch_ajax?ajax_call=1&func_name=ajax_search',
				data: this.loadData,
				complete: this._loadComplete.bind(this)
			});
		},

		_loadComplete: function (result) {

			var data = result.getData(), files = [];

			if (data && data.total) {

				this.total = data.total;

				var mainData = {
					MainMailHost: location.host
				};

				$.each(data.list, function (k, fileData) {

					fileData = $.extend({
						PartID: [fileData.id].concat(fileData.n).join(';')
					}, fileData);

					if (fileData.content_type_id == 1) {
						if (fileData.name) {
							if (!/^tiff?$/i.test(fileData.name.replace(/(.*)\./, '').toLowerCase())) {
								fileData.IsImage = fileData.ShowThumbnail = 1;
							}
						}
					}

					mainData.Id = fileData.id;

					var file = this.utils.createFileDescription(mainData, fileData, k);

					files.push(file);
					this.files.push(file);

					this.filesMap[file.PartID] = file;

				}.bind(this));

				this.loadData.offset += files.length;

				var html = this._getHTMLTemplate([], files);

				this.$list.append(html);

				this.$waypoint.waypoint(this.options.waypoint);

			} else {

				this.$list.append(this.$notFound);
			}

			this._updateDisabled();

			this.$loading.detach();
		},

		_getHTMLTemplate: function (selected, files) {

			var templateData = {
				selected: selected,
				newsnippets: 1,
				Attachments: files,
				messages: files
			};

			var templateId = this.options.templateExpandId;

			if (mailru.MailFilesViewStyle) {
				templateId = this.options.templateCompactId;
			}

			return $.tpl(templateId, templateData);
		},

		_updateDisabled: function () {

			// get selected files
			var size = 0;
			var files = this._getSelectedFiles();

			// check files limit
			var isLimitExceeded = false;
			if( files.length >= this.options.filesLimit - this.options.filesCount ) {
				isLimitExceeded = true;
				this.$error
					.fadeIn()
					.find('.js-error-text')
					.text(String.sprintf.apply(ajs, [Lang.get('upload.limit'), this.options.filesLimit]));
			} else {
				this.$error.hide();
			}

			// count size
			$.each(files, function (k, file) {
				size += file.size;
			});

			// spaceLeft
			var spaceLeft = Math.max(this.options.spaceLeft - size, 0);

			//disable big files
			var disabledFilesMap = {};
			$.each(this.files, function (k, file) {
				if (file.size > spaceLeft) {
					disabledFilesMap[file.PartID] = file;
				}
			});

			var $item, $checkbox, fileId;
			$('.js-item', this.$list).each(function() {
				$item = $(this);
				$checkbox = $('.js-input', $item);
				fileId = $item.data('fileId');

				if((disabledFilesMap[fileId] || isLimitExceeded) && !$checkbox.attr('checked')) {
					// file is too big and not selected - disable it
					$checkbox.attr('disabled', 'disabled');
				}
				else {
					$checkbox.removeAttr('disabled');
				}
			});
		},

		_searchButtonClick: function (evt) {
			evt.preventDefault();
			this.loadData.name_needle = this.$searchField.val();
			this._reload();
			Counter.sb(1345769);
		},

		_listClick: function (evt) {

			var $target = $(evt.target);
			var $item = $target.closest('.js-item', this.$container);
			var $link = $target.closest('.js-link', $item);
			var $label = $target.closest('.js-label', $item);
			var $checkbox = $item.find('.js-input');
			var $preview = $target.closest('.js-preview', $item);

			var fileId = $item.data('fileId');

			if (!$checkbox.attr('disabled') && !$preview.length && fileId) {

				var file = this.filesMap[fileId];

				if (file) {

					if ($label.length) {

						if ($checkbox.attr('checked')) {
							this.checkedFilesMap[fileId] = 1;
						} else {
							delete this.checkedFilesMap[fileId];
						}

					} else if ($item.length && $link.length) {

						if ($checkbox.attr('checked')) {
							$checkbox.attr('checked', '');
							delete this.checkedFilesMap[fileId];
						} else {
							$checkbox.attr('checked', 'checked');
							this.checkedFilesMap[fileId] = 1;

							if(!$target.hasClass('js-input')) {
								// click outside the checkbox
								var files = this._getSelectedFiles();
								if( files.length == 1) {
									// if user click on file, not on
									this.triggerHandler('select', [files]);
									this.hide();
								}
							}
						}

						evt.preventDefault();
					}

					this._updateDisabled();
				}
			} else if ($checkbox.attr('disabled')) {
				evt.preventDefault();
			}
		},

		_switcherClick: function () {
			mailru.MailFilesViewStyle = !mailru.MailFilesViewStyle;
			this.$switcher.toggleClass('attachlist__header__mode_short', !!mailru.MailFilesViewStyle);
			if (this.files.length) {
				var html = this._getHTMLTemplate(this.checkedFilesMap, this.files);
				this.$list.html(html);
				this.$wrapper.scrollTop(0);
				this.$waypoint.waypoint(this.options.waypoint);
			} else {
				this.$list.append(this.$notFound);
			}
			this._updateDisabled();
			Counter.sb(1345766);
		}
	});

	jsLoader.loaded('{mailru.ui}mailru.ui.FileSearch', 1);

// data/ru/images/js/ru/ui/mailru.ui.FileSearch.js end

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.FormValidator.js start


(function($)
	{
		/**
		 * @class mailru.Compose.FormValidator
		 */
		jsClass
		.create('mailru.Compose.FormValidator')
		.methods({

			__construct: function(form)
			{
				var t = this;
				t.$form = $(form);
			},

			unactive: function()
			{
			},

			validate: function()
			{
				var t = this;
				var $input;

				$input = t._formElm('To');

				if (!$.trim($input.val()))
				{
					alert(Lang.get('compose.field_to_empty'));
					$input.focus();
					return false;
				} else if (mailru.ComposeLabels) {
					var names = ['To', 'CC', 'BCC']
						, widget
						, i = 0
						;

					for( ; i < names.length; i++) {
						$input = t._formElm(names[i]);
						widget = $input.closest('.js-compose-labels').composeLabels("widget");
						if ( widget && !widget.isValid() ) {
							ajs.log('invalid', names[i]);
							var txt = Lang.get('compose.field.invalid_address')
								, a = Lang.get('compose.field.'+names[i]);
							alert(String.sprintf(txt,a));
							$input.focus();
							return false;
						}
					}
				}

				return true;
			},

			_formElm: function (name) {
				return	$('input[name="'+name+'"], textarea[name="'+name+'"]', this.$form);
			}
		});

	})(jQuery);

	jsLoader.loaded('{mailru.compose}mailru.Compose.FormValidator', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.FormValidator.js end

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.FileUploader.js start


// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.FileUploaderJS.js start


(function($) {

		/**
		 * @class   mailru.Compose.FileUploaderJS
		 */
		jsClass
		.create('mailru.Compose.FileUploaderJS')
		.extend(jQueryEvent)
		.methods({

			__construct: function(form, opts)
			{
				var t = this;

				t.options = $.extend({}, mailru.Compose.FileUploaderJS.defaultOptions, opts);

				t.$form = $(form);

				t.$form.data('defaultAction', t.$form.attr('action'));
				t.$form.data('defaultTarget', t.$form.attr('target'));

				t.filesCount = t.filesSize = 0;
				t.fileMap = {};
				t.filesData = {};

				var domIDs = t.options.domIDs;

				t.$container = $(domIDs.JSUploaderContainer);
				t.$filesList = $('.list:first', t.$container);
				t.$filesCount = $('.fCount:first', t.$container);
				t.$filesSize = $('.fSize:first', t.$container);
				t.fileTpl = $(domIDs.JSUploaderFileTpl).html();

				t.bind('onQueueChanged', $.proxy(function() {
					var t = this;
					t._updateFilesCount();
					t._updateFilesSize();
					t._updateContainerVisible();
				}, t));

				t.$browseFileInput = $('input[type="file"]:first', domIDs.BrowseFile);

				t._addBrowseInputFileEvents();

				t.$uploadFrame = $('<iframe src="javascript:false;" name="id' + jsCore.getUniqId() + '"/>')
					.hide()
					.appendTo(form)
					.bind('load error', $.proxy(t._frameLoad, t));
			},

			_updateContainerVisible: function() {
				var t = this;
				t.$container.toggleClass('jsdn', t.filesCount <= 0);
				$(window).resize();
			},

			_addBrowseInputFileEvents: function() {
				var t = this;
				t.$browseFileInput.change($.proxy(t._browseInputChange, t));
			},

			_browseInputChange: function() {
				var t = this;
				t.submiting = true;
				t.$form.attr({
					'action': '/cgi-bin/sentmsg?ajax_upload=1&compose_name=' + t.settings.name + '&r=' + jsCore.getUniqId(),
					'target': t.$uploadFrame.attr('name')
				}).trigger('submit', [{'force': true}]);
				t.triggerHandler('onQueueStart');
			},

			_frameLoad: function() {
				var t = this;
				if (t.submiting) {
					t.submiting = false;

					// reset field
					var $input = t.$browseFileInput;
					var $clone = $('<input type="file"/>')
						.attr({
							'class': $input.attr('class'),
							'name': $input.attr('name'),
							'multiple': $input.attr('multiple')
						 });
					$input.replaceWith(t.$browseFileInput = $clone);
					t._addBrowseInputFileEvents();

					t.$form.attr({
						'action': t.$form.data('defaultAction'),
						'target': t.$form.data('defaultTarget')
					});
					t.triggerHandler('onQueueChanged', [t.filesCount]);
					t.triggerHandler('onQueueFinsh');
				}
			},

			_updateFilesCount: function() {
				var t = this;
				t.$filesCount.html(String.num(t.filesCount, Lang.get('files.plural'), ' '));
			},

			_updateFilesSize: function() {
				var t = this;
				t.$filesSize.html(String.sizeFormat(t.filesSize));
			},

			_deleteFileClick: function(evt) {
				var t = this;
				var $target = $(evt.target);
				var $node = $target.parents('.mlr-snd_fls_itm:first');

				var layer = t.getConfirmLayer();
				layer.one('callback', (function($node) {
					return function(evt, status) {
						if (status)
							t._deleteFile($node);
					};
				})($node))[0].show();

				evt.preventDefault();
			},

			_deleteFile: function($node) {
				var t = this;
				var fileData = $node.data('file');

				AjaxCall.send(
					t.config.UploadConfig[1].AjaxURI.replace(/^https?:/,''),
					'cbHardDeleteFile',
					[fileData.Id, 'message=' + t.settings.MessageId]
				);

				$node.remove();

				t.filesCount--;
				t.filesSize -= ~~fileData.Size;

				delete t.filesData[fileData.Id];

				t.triggerHandler('onQueueChanged', [t.filesCount]);
			},

			_addFileEvents: function($node) {
				var t = this;
				$('.mlr-snd-del:first', $node).click($.proxy(t._deleteFileClick, t));
			},

			_prepareFileData: function(data) {
				data.Size = data.Size || 0;
				return $.extend(data, {
					'SizeForShow': String.sizeFormat(data.Size),
					'FileExt': data.FileName.replace(/(.*)\./, '').toLowerCase()
				});
			},

			_addDropFiles: function (filesData) {
				var t = this;
				for (var fileData, i=0, l=filesData.length; i<l; i++) {
					fileData = filesData[i];
					t._addDropFile(fileData.id, fileData.file);
				}
				t.triggerHandler('onQueueChanged', [t.filesCount]);
				t.triggerHandler('onQueueFinsh');
			},

			_addDropFile: function (fid, file) {
				var t = this;
				var o = {'FileName': file.name, 'Size': file.size};
				var data = t._prepareFileData(o);
				var $node = $(String.supplant(t.fileTpl, data));
				t.filesCount++;
				t.filesSize += o.Size;
				t.fileMap[fid] = $node.appendTo(t.$filesList);
			},

			_progressUpload: function () {
			},

			_addFile: function(fid, file) {
				var t = this;
				var data = t._prepareFileData(file);
				var $newnode = $(String.supplant(t.fileTpl, data));

				if (t.fileMap[fid]) {
					t.fileMap[fid].replaceWith($newnode);
				}
				else {
					t.filesCount++;
					t.filesSize += ~~file.Size;
					t.$filesList.append($newnode);
				}

				t.filesData[data.Id] = data;

				$newnode.data('file', file);
				t._addFileEvents($newnode);
			},

			getConfirmLayer: function() {
				var t = this;
				return t.layer || (t.layer = new Layer('is-delete_attach'));
			},

			init: function(settings, config) {
				var t = this;
				t.settings = settings;
				t.config = config;
//				t.$browseFileInput.removeAttr('disabled').removeClass('button-a_disabled');
				t.initFiles(settings.mailRestoreList);
			},

			unactive: function() {
			},

			reset: function() {
				var t = this;
				t.$filesList.empty();
				t.filesData = {};
				t.filesCount = t.filesSize = 0;
				t.triggerHandler('onQueueChanged', [t.filesCount]);
			},

			getUploadedAttachments: function() {
				var t = this, r = [];
				$.each(t.filesData, function(key, data) {
					r.push({'fileid': data.Id, 'filesize': data.Size});
				});
				return r;
			},

			getFiles: function() {
				return [];
			},

			initFiles: function(files) {
				var t = this;
				t.$filesList.empty();
				t.filesCount = t.filesSize = 0;
				if (files) {
					$.each(files, $.proxy(function(key, value) {
						var t = this;
						t.filesCount++;
						t.filesSize += value.filesize;
						var data = t._prepareFileData({
							'Id': value.fileid,
							'Size': value.filesize,
							'FileName': value.filename
						});

						t.filesData[data.Id] = data;

						var $node = $(String.supplant(t.fileTpl, data))
							.appendTo(t.$filesList)
							.data('file', data);
						t._addFileEvents($node);
					}, t));
				}

				t.triggerHandler('onQueueChanged', [t.filesCount]);
			},

			attachUpload: function(fid, fileData, file) {
				var t = this;
				if (fileData.Error) {
					t.triggerHandler('fileLoadError', [fileData]);
				}
				else {
					t._addFile(fid, fileData, file);
					t.triggerHandler('onQueueChanged', [t.filesCount]);
					t.triggerHandler('onQueueFinsh');
				}
			}
		});

	})(jQuery);

	jsLoader.loaded('{mailru.compose}mailru.Compose.FileUploaderJS', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.FileUploaderJS.js end

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.FileUploaderSWF.js start


(function($) {

		/**
		 * @class mailru.Compose.FileUploaderSWF
		 */
		jsClass
		.create('mailru.Compose.FileUploaderSWF')
		.extend(jQueryEvent)
		.statics({

			previewSizeLimit: Math.MB * 10,

			defaultOptions: {
				allowVersion: '10.0.12'
			},

			createPreviewDataURL: function (img, maxWidth, maxHeight) {

				var ratio = Math.max(maxWidth / img.width, maxHeight / img.height),
					newWidth = img.width * ratio, newHeight = img.height * ratio,

					canvas = document.createElement('canvas'),
					ctx = canvas.getContext('2d'),
					canvasCopy = document.createElement('canvas'),
					ctxCopy = canvasCopy.getContext('2d');

				canvasCopy.width = img.width;
				canvasCopy.height = img.height;
				ctxCopy.drawImage(img, 0, 0);

				canvas.width = maxWidth;
				canvas.height = maxHeight;

				ctx.fillStyle = 'rgb(255,255,255)';
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.drawImage(canvasCopy, 0, 0, canvasCopy.width, canvasCopy.height, (canvas.width - newWidth) / 2, (canvas.height - newHeight) / 2, newWidth, newHeight);

				canvasCopy = ctx = ctxCopy = null;

				return canvas.toDataURL('image/jpeg');
			}
		})
		.methods({

			__construct: function(form, opts)
			{
				var t = this;

				t.options = $.extend({}, mailru.Compose.FileUploaderSWF.defaultOptions, opts);

				t.$form = $(form);

				t.completeUploadCallbacks = {};
				t.startUpload = {};

				var
					  domIDs	= t.options.domIDs
					, flashId	= domIDs.flashUploader.substr(1)
				;


				t.$flashUploaderContainer = $(domIDs.flashUploaderContainer, t.$form);

				t.flashConfig = {
					'flashId': flashId,
					'width': 125,
					'height': 22,
					'allowVersion': t.options.allowVersion,
					'vars': {
						  'hidebutton':					1
						, 'localChain':					'ru_RU'
						, 'FlashLog':					'FlashLog' + flashId
						, 'MRUUploader':				'MRUUploader' + flashId
						, 'GetUploadCookie':			'GetUploadCookie' + flashId
						, 'OnChangeFlashScreen':		'OnChangeFlashScreen' + flashId
						, 'setHeightToFileUploader':	'setHeightToFileUploader' + flashId
						, '_AjaxViaAdobeFlashIsReady':	'_AjaxViaAdobeFlashIsReady' + flashId

					},
					'params': {
						'allowScriptAccess': 'always',
						'wmode': 'transparent',
						'menu': false,
						'loop': false
					}
				};

				t.bind('flashLoad', $.proxy(function(evt, flash)
				{
					var t = this;

					t.$flashObj = $(flash);

					t.SWFJSApi = new mailru.Compose.FileUploaderSWF.SWFJSApi(flashId);
					t.JSSWFApi = new mailru.Compose.FileUploaderSWF.JSSWFApi(flash);


					t.SWFJSApi.bind({

						'_AjaxViaAdobeFlashIsReady': $.proxy(function() {
							var t = this;
							t.JSSWFApi.SetUploadConfig(JSON.stringify(t.config.UploadConfig), JSON.stringify(t.config.GlobalConfig));
							if (mailru.EnableFlashLog) {
								t.JSSWFApi.toggleFlashLog(true);
							}
							t.JSSWFApi.setLocalization(mailru.fileUploaderSWFStrings);

							t.triggerHandler('_AjaxViaAdobeFlashIsReady', Array.prototype.slice.call(arguments, 1));
						}, t),

						'OnChangeFlashScreen': $.proxy(function(evt, mode) {
							var t = this;
							t.$flashObj.css('width', mode ? '100%' : t.flashConfig.width);
							t.triggerHandler('OnChangeFlashScreen', Array.prototype.slice.call(arguments, 1));
						}, t),

						'setHeightToFileUploader': $.proxy(function(evt, height) {
							var t = this;
							t.$flashObj.attr('height', height);
							$(window).resize();
							t.triggerHandler('setHeightToFileUploader', Array.prototype.slice.call(arguments, 1));
						}, t)
					});

					t.SWFJSApi.MRUUploader.bind('onQueueStart onQueueFinsh onQueueChanged onFilesLinkCodeChange', $.proxy(function(evt) {
						var t = this;
						t.triggerHandler(evt.type, Array.prototype.slice.call(arguments, 1));
					}, t));

					mailru.Compose.JSSWFApi = t.JSSWFApi;

				}, t));
			},

			_flashLoad: function(o) {
				var t = this;
				setTimeout($.proxy((function(o) {
					return function() {
						var t = this;
						if (o && o.ref && o.ref.style && o.ref.style.display != 'none'){
							t.triggerHandler('flashLoad', [o.ref]);
						}
						else {
							t.triggerHandler('errorFlashLoad');
						}
					};
				})(o), t), 100);
			},

			_addDropFiles: function (filesData) {
				var t = this;
				for (var fileData, i=0, l=filesData.length; i<l; i++) {
					fileData = filesData[i];
					t._addDropFile(fileData.id, fileData.file);
				}
			},

			_addDropFile: function(fid, file) {
				var t = this;
				if (/^image\/(gif|jpeg|png)/i.test(file.type) && file.size < mailru.Compose.FileUploaderSWF.previewSizeLimit) {
					var reader = new FileReader();
					reader.onload = function(evt) {
						var img = new Image();
						img.onload = function() {
							var dataURL = null;
							try {
								dataURL = mailru.Compose.FileUploaderSWF.createPreviewDataURL(this, 100, 100);
							}
							catch (e) {}
							t.JSSWFApi.startUpload(fid, file.name, file.size, dataURL);
							t.startUpload[fid] = 1;
							if (t.completeUploadCallbacks[fid]) {
								t.completeUploadCallbacks[fid].call(t);
								delete t.completeUploadCallbacks[fid];
							}
							img = null;
						};
						img.src = evt.target.result;
					};
					reader.readAsDataURL(file);
				}
				else {
					t.JSSWFApi.startUpload(fid, file.name, file.size, null);
					t.startUpload[fid] = 1;
					if (t.completeUploadCallbacks[fid]) {
						t.completeUploadCallbacks[fid].call(t);
						delete t.completeUploadCallbacks[fid];
					}
				}
			},

			_progressUpload: function () {
			},

			_addFile: function(fid, data) {

				var t = this;
				var _callback = (function(scope, fid, data) {
					return function() {
						scope.JSSWFApi.completeUpload(fid, data.Id, data.FileName, data.Size);
					};
				})(t, fid, data);

				if (t.startUpload[fid]) {
					_callback();
					delete t.startUpload[fid];
				}
				else {
					t.completeUploadCallbacks[fid] = _callback;
				}
			},

			getUploadedAttachments: function () {
				var t = this;
				return t.JSSWFApi.getUploadedAttachments();
			},

			getFiles: function() {
				var t = this;
				var f = t.JSSWFApi.GetServerQueueItems('files', 'done');
				var m = t.JSSWFApi.GetServerQueueItems('mail', 'done');
				return f.concat(m);
			},

			init: function(settings, config) {

				var t = this;

				t.settings = settings;
				t.config = config;

//				t.flashConfig['src'] = 'http://'+ settings.ServerName +'/images/photouploader/uploader_25052011.swf?v=1';
//				t.flashConfig['src'] = 'http://e.mail.ru/images/photouploader/uploader_20110610.swf?b=1';
//				t.flashConfig['src'] = '//img.' + mailru.staticDomainName + '/r/photouploader/uploader_20110615.swf?b=1';
//				t.flashConfig['src'] = 'http://v.demidov.boom.corp.mail.ru/attachmentsuploader/uploader.swf?' + Math.random();

				if (window.IS_LOCAL) {
					t.flashConfig['src'] = 'http://v.demidov.boom.corp.mail.ru/attachmentsuploader/uploader.swf?b=' + Math.random();
				} else {
					t.flashConfig['src'] = '//img.' + mailru.staticDomainName + '/r/photouploader/uploader_228.swf?b=1';
				}

				swfobject.embedSWF(
					t.flashConfig.src,
					t.flashConfig.flashId,
					t.flashConfig.width,
					t.flashConfig.height,
					t.flashConfig.allowVersion,
					null,
					t.flashConfig.vars,
					t.flashConfig.params,
					t.flashConfig.attrs,
					$.proxy(t._flashLoad, t)
				);

				setTimeout(swfobject.callDomLoadFunctions, 0);
			},

			unactive: function() {
			},

			reset: function() {
				var t = this;
				t.$flashUploaderContainer.html('<div id="' + t.flashConfig.flashId + '">');
			},

			attachUpload: function(fid, fileData, file) {
				var t = this;
				if (fileData.Error) {
					t.triggerHandler('fileLoadError', [fileData]);
				}
				else {
					t._addFile(fid, fileData, file);
				}
			}
		});

	})(jQuery);

	(function($) {

		/**
		 * @class mailru.Compose.FileUploaderSWF.SWFJSApi
		 */
		jsClass
		.create('mailru.Compose.FileUploaderSWF.SWFJSApi')
		.extend(jQueryEvent)
		.methods({

			__construct: function(id)
			{
				var t = this, w = window;

				t.MRUUploader	= new mailru.Compose.FileUploaderSWF.SWFJSMRUUploaderApi();

				w['MRUUploader'+id]					= t.MRUUploader;
				w['GetUploadCookie'+id]				= $.proxy(t.GetUploadCookie, t);
				w['OnChangeFlashScreen'+id]			= $.proxy(t.OnChangeFlashScreen, t);
				w['setHeightToFileUploader'+id]		= $.proxy(t.setHeightToFileUploader, t);
				w['_AjaxViaAdobeFlashIsReady'+id]	= $.proxy(t._AjaxViaAdobeFlashIsReady, t);
				w['FlashLog'+id]					= $.proxy(t.FlashLog, t);
			},

			_AjaxViaAdobeFlashIsReady: function() {
				var t = this;
				t.triggerHandler('_AjaxViaAdobeFlashIsReady', arguments);
				return false;
			},

			OnChangeFlashScreen: function() {
				var t = this;
				t.triggerHandler('OnChangeFlashScreen', arguments);
			},

			setHeightToFileUploader: function() {
				var t = this;
				t.triggerHandler('setHeightToFileUploader', arguments);
			},

			GetUploadCookie: function() {
				var t = this;
				t.triggerHandler('GetUploadCookie', arguments);
				return 'Mpop=' + jsCookie.get('Mpop') + '; mrcu=' + jsCookie.get('mrcu') + ';';
			},

			FlashLog: function (log) {
				mailru.Compose.log(log);
			}
		});

	})(jQuery);

	(function($) {

		/**
		 * @class mailru.Compose.FileUploaderSWF.SWFJSMRUUploaderApi
		 */
		jsClass
		.create('mailru.Compose.FileUploaderSWF.SWFJSMRUUploaderApi')
		.extend(jQueryEvent)
		.methods({

			onQueueStart: function() {
				var t = this;
				t.triggerHandler('onQueueStart', arguments);
			},

			onQueueChanged: function() {
				var t = this;
				t.triggerHandler('onQueueChanged', arguments);
			},

			onQueueFinsh: function() {
				var t = this;
				t.triggerHandler('onQueueFinsh', arguments);
			},

			onFilesLinkCodeChange: function() {
				var t = this;
				t.triggerHandler('onFilesLinkCodeChange', arguments);
			}
		});

	})(jQuery);

	(function($) {

		/**
		 * @class mailru.Compose.FileUploaderSWF.JSSWFApi
		 */
		jsClass
		.create('mailru.Compose.FileUploaderSWF.JSSWFApi')
		.extend(jQueryEvent)
		.methods({

			__construct: function(flash) {
				var t = this;
				t.flashObj = flash;
			},

			SetFilesOnlyUpload: function(flag) {
				var t = this;
				var r = t.flashObj.SetFilesOnlyUpload(flag + 0);
				t.triggerHandler('SetFilesOnlyUpload', arguments);
				return r;
			},

			SetUploadConfig: function(serversConfig, appConfig) {
				var t = this;
				var r = t.flashObj.SetUploadConfig(serversConfig, appConfig);
				t.triggerHandler('SetUploadConfig', arguments);
				return r;
			},

			SetGroupCode: function(serverName, groupcode) {
				var t = this;
				var r = t.flashObj.SetGroupCode(serverName, groupcode);
				t.triggerHandler('SetGroupCode', arguments);
				return r;
			},

			GetServerQueueItems: function(serverName, fileState) {
				var t = this, r = [];
				try {
					r = $.parseJSON(t.flashObj.GetServerQueueItems(serverName, fileState));
				}
				catch(e){}
				t.triggerHandler('GetServerQueueItems', arguments);
				return r;
			},

			DeleteUploadItem: function(fileId) {
				var t = this;
				var r = t.flashObj.DeleteUploadItem(fileId);
				t.triggerHandler('DeleteUploadItem', arguments);
				return r;
			},

			GetServerStat: function(serverId) {
				var t = this;
				var r = t.flashObj.GetServerStat(serverId);
				t.triggerHandler('GetServerStat', arguments);
				return r;
			},

			startUpload: function(tid, name, size, base64data) {
				name = $('<div/>').html(name).text();
				var t = this;
				var r = t.flashObj.startUpload(tid, name, size, base64data);
				t.triggerHandler('startUpload', arguments);
				return r;
			},

			completeUpload: function(tid, id, name, size) {
				name = $('<div/>').html(name).text();
				var t = this;
				var r = t.flashObj.completeUpload(tid, id, name, size);
				t.triggerHandler('completeUpload', arguments);
				return r;
			},

			getUploadedAttachments: function() {
				var t = this, r = [];
				try {
					r = $.parseJSON(t.flashObj.getUploadedAttachments());
				}
				catch(e){}
				t.triggerHandler('getUploadedAttachments', arguments);
				return r;
			},

			toggleFlashLog: function(enable) {
				var t = this;
				var r = t.flashObj.toggleFlashLog(enable >>> 0);
				return r;
			},

			setLocalization: function(strings) {
				var t = this;
				var r = t.flashObj.setLocalization(strings);
				return r;
			}
		});

	})(jQuery);

	jsLoader.loaded('{mailru.compose}mailru.Compose.FileUploaderSWF', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.FileUploaderSWF.js end

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.FileUploaderHTML5.js start


// data/ru/images/js/ru/jsCore/jquery/jquery.multiple.js start

/**
 * @author	RubaXa <trash@rubaxa.org>
 */
(function (win, $, undef){
	/**
	 * @namespace   win.atob
	 * @namespace   win.document
	 * @namespace   win.FileReader
	 * @namespace   win.FormData
	 * @namespace   win.File
	 */
	var
		  document  = win.document
		, Reader	= win.FileReader
		, FormData	= win.FormData
		, flash		= null  // Flash instance
		, html5		= $.support.fileapi = (mailru.HTML5Uploader == 2) && !!(win.File && Reader) && ('withCredentials' in (new XMLHttpRequest))
		, gid		= +(new Date)  // uniq id
		, uname		= '_'+gid      // uniq name

		, _rs       = /%s/g
		, _rext		= /\.(\w+)$/i   // extension extractor
		, _rIsMime	= /.+\/.+/i    // is mime string
		, _rpngjpg  = /png|jpe?g/i

		, _mime	= {     // default extensions by mime
						  'image':	'png|jpg|jpeg|bmp|gif|ico|tif|tiff|tga|pcx|cbz|cbr'
						, 'audio':	'm4a|flac|aac|rm|mpa|wav|wma|ogg|mp3|mp2|m3u|mod|amf|dmf|dsm|far|gdm|imf|it|m15|med|okt|s3m|stm|sfx|ult|uni|xm|sid|ac3|dts|cue|aif|aiff|wpl|ape|mac|mpc|mpp|shn|wv|nsf|spc|gym|adplug|adx|dsp|adp|ymf|ast|afc|hps|xsp'
						, 'video':	'm4v|3gp|nsv|ts|ty|strm|rm|rmvb|m3u|ifo|mov|qt|divx|xvid|bivx|vob|nrg|img|iso|pva|wmv|asf|asx|ogm|m2v|avi|bin|dat|dvr-ms|mpg|mpeg|mp4|mkv|avc|vp3|svq3|nuv|viv|dv|fli|flv|wpl'
					}
		, _rmime = {}	// RegExp mime

		, _slice = [].slice
		, _proxy = $.proxy // short name for obfuscate

		, log = win.log || $.noop
	;

	// Convert mime to regexp
	$.each(_mime, function (key, val){
		_rmime[key]	= new RegExp('('+val+')\\b', 'i');
	});


	// JSONP callbacks storage
	win[uname] = {};


	// Create JSONP-callback
	function _jsonp(name, fn, context){
		win[uname]['_'+name] = context ? _proxy(fn, context) : fn;
		return 'window.'+uname+'._'+name;
	}


	// Remove JSONP-callback
	function _jsonpRemove(name){
		delete win[uname]['_'+name];
	}


	// Add event props, if they not exists
	if( $.event.props ) $.each(['loaded', 'total'], function (i, key){
		if( !~$.inArray(key, $.event.props) ){
			$.event.props.push(key);
		}
	});


	function _emit(ctx, ns, evt, fn){
		if( ns ) evt.namespace = ns;
		if( fn ) fn.call(ctx, evt);
		$(ctx).triggerHandler(evt.type+(ns ? '.'+ns : ''), [evt]);
	}


	/**
	 * @class	File
	 * @param  {File}       file    html5 file instance
	 * @param  {HTMLInput}  input   linked element
	 */
	function File(file, input){
		/** @namespace file.uid */
		this.uid	    = file.uid || ++gid; // make uniqId
		this._file	    = file;
		this._input	    = input;

		this._rotate    = 0;
		this.__rotate   = 0;

		this._minSide;    /*:undef*/
		this._maxSide;   /*:undef*/

		/** @namespace file.fileName */
		/** @namespace file.fileType */
		/** @namespace file.fileSize */
		this.name	    = String(file.fileName || file.name);
		this.type	    = String(file.fileType || file.type); // mime type
		this.size	    = ~~(file.fileSize || file.size);
		this.isFlash	= !!file.isFlash;

		// Check mime type
		if( this.name ){
			var ext = this.extension = this.name.match(_rext) && RegExp.$1; // extract file extension
			if( !_rIsMime.test(this.type) ){
				this.type = ext;

				// Define mime type by extension
				for( var type in _rmime ) if( _rmime[type].test(ext) ){
					this.type = type+'/'+ext;
					break;
				}
			}
		}
	}

	File.fn = File.prototype = {
		uid: 0,
		getId: function (){ return this.uid; },
		getBoundary: function (){ return this.uid; },
		loadAsDataURL: function (fn){ _emit(this, 'dataURL', { type: 'error' }, fn); },
		loadAsBinaryString: function (fn){ _emit(this, 'binaryString', { type: 'error' }, fn); },

		abort: $.noop,
		isImage: function (){ return _rmime.image.test(this.type); },

		hasSupportTransform: function (){
			return  _rpngjpg.test(this.type);
		},

		isNeedTransform: function (){
			if( this.hasSupportTransform() ){
				return (this._rotate !== this.__rotate) || this.isNeedResize();
			}
			return  false;
		},

		isNeedResize: function (){
			return (this._minSide && (!this.width || this._maxSide < this.width))
				|| (this._minSide && (!this.height || this._maxSide < this.height));
		},

		resize: function (min, max){
			this._minSide    = min || 0;
			this._maxSide    = max || min;
		},

		rotate: function (deg){
			this._rotate = deg;
		},

		on: function (events, fn){
			if( !fn._proxy ) fn._proxy = _proxy(function (jqEvt, evt){
				evt.namespace = jqEvt.namespace;
				fn.call(this, evt);
			}, this);
			$(this).bind(events, fn._proxy);
		},

		off: function (events, fn){
			if( fn._proxy ) $(this).unbind(events, fn._proxy);
		},

		emit: function (name, data){
			_emit(this, '', $.extend({ type: name }, data));
			return  this;
		},

		loadAsImage: function (fn){
			var cb = function (evt){
				var type = evt.type;

				if( type == 'load' ){
					$(new Image)
						[evt.cors ? 'attr' : 'removeAttr']('crossOrigin', 'use-credentials')
						.bind('error abort load', function (evt){
							$(this).unbind();
							fn({ type: evt.type, target: this });
						})
						.attr('src', this.dataURL)
					;
				} else if( type == 'abort' || type == 'error' ){
					fn({ type: type });
				}
			};

			if( $.browser.msie && parseInt($.browser.version) < 8 ){
				cb({ type: 'error' });
			}
			else if( $.support.fileapi && !(this._input && this._input.nodeType) ){
				cb.call({ dataURL: this.url }, { type: 'load', cors: true });
			}
			else {
				this.loadAsDataURL(cb);
			}
		}
	};



	function FlashAPI(){
		this.ready	= false;
		this.active	= false;
		this._flash	= 'flashapi_' + uname;

		if( this.hasFlash() ){
			this._init(0);
		} else {
			setTimeout(this._fail.bind(this), 1);
		}
	}
	FlashAPI.prototype = {

		hasFlash: function (){
			var nav	= navigator, mime = nav.mimeTypes, has = false;

			if( nav.plugins && typeof nav.plugins['Shockwave Flash'] == 'object' ){
				has	= nav.plugins['Shockwave Flash'].description && !(mime && mime['application/x-shockwave-flash'] && !mime['application/x-shockwave-flash'].enabledPlugin);
			}
			else {
				try {
					has	= !!(win.ActiveXObject && new ActiveXObject('ShockwaveFlash.ShockwaveFlash'));
				}
				catch(er){ /*__*/ }
			}

			return	has;
		},

		// @private
		_init: function (i){
			var Helper = document.getElementById('__FFA__');

			if( !Helper ){
				if( ++i < 50 ){
					setTimeout(this._init.bind(this, i), 500);
				} else {
					this._fail();
				}
				return;
			}

			var swfSrc = 'http://v.demidov.boom.corp.mail.ru/uploaderfileapi/UploaderFileAPI.swf?r='+ ajs.now();

			if( 1 || !(jsCore.local && (location.host != 'e.mail.ru')) ){
				swfSrc	= '//e.mail.ru/r/photouploader/UploaderFileAPI_236.swf?r=1';
			}

			var
				http = location.protocol,
				tplVars = {
					  id: this._flash
					, src: swfSrc
					, flashvars: ajs.toQuery({
						  ping: http +'//'+ location.host
						, storeKey: navigator.userAgent.match(/\d/g).join('')
						, clearError: +/flash_clear_error/.test(location.toString())
						, callback: _jsonp('__flash', this._event, this)
					})
				}
			;

			var tpl = ('<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="" id="#id#" width="100%" height="100%">'
					+ '<param name="movie" value="#src#" />'
					+ '<param name="flashvars" value="#flashvars#" />'
					+ '<param name="swliveconnect" value="true" />'
					+ '<param name="allowscriptaccess" value="always" />'
					+ '<param name="wmode" value="transparent" />'
					+ '<param name="menu" value="false" />'
					+ '<embed flashvars="#flashvars#" swliveconnect="true" allowscriptaccess="always" name="#id#" src="#src#"  width="100%" height="100%" menu="false" wmode="transparent" type="application/x-shockwave-flash"></embed>'
					+ '</object>').replace(/#(\w+)#/ig, function (a, name){ return tplVars[name]; })
			;

			// Publish flash
			this.$H = $(Helper).css({ position: 'absolute', zIndex: 81100, overflow: 'hidden' });

			$(win).scroll(_proxy(this._scroll, this));

			ajs.log('FileAPI.SWF.publish');
			this.$H[0].innerHTML = tpl;

			/** @namespace document.embeds */
			this._engine = document[this._flash] || window[this._flash] || document.embeds[this._flash];

			this._event({ type: 'mouseleave' });
			setTimeout(function (){ $.multiple.ready(true) }, 10000);
		},

		_fail: function (){
			if( !this.ready ){
				this._event = this._ready = ajs.F;
				$('body').addClass('fileapi-not-support');
				$.multiple.ready( true );
			}
		},

		_ready: function (){
			this._ready = ajs.F;

			var mixin = {
				loadAsDataURL: function (fn){
					ajs.log('loadAsDataURLById:', this.getId(), this.url);
					flash._cmd(!this._input.nodeType ? 'load' : 'loadAsDataURL', {
						  id: this.getId()
						, url: this.url
						, callback: _jsonp(++gid, function (evt){
							if( evt.type == 'load' ){
								if(  evt.target.type ) this.type = evt.target.type;
								this.dataURL = 'data:'+this.type+';base64,'+evt.target.result;
							}
							_emit(this, 'dataURL', evt, fn);
						}, this)
					});
				},

				upload: function (url, opts, fn){
					ajs.log('uploadById:', this.getId());


					this.__failId = setTimeout(function (){
						mailru.radar('flash_timeout', 1);
						_emit(this, 'upload', { type: 'error', error: 'timeout' });
						_emit(this, 'upload', { type: 'uploadend' });
						this.abort();
					}.bind(this), 60*1000);


					this.__rotate = this._rotate;
					this.uploading = true;
					this.on('abort.upload', fn);
					this.on('uploadend.upload', function() {
						if (this.aborted) {
							// https://jira.mail.ru/browse/MAIL-14670
							//  abort    uploadend
							fn.call(this, arguments[0]);
						}
					}.bind(this));

					flash._cmd('upload', $.extend({
						  id: this.getId()
						, url: url
						, name: this._input.name
						, data: opts.data || {}
						, headers: opts.headers || {}
						, callback: _jsonp(++gid, function (evt){
							if( evt.type == 'progress' ){
								if( this.__failId !== 0 ){
									clearTimeout(this.__failId);
									this.__failId = 0;
								}
							}
							else {
								ajs.log(evt.type, ' ', JSON.stringify(evt));
							}

							_emit(this, 'upload', evt, fn);
						}, this)
					}, opts));
				},

				abort: function (){
					flash._cmd('abort', { id: this.getId() });

					if( !this.__failId ){
						this.aborted = true;
						_emit(this, 'upload', { type: 'abort' });
						_emit(this, 'upload', { type: 'uploadend' });
					}
				},

				rotate: function (deg){
					this._rotate = deg;
					flash._cmd('rotate', { id: this.getId(), deg: deg });
				}
			};

			$.each(mixin, function (name, fn){
				var _fn = File.fn[name];
				File.fn[name] = function (){
					return (this.isFlash ? fn : _fn).apply(this, arguments);
				};
			});

			// READY
			this.ready = $.support.flash = $.support.flashUpload = true;
			$.multiple.ready( true );
		},

		_scroll: function (){
			if( !this.active ){
				this.$H.css({
					  top: $(win).scrollTop()
					, left: $(win).scrollLeft()
					, width: 2
					, height: 2
				});
			}
		},

		_cancel: function (force){
			this.$Active	= null;
			this.active		= false;
			if( force ){
				this._scroll();
			} else {
				$('body').one('mousemove', _proxy(this._scroll, this));
			}
		},

		_event: function (evt){
			var type = evt.type;

			if( type !== 'log' ){
				ajs.log('[flash] -->', type, ': ', JSON.stringify(evt));
			}

			if( type == 'ready' ){
				this._ready.gap(this, 20)();
				return	true;
			}
			else if( type == 'ping' ){
				mailru.log('flash_ping', evt, 1);
				if( evt.status == 'ok' && evt.savedStatus == 'error' ){
					mailru.radar('flash_ping', 'ok_error=1');
				}
				else if( evt.status == 'error' && evt.savedStatus == 'ok' ){
					mailru.radar('flash_ping', 'error_ok=1');
				}
				else if( evt.status == 'error' && evt.savedStatus == 'error' ){
					mailru.radar('flash_ping', 'err_error=1');
				}
				else {
					mailru.radar('flash_ping', evt.status+'=1');
				}
			}
			else if( type == 'log' ){
				ajs.log('[flash.log] -->', evt.target);
			}
			else if( type == 'mouseleave' ){
				if( this.$Active ) this.$Active.triggerHandler('mouseleave');
				this._cancel(true);
			}
			else if( type == 'select' ){
				$.each(evt.target.files, function (i,X){ X.isFlash = true; });
				this.$Active.data(uname, evt.target.files).triggerHandler('change');
				this._cancel();
			}
			else if( type == 'mouseDown' || type == 'mouseUp' ){
				this.$Active.triggerHandler(type);
			}
		},

		_cmd: function (name, data){
			if( this.ready ) try {
				this._engine.cmd(name, data);
			} catch (e){ }
		},

		// @public
		mouseOver: function (evt, $Inp){
			if( this.ready ){
				var $Elm = $(evt.currentTarget), pos = $Elm.offset();

				pos.top  -= 1;
				pos.left -= 1;

				this.$H.css(pos).css({
					  width:  $Elm.outerWidth() + 2
					, height: $Elm.outerHeight() + 2
				});

				this.active  = true;
				this.$Active = $Inp;
			}
		},

		mouseOut: function (){
			if( this.ready ){
				this._cancel(true);
			}
		},

		setAccept: function (accept){
			flash._cmd('accept', { 'All files': accept || '*' });
		},

		setResize: function (resize){
			$.each(resize, function (name, opt){
				flash._cmd('setResize', {
					  type:			name
					, enabled:		opt.enabled != false
					, strategy:		opt.type == 'min' ? 'byMinSide' : 'byMaxSide'
					, resizeSize:	opt.min
					, bigImageSize:	opt.max || 2000
				});
			});
		},

		clear: function (){
			flash._cmd('clear');
		}

	};


	$.support.canvas = !!(function(){
		var canvas = document.createElement('canvas'), support = canvas.getContext && ~canvas.toDataURL("image/png").indexOf("data:image/png");
		canvas = null;
		return support;
	})();


	if( html5 ){
	// Support HTML5
		function _canvas(width, height){
			var canvas  = document.createElement('canvas');
			if( height ){
				canvas.width    = width;
				canvas.height   = height;
			} else {
				var img = width;
				canvas.width    = img.width;
				canvas.height   = img.height;
				canvas.getContext('2d').drawImage(img, 0, 0, img.width, img.height);
			}
			return  canvas;
		}


		function _rotate(src, deg){
			var
				  canvas = _canvas((deg == 0  || deg == 180) ? src.width : src.height, (deg == 0 || deg == 180) ? src.height : src.width)
				, ctx = canvas.getContext('2d')
				, x = 0
				, y = 0
			;

			if( deg == 180 || deg == 270 )  x = -src.width;
			if( deg == 90 || deg == 180 )   y = -src.height;

			ctx.rotate(deg * Math.PI / 180);
			ctx.drawImage(src, x, y);
			ctx = null;

			return  canvas;
		}


		function _resize(src, max){
			var
				  ratio = ((src.width > max) ? max/src.width : max/src.height)
				, canvas = _canvas(src.width*ratio, src.height*ratio)
			;
			canvas.getContext('2d').drawImage(src, 0, 0, canvas.width, canvas.height);
			return  canvas;
		}


		function _readFile(file, fn, type){
			var
				  lock = type+'_lock'
				, st = type+'_status'
				, events = 'loadstart.%s error.%s abort.%s load.%s loadend.%s'.replace(_rs, type)
			;

			if( file[type] ){
				file[st]    = 'load';
				file[lock]  = true;
			}

			if( !file[lock] ){
				file[lock] = true;
				file.on(events, fn);
				file.on('loadend.'+type, function (){ this[st] = (type in this) ? 'load' : 'error'; });

				var R = new Reader();
				R.onabort = R.onerror = R.onprogress = R.onload = R.onloadstart = R.onloadend = function (evt){
					if( evt.type == 'load' ) file[type] = evt.target.result;
					_emit(file, type, evt);
				};

				R['readAs'+type.charAt(0).toUpperCase()+type.substr(1)](file._file);
				R = null;
			} else {
				fn({ type: 'loadstart', namespace: type, target: {} });
				if( file[st] ){
					fn({ type: file[st], namespace: type, target: {} });
					fn({ type: 'loadend', namespace: type, target: {} });
				} else {
					file.on(events, fn);
				}
			}
		}

		File.fn.loadAsDataURL		= function (fn){
			if( this._input.nodeType ){
				_readFile(this, fn, 'dataURL');
			} else {
				_loadFile(this, this.url, fn);
			}
		};

		File.fn.loadAsBinaryString	= function (fn){ _readFile(this, fn, 'binaryString'); };


		function _formData(useFD, file, data){
			if( useFD ){
				var form = new FormData;
				form.append(file._input.name, file._file);
				$.each(data, function (key, val){ form.append(key, val); });
				return	form;
			} else {
				/** @namespace file.binaryString */
				var uniq	= file.getBoundary();
				var bin		= file.binaryString;
				var req 	= '--'+uniq+'\r\n';

				if( data ) $.each(data, function (name, val){
					req += 'Content-Disposition: form-data; name="'+ encodeURIComponent(name) +'"\r\n'
					     + '\r\n'
					     + encodeURIComponent(val) +'\r\n'
					     + '--'+ uniq +'\r\n'
					;
				});

				req += 'Content-Disposition: form-data; name="'+ file._input.name +'"; filename="'+ encodeURIComponent(file.name) +'"\r\n'
				     + 'Content-Type: '+ (file.type || 'application/octet-stream') +'\r\n'
				     + '\r\n'
				     + bin +'\r\n'
				     + '--'+ uniq +'--'
				;

				return	req;
			}
		}

		File.fn.abort = function (){
			this.aborted = true;
			if( this._xhr ) this._xhr.abort();
		};

		File.fn.upload	= function (url, opts, fn){
			if( $.isFunction(opts) ){
				fn = opts;
				opts = {};
			}

			this.uploading = true;
			_emit(this, 'upload', { type: 'uploadstart' }, fn);

			var
			  file = this
			, _ready = function (useFD){
				if( file._input.nodeType == 1 ){
					var $Inp = $(file._input);
					$Inp.clone(true).val('').insertBefore($Inp).trigger('reinit-inp.'+uname);
					$Inp.remove();
				}

				file._xhr = $.ajax({
					url: url,
					type: 'POST',
					crossDomain: true,
					processData: false,

					data: _formData(useFD, file, opts.data),
					dataType: 'text',

					headers: opts.headers || {},
					contentType: useFD ? false : 'multipart/form-data; boundary='+ file.getBoundary(),

					xhr: function(){
						var xhr	= $.ajaxSettings.xhr();

						xhr.withCredential = "true";

						if( !useFD ){
							/** @namespace xhr.sendAsBinary */
							xhr.send = xhr.sendAsBinary || (function (_send){
								return function (str){
									var bytes = Array.prototype.map.call(str, function(c){ return c.charCodeAt(0) & 0xff; });
									_send.call(this, new Uint8Array(bytes).buffer);
								};
							})(xhr.send);
						}

						if( xhr.upload ) xhr.upload.addEventListener('progress', function (/** Event */evt){
							/** @namespace evt.lengthComputable */
							if( evt.lengthComputable ){
								_emit(file, 'upload', evt, fn);
							}
						}, false);

						return	xhr;
					},

					success: function (res){
						_emit(file, 'upload', { type: 'progress', total: file.size, loaded: file.size }, fn);
						_emit(file, 'upload', { type: 'upload', target: { result: res } }, fn);
					},

					complete: function (xhr, status){
						file.uploading = false;
						if( status != 'success' ){
							_emit(file, 'upload', {
								  "type": status != "abort" ? 'error' : "abort"
								, "ajaxStatus": status
							}, fn);
							mailru.log('html5.multiple.upload.error', { status: xhr.status, textStatus: status }, true);
						}
						_emit(file, 'upload', { type: 'uploadend' }, fn);
					}
				});
			}; // ready


			if( FormData && !file.isNeedTransform() ){
				_ready(true);
			}
			else {
				file[file.isNeedTransform() ? 'loadAsDataURL' : 'loadAsBinaryString'](function (evt){
					var type = evt.type;

					if( file.aborted ){
						return;
					}
					else if( type == 'abort' || type == 'error' ){
						_emit(file, 'upload', evt, fn);
						_emit(file, 'upload', { type: 'uploadend' }, fn);
					}
					else if( type == 'load' ){
						if( file.isNeedTransform() ){
							$(new Image)
								.attr('src', file.dataURL)
								.bind('load error', function (evt){
									$(this).unbind();

									if( evt.type == 'error' ){
										_emit(file, 'upload', { type: 'error' }, fn);
										_emit(file, 'upload', { type: 'uploadend' }, fn);
									} else {
										var img     = _canvas(evt.target);
										file.width  = img.width;
										file.height = img.height;

										if( file.isNeedTransform() ){
											if( file.isNeedResize() ) img = _resize(img, file._minSide);
											if( file._rotate )  img = _rotate(img, file._rotate);
											file.__rotate = file._rotate;
										}

										var mime = ~file.type.indexOf('png') ? 'image/png' : 'image/jpeg';
										file.binaryString = win.atob(img.toDataURL(mime).substr(13 + mime.length));

										_ready();
									}
								})
							;
						} else {
							_ready();
						}
					}
				});
			}
		};
	}


	// html5 not supported
	if( !html5 ){
		// Build flash transport
		flash	= new FlashAPI();

		File.fn.upload = function (url, opts, fn){
			if( $.isFunction(opts) ){
				fn = opts;
				opts = {};
			}

			if( !fn ) fn = $.noop;
			_emit(this, 'upload', { type: 'uploadstart' }, fn);


			var
				  fid = this.getId()
				, jsonp = _jsonp(fid, function (result){
								_emit(this, 'upload', { type: 'progress', loaded: 1, total: 1 }, fn);
								_emit(this, 'upload', { type: 'upload', target: { result: result } }, fn);
								_emit(this, 'upload', { type: 'uploadend' }, fn);

								_clear();
								_jsonpRemove(fid);
							}, this)
				, $Inp = $(this._input)
				, $Form = $($Inp[0].form)
				, $Transport = $('<div></div>')
									.css({ position: 'absolute', top: -1000, width: 1, height: 1, overflow: 'hidden', visibility: 'hidden' })
									.insertAfter($Form)
			;

			$Transport[0].innerHTML = '<form target="'+ fid +'" action="'+ url +'" method="POST" enctype="multipart/form-data">'
									+ '<iframe name="'+fid +'" src="about:blank"></iframe>'
									+ '<input value="'+ jsonp.replace('window.', '') +'" name="callback" type="hidden" />'
									+ '</form>'
			;

			$.each(opts.data, function (key, val){
				$Transport.find('form').append('<input value="'+val+'" name="'+key+'" type="hidden" />');
			});

			this.uploading = true;

			$Inp.clone(true).val('').insertBefore($Inp).trigger('reinit-inp.'+uname);
			$Transport.find('form').append($Inp)[0].submit();

			this.abort = function (){
				this.aborted = true;

				_emit(this, 'upload', { type: 'abort' }, fn);
				_emit(this, 'upload', { type: 'uploadend' }, fn);

				try {
					var win	= $Transport[0].contentWindow;
					if( win ){
						if( win.stop ) win.stop();
						else if( win.document ) win.document.execCommand('Stop');
					}
				}
				catch(_){}

				_clear()
			};

			function _clear(){
				$Transport.remove();
				$Transport = null;
			}
		};
	}




	function Multiple(elm, opts){
		this.$Elm	= elm = $(elm).bind('mouseenter mousedown', _proxy(this, '_event'));
		this.$Inp	= ($.nodeName(elm[0], 'input') ? elm : elm.find('input:file'))
						.val('')
						.attr('multiple', html5)
						.bind('change reinit-inp.'+uname, _proxy(this, '_event'))
					;
		this.opts	= opts = $.extend({
						  url:		0
						, max:		0
						, resize:   { upload: { enabled: false }, preview: { enabled: false } }
						, types:	{ 'All files': '*.*' }
						, accept:	0
						, onselect:	$.noop
					}, opts);

		if( opts.accept ){
			this.$Inp.attr('accept', opts.accept);
		}
	}
	Multiple.prototype = {

		_event: function (evt){
			var opts = this.opts, type = evt.type;

			log('js -> ', evt.type, evt.pageX, evt.pageY);

			if( type == 'change' ){
				var files = this.files();

				if( opts.max ){
					files = _slice.call(files, 0, opts.max);
				}

				if( files.length ){
					opts.onselect.call(this, files);
				}
			}
			else if( type == 'reinit-inp' ) {
				var $inp = $(evt.currentTarget);
				if( $.nodeName(this.$Elm[0], 'input' ) ) this.$Elm = $inp;
				this.$Inp = $inp;
			}
			else if( (flash !== null) && (type == 'mouseenter' || type == 'mousedown') ){
				flash.setResize(this.opts.resize);
				flash.setAccept(this.getAccept());
				flash.mouseOver(evt, this.$Inp);
			}
		},


		// @public
		newFile: function (file, inp){
			flash && flash.setResize(this.opts.resize);
			file = new File(file, inp);
			return	file;
		},

		clear: function (){
			flash && flash.clear();
		},

		mouseout: function (){
			flash && flash.mouseOut();
		},

		resize: function (opt){
			$.extend(this.opts.resize, opt);
			flash && flash.setResize(this.opts.resize);
		},

		getAccept: function (){
			if( this.opts.accept ){
				var accept = [], x = this.opts.accept;

				$.each(typeof x == 'string' ? x.split(/,\s*/g) : x, function (t, val){
					accept.push(_mime[val] ? _mime[val] : val.split('/')[1]);
				});

				return	accept.join(',');
			}
		},

		files: function (fileList){
			var
				  $Inp  = this.$Inp
				, files = (fileList || $Inp.data(uname) || $Inp[0].files)
				, accept = this.getAccept()
				, opts = this.opts
			;

			if( !(files && files.length) && $.trim($Inp.val()) ){
				files = [{ name: $Inp.val().split('/').shift() }];
			}

			files = $(files).map(function (){
				var file = new File(this, $Inp[0]);
				if( opts.resize && opts.resize.upload && opts.resize.upload.enabled ){
					file.resize(opts.resize.upload.min, opts.resize.upload.max);
				}
				return file;
			});

			if( accept ){
				accept = new RegExp('('+accept+')', 'i');
				files  = files.filter(function (i, file){
					return accept.test(file.type);
				});
			}

			return	files.toArray();
		},


		select: function (files){
			this.opts.onselect.call(this, this.files(files));
		}

	};



	// jQuery plugin
	$.fn.multiple = function (key){
		var ret, args = arguments;

		this.each(function (){
			var $this = $(this);
			if( ret = $this.data('multiple.inst') ){
				if( $.isFunction(ret[key]) ){
					ret	= ret[key].apply(ret, $.makeArray(args).slice(1));
				}
			}
			else {
				$this.data('multiple.inst', new Multiple($this, key));
			}
		});

		return	ret === undef ? this : ret;
	};


	$.multiple = {
		_fn: [],

		isImage: function (file){
			return  file.isImage ? file.isImage() : _rmime.image(file.name.match(_rext) && RegExp.$1);
		},

		file: function (data, input){
			return  new File(data, input);
		},

		ready: function (fn){
			if( fn === true ){
				this.ready = function (x){ $.isFunction(x) && x(); };
				while( this._fn.length ) this._fn.shift()();
			} else {
				this._fn.push(fn);
			}
		}
	};


	if( html5 ){
		// ready HTML5
		$.multiple.ready( true );
	}

	$.multiple.File = File;

	function _loadFile(file, url, fn){
		var xhr = $.ajaxSettings.xhr();
		if( xhr ){
			xhr.open('GET', url, true);

			if( xhr.overrideMimeType ){
		        xhr.overrideMimeType('text/plain; charset=x-user-defined');
			}

			xhr.onreadystatechange = function(){
				if( xhr.readyState == 4 ){
					xhr.onreadystatechange = null;
					if( xhr.status == 200 ){
						url = url.split('/');
						/** @namespace xhr.responseBody */
						$.extend(file, {
						      name: url[url.length-1]
							, size: xhr.getResponseHeader('Content-Length')
							, type: xhr.getResponseHeader('Content-Type')
						});
						file.dataURL = 'data:'+file.type+';base64,' + encode64(xhr.responseBody || xhr.responseText);
						fn({ type: 'load', result: file });
					}
					else {
						fn({ type: 'error' });
					}
			    }
			};
		    xhr.send(null);
		} else {
			fn({ type: 'error' });
		}

		return  xhr;
	}


	function encode64(str){
		var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=', outStr = '', i = 0;

		while( i < str.length ){
			//all three "& 0xff" added below are there to fix a known bug
			//with bytes returned by xhr.responseText
			var
				  byte1 = str.charCodeAt(i++) & 0xff
				, byte2 = str.charCodeAt(i++) & 0xff
				, byte3 = str.charCodeAt(i++) & 0xff
				, enc1 = byte1 >> 2
				, enc2 = ((byte1 & 3) << 4) | (byte2 >> 4)
				, enc3, enc4
			;

			if( isNaN(byte2) ){
				enc3 = enc4 = 64;
			} else {
				enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
				enc4 = isNaN(byte3) ? 64 : byte3 & 63;
			}

			outStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
		}

		return  outStr;
	}


	jsLoader.loaded('{jQuery}jquery.multiple', 1);
})(window, jQuery);

// data/ru/images/js/ru/jsCore/jquery/jquery.multiple.js end

(function (){
		function _getFilesHost() {
			return (location.protocol == 'https:' ? 'ssl.': '') +  (mailru.UploadFilesMultiGroup? 'files.my.com' : 'files.mail.ru')
		}

		var
			  _rext = /\.(\w+)$/i
			, _rimg	= /gif|jpg|jpeg|bmp|png/i
			, _rmime = /(image|video|audio)\//i
			, _IERotate = { '0': 0, '90': 1, '180': 2, '270': 3 }
			, _isWinDev = /win\d*.dev/.test(location.host)
		;

		/**
		 * @class	mailru.Compose.FileUploaderHTML5
		 */
		ajs.createClass('mailru.Compose.FileUploaderHTML5', [jQueryEvent], {

			__construct: function (form, options){
				/** @namespace mailru.UploadFilesMultiGroup -- MAIL-11655:   files_id */
				this.useUniqFilesId = mailru.UploadFilesMultiGroup;
				this._filesHost = _getFilesHost();

				this.opts	= options;
				this.$Form	= $(form);

				var adaptive = this.adaptive();
				mailru.radar('picadapt', (adaptive ? 'on' : 'off')+'=1');

				this.$Inp	= $('.js-input-file', form).multiple({
								  resize: {
									  preview:  { min: 100, type: 'min' }
									, upload:   { min: 800, max: 1280, type: 'min', enabled: adaptive }
								  }
								, onselect: this._onSelect.bind(this)
							});
				this.List	= new mailru.Compose.FileUploaderView($('.js-attachments', form), this);
				this._uploading = false;

				this.List.bind('remove rotate', this._fileEvent.bind(this));

				this.reset();
				this.restore();

				// https://jira.mail.ru/browse/MAIL-11408
				if( $.browser.iOS && !$.support.fileapi ){
					this.$Inp.bind('touchstart', function (){
						var $notify = this.$Form.find('.js-ios-fileapi-not-support');
						if( $notify[0] ){
							$notify.show();
							this.$Inp.parent().hide();
							return	false;
						}
					}.bind(this));
				}

				$(window).bind('changeFieldVisible.compose', function (){
					try {
						var Form = mailru.Compose.Form.getActive(), cnt = Form.getActive().$form.find('.js-file').length;
						if( cnt != Form.getFileUploader().getUploadedAttachments() ){
							mailru.radar('uploader', 'viewFail='+cnt);
						}
					} catch( er ){}
				}.gap(2000));
			},

			_fileEvent: function (evt, uid){
				var type = evt.type, file = this.getByUid(uid);

				this.List.hold(uid, true);

				/** @namespace file._rotate */
				if( type == 'remove' || (type == 'rotate' && file.isNeedTransform()) ){
					mailru.log('html5._fileEvent.'+type, evt, 1);

					this._removeFile(file, function (R){
						this.List.hold(uid, false);

						if( R[1] == 'OK' ){
							this._count--;

							if( !file.aborted ){
								this._spaceLeft = R[5] - mailru.Compose.Form.getActive().attachFromFileSearchSize; //   , ..      .
								this._loaded--;
							}

							this.trigger('onQueueChanged', [this._loaded]);

							if( type == 'rotate' ){
								this._uploadFile(file);
							}
							else {
								this._removeItem(file);
								mailru.radar('uploader', 'removeOk=1');
							}
						} else {
							this._error('remove', file);
						}
					}.bind(this));
				}
				else {
					mailru.log('html5._fileEvent.'+type+'.warn', evt, 1);
				}
			},

			_removeItem: function (file){
				this.List.remove(file);

				this._queue 	= ajs.remove(this._queue, file, true);
				this._files 	= ajs.remove(this._files, file, true);
				this._uploading	= this._uploading && !!this._queue.length;

				if( !ajs.filter(this._files, function (file){ return file.isFiles; }).length ){
					this.opts.files_id = '';
					this.triggerHandler('onFilesLinkCodeChange', '');
				}

				this._uploadNext();
			},

			_removeFile: function (file, fn){
				mailru.log('html5._removeFile', file, 1);
				mailru.radar('uploader', 'remove=1');

				if( file ){
					if( !file.data || file.onlyPartId ){
						file.abort();
						fn(['','OK'], file);
						mailru.log('html5._removeFile.abort', file, 1);
					}
					else {
						var url = '/cgi-bin/attach_upload2?ajax_call=1&func_name=cbHardDeleteFile&data=["'+file.data.Id+'","message='+this.opts.MessageId+'"]';

						if( file.isFiles ){
							url = '//'+this._filesHost+'/cgi-bin/files/fajaxcall?ajax_call=1&func_name=cbHardDeleteFileMail&data=["'+file.data.Id+'","'+file.uid+'"]';
						}

						$.ajax({
							  url: url
							, type: 'POST'
							, xhrFields: { withCredentials: true }
							, dataType: 'json'
							, success: function (R){
									if( file.isFiles && (R[1] == 'OK' && R[2] == 1) ) R[2] = R.slice(2);
									else if( !(R[1] == 'OK' && R[2] == 'DELETED') )  R[1] = 'ERROR';
									if( R[1] == 'OK' ) file.data = null;
									fn(R, file);
									mailru.log('html5._removeFile.success', { file: file, result: R }, 1);
								}.bind(this)
							, error: function (){
								fn(['','ERROR'], file);
								mailru.log('html5._removeFile.error', file, 1);
							}.bind(this)
						});
					}
				}
				else {
					// @todo: log this situation
				}
			},

			_onSelect: function (files){
				var limit = this.opts.MaxAttachments - this._count;

				mailru.radar('uploader', { select: files.length });

				if( limit > 0 ){
					if( files.length > limit ){
						this._notify('upload.over', ajs.plural(this.opts.MaxAttachments, 'files.plural', ' '), ajs.plural(files.length - limit, 'files.plural', ' '));
					}

					files = files.slice(0, limit);

					files.sort(_sortByFileSize);
					files.sort(_sortByFileType);

					this._count += files.length;
					this._queue  = this._queue.concat(files);
					this._files  = this._files.concat(files);

					mailru.log('html5.onSelect', files.length);

					ajs.each(files, function (file){
						var
							  size      = file.size
							, useFiles  = (size > this._spaceLeft) || (size >= this.opts.MaxAttachmentSize)
						;

						file.isFiles    = useFiles;
						this.List.add(file, true);

						if( !useFiles ) this._spaceLeft -= size;
					}, this);
				}
				else {
					mailru.radar('uploader', 'selectErr=' + Math.abs(limit));
					this._notify('upload.limit', ajs.plural(this.opts.MaxAttachments, 'files.plural', ' '));
				}

				this._uploadNext();
			},

			_uploadNext: function (){
				if( !this._uploading && this._queue.length > 0 ){
					if( !this._onQueueStart ){
						this._onQueueStart = true;
						this.trigger('onQueueStart');
					}

					this._uploading = true;

					var file = this._queue.shift();

					mailru.log('html5._uploadNext', file.name, 1);

					if( ($.support.flashUpload || $.support.fileapi) && store.get('upload.adaptive') == null && file.isImage() ){
						this.List.getLayer(function (data){
							this.adaptive(data && data.state == 1, true);
							this._uploadFile(file);
						}.bind(this));
					} else {
						this._uploadFile(file);
					}
				}
				else if( !this.isLoading() ){
					this._onQueueStart = false;
					this.trigger('onQueueFinsh');
				}
			},

			_uploadFile: function (file, useFiles){
				if( useFiles == undef ) useFiles = !!file.isFiles;

				this._chooseStorage(useFiles, file, function (url){
					var opts = {
						data: {
							  swf: 1
							, fuid: file.uid
							, url_charset: 'utf-8'
							, FileName: file.name
							, message: file.MessageId || this.opts.MessageId
						    , groupcode: this.useUniqFilesId ? '' : this.opts.files_id
						    , upmode: 'contextflash'
						    , upload: 1
							, sourcehost: 'e.mail.ru'
							, hidelinkcode: 1
						},
						headers: {}
					};

					if( file.isFlash && useFiles ){
						opts.headers['Session-ID'] = ajs.uuid();
						opts.headers['Content-Type'] = 'application/octet-stream';
//						if( file.isNeedTransform() ){
							opts.headers['Content-Disposition'] = 'attachment; filename="'+ encodeURIComponent(file.name) +'"';
//						}
					}

					if( file.iframe ){
						// iframe transport
						file._input.name = 'File';
						ajs.extend(opts.data, mailru.tokens.sentmsg);
					}
					else if( useFiles ){
						// files@mail.ru
						opts.headers['X-Cookie'] = _getCookies();
					}

					if( file.isFlash ){
						opts.data.cookies = _getCookies();
					}


					mailru.log('html5._uploadFile', { url: url, file: file.name }, 1);


					/** @namespace file.upload */
					file.uploading = true;
					file.upload(url, opts, function (evt){
						var type = evt.type, R;

						if( type != 'progress' ){
							mailru.log('html5._uploadFile.'+type, { url: url, event: evt }, 1);
						}

						switch( type ){
							case 'upload':
									R = evt.target.result;

									if( file.iframe ){
										R = R.slice(1);
										file.name = R[2].FileName;
										file.size = ~~R[2].Size;
										this.List.add(file, false, true);
									}
									else if( useFiles ){
										/** @namespace R.vfileid */
										/** @namespace R.linkcode */
										/** @namespace R.ulinkcode */
										R = ajs.toObject(R);

										if( this.useUniqFilesId ){
											this.triggerHandler('onFilesLinkCodeAdded', R.ulinkcode || R.linkcode);
										} else {
											this.opts.files_id = this.opts.files_id || R.ulinkcode || R.linkcode;
											this.triggerHandler('onFilesLinkCodeChange', this.opts.files_id);
										}

										R = ['OK', 'UPLOADED', { Id: R.vfileid, files: true }];
									}
									else {
										try{ R = $.parseJSON(R).slice(1); } catch (_){ R = ['','ERROR']; }
									}

									file.data = R[2] || {};
									file.uploading = false;

									if( (R[1] == 'UPLOADED') && R[2] && !R[2].Error ){
										file.loaded     = true;
										this._spaceLeft = file.data.SpaceLeft - mailru.Compose.Form.getActive().attachFromFileSearchSize || this._spaceLeft;

										this.trigger('onQueueChanged', [++this._loaded]);
										mailru.radar('attached', 'ok=1');
									} else if(R[2] && R[2].Error == 'EX_FILEEMPTY') { // MAIL-11795
										file.error = true;
										this._error('fileempty', file, R);
									} else {
										file.error = true;
										this._error('upload', file, R);
									}
								break;

							case 'error':
									file.error = true;
									this._error('upload', file);
								break;

							case 'uploadend':
									this._uploading = false;
								break;
						}

						if( file.error ){
							this._removeItem(file);
						}

						if( type !== 'progress' ){
							this._uploadNext();
						}
					}.bind(this));
				}.bind(this));
			},

			_chooseStorage: function (useFiles, file, fn){
				mailru.log('html5._chooseStorage', file.name, 1);

				if( !$.support.fileapi && !file.isFlash ){
					file.iframe = true;
					fn('/cgi-bin/sentmsg?ajax_upload=1&compose_name='+ this.opts.name +'&rnd='+ ajs.now());
				}
				else if( useFiles ){
					$.ajax({
						  url: '//'+this._filesHost+'/cgi-bin/files/fajaxcall?func_name=cbChooseStorage&ajax_call=1&data=["'+file.size+'"]'
						, type: 'GET'
						, dataType: 'json'
						, crossDomain: true
						, timeout: 5000
						, success: function (R){
									var url = this._filesUrl, data = R[2];
									if( R[1].toUpperCase() == 'OK' && data && /http(s?):\/\/\w+/i.test(data.host) ){
										url	= data.host + data.url;
									}
									url += (~url.indexOf('?') ? '&' : '?') +'&rnd='+ ajs.now();
									fn(url);
								}.bind(this)
						, error: function (xhr, textStatus){
							fn(this._filesUrl);
							mailru.log('html5._chooseStorage.error', { xhrStatus: xhr.status, textStatus: textStatus }, 1)
						}.bind(this)
					});
				}
				else {
					fn('/cgi-bin/attach_upload2?ajax_call=1&rnd='+ ajs.now());
				}
			},


			/**
			 * @param   {String}    type
			 * @param   {File}      file
			 * @param   {mailru.Ajax.Result}    [Res]
			 */
			_error: function (type, file, Res){
				mailru.radar('uploader', type+'Err=1');

				mailru.log('html5._error.'+type, { file: file.name, result: Res }, 1);

				switch( type ){
					case 'upload':
					case 'fileempty':
							this._notify(type == 'fileempty' ? 'upload.error.fileempty' : 'upload.error.upload', file.name);
							this.List.remove(file);
						break;

					case 'files':
							this._notify('upload.error.files', file.name);
						break;

					case 'remove':
							this._notify('upload.error.remove', file.name);
						break;
				}
			},

			_notify: function (txt, a){
				arguments[0] = Lang.get(txt);
				alert(String.sprintf.apply(ajs, arguments));
			},


		// @public
			getByUid: function (uid){
				for( var i = 0, n = this._files.length; i < n; i++ ){
					if( this._files[i].uid == uid ){
						return  this._files[i];
					}
				}
			},

			redraw: function (options, config){
				this.opts 			= options;
				this.opts.files_id	= ajs.filter(config.UploadConfig, function (x){ return x.name == 'files'; })[0].GroupCode;
				this._spaceLeft		= this.opts.LeftMailSize;
				this._restoreUrl	= this.opts.files_id;
				this.restore();
			},

			restore: function (files){
				$.multiple.ready(function (){
					if( this._restoreUrl ){
						var files_id = this._restoreUrl;
						delete this._restoreUrl;

						Array.forEach(files_id.split(','), function (id){
							$.ajax({
								  url: '//'+this._filesHost+'/'+ id +'?json=1&uploader=1'
								, type: 'GET'
								, dataType: 'json'
								, crossDomain: true
								, success: function (R){
									/** @namespace R.file_list */
									this.restore(R.file_list);
								}.bind(this)
							});
						}, this);
					}


					files = ajs.map((files || []).concat(this.opts.mailRestoreList || []), function (file){
						/** @namespace file.dlink */
						/** @namespace file.is_previewable */
						var name = defined(file.filename, '')+'';

						return {
							  uid:      file.fileid
							, name:     name
							, size:     ~~file.filesize
							, isRFC822: ~~file.isRFC822
							, partId:   file.partid
							, isFiles:	!!file.dlink

							, hasPreview:   file.is_previewable || _rimg.test(name.match(_rext))
							, previewSrc:   file.is_previewable && file.static ? file.static : 0
						};
					}, this);

					delete this.opts.mailRestoreList;
					this.attach(files);
				}.bind(this));
			},

			active: $.noop,

			unactive: function (){
				this.reset();
				this.$Inp.multiple('mouseout').multiple('clear');
			},

			reset: function (){
				this._filesUrl	= '//'+this._filesHost+'/upload_ext/'; // default upload url
				this._restoreUrl= this.opts.files_id;
				this._spaceLeft	= this.opts.LeftMailSize;
				this._count		= 0;    // count attachment files
				this._loaded    = 0;    // count loaded
				this._queue		= [];   // queue files
				this._files     = [];   // all files

				this._uploading		=
				this._onQueueStart	= false;

				this.List.clear();
			},

			isLoading: function (){
				return  ajs.filter(this._files, function (file){ return !(file.loaded || file.error) }).length > 0;
			},

			getUploadedAttachments: function (){
				var files = ajs.filter(this._files, function (file){ return file.loaded });
				return  ajs.map(files, function (file){
					return {
						  fileid:   file.data.Id
						, fuid:     file.uid
						, filename: file.name
					};
				});
			},

			getUploaderSize: function (){
				var size = 0;
				ajs.each(this._files, function (file){
					size += file.loaded ? file.size : 0;
				});
				return	size;
			},

			getFilesCount: function() {
				return this.List? this.List._count : this._count;
			},

			attach: function (files){
				var size = 0, addFiles = [];

				ajs.each([].concat(files), function (data){
					var file = this.$Inp.multiple('newFile', data, { name: 'Filedata' });

					file.data	= { Id: data.uid };
					file.loaded	= true;
					file.PartId = data.partId;
					file.isFiles = data.isFiles;
					file.previewSrc = data.previewSrc;
					file.hasPreview = data.hasPreview;
					file.onlyPartId = data.onlyPartId;

					file.MessageId		= this.opts.MessageId;
					file.notTransform	= true;

					this._count++;
					this._loaded++;
					this._files.push(file);
					this.List.add(file, false, true);

					addFiles.push(file);

				}, this);

				this._spaceLeft	= Math.max(this._spaceLeft - size, 0);

				this.triggerHandler('attachFiles', [addFiles]);
			},


			adaptive: function (state, remember){
				if( this._adaptive == null ){
					try {
						this._adaptive	= store.get('upload.adaptive') == 1;
					} catch (e) {}
				}

				if( state != null ){
					if( remember ){
						store.set('upload.adaptive', +state);
					}

					this._adaptive	= state;
					this.$Inp.multiple('resize', {
						upload: { min: 800, max: 1280, type: 'min', enabled: state }
					});

					mailru.log('html5.images.adaptive', state);
					mailru.radar('picadapt', 'change=1');
				}

				return	this._adaptive;
			}

		});


		/**
		 * @class   mailru.Compose.FileUploaderView
		 */
		ajs.createClass('mailru.Compose.FileUploaderView', [jQueryEvent], {

			__construct: function ($V, model){
				this.$View		= $V = $($V).delegate('i', 'click', this._onClick.bind(this));
				this.$hr		= $('.js-hr', $V).display(0);
				this.$Files		= $('.js-files', $V).display(0);
				this.$Images	= $('.js-images', $V).display(0);

				this._model     = function (){ return model; };
				this._size		= 0;/*:Int*/
				this._count		= 0;/*:Int*/
				this._files		= 0;/*:Int*/
				this._images	= 0;/*:Int*/

				this._redraw	= this._redraw.bind(this);
				this._adaptive();
			},


			_adaptive: function (){
				var state	= this._model().adaptive();

				this.$View
					.find('.js-adapted-on')
						.display(state)
						.end()
					.find('.js-adapted-off')
						.display(!state)
				;
			},


			_onClick: function (evt){
				var
					  node = evt.target
					, act = node.getAttribute('data-act')
					, id = $(node).closest('.js-file').attr('id')
					, file = this.getModel().getByUid(id)
				;

				if( act ){
					mailru.radar('uploader', 'act'+act+'=1');

					if( act == 'rotate' ){
						file.rotate(_rotate(id, node.getAttribute('data-rotate') == 'cw' ? 1 : -1));
						ajs.clearSleep(file._rpid);
						file._rpid = ajs.sleep(this.trigger.bind(this, act, id), 1000);
					}
					else if( act == 'adapted' ){
						this.getLayer(function (data){
							if( data ){
								/** @namespace data.state */
								/** @namespace data.remember */
								this._model().adaptive(data.state == 1, data.remember);
								this._adaptive();
								this.trigger(act);
							}
						}.bind(this));
					}
					else {
						this.trigger(act, [id]);
					}

					evt.preventDefault();
				}
			},

			getLayer: function (fn){
				var self = this;
				$R('{plugins}' + 'Layer', function () {
					Layer.get('uploadAdaptedPhotos', function (layer) {
						layer.$div
							.find('.js-adapted-'+(self._model().adaptive() ? 'on' : 'off'))
								.attr('checked', true)
						;

						layer.func = function (state){
							fn(state ? this.$div.toObject() : null);
						};

						layer.show();
					});
				});
			},

			_upload: function (id, evt){
				var type = evt.type, $File = $('#'+id);

				if( type != 'progress' ){
					mailru.radar('uploader', type+'=1');
				}

				if( $File[0] ) switch( type ){
					case 'uploadend':
							$File.addClass('upload__file_loaded'+($File.data('error') ? '-error' : ''));
							$('.js-ok', $File).display(1);
							$('.js-del', $File).display(1);
					case 'uploadstart':
							var end = type == 'uploadend';
							$('.js-hide', $File).display(end);
							$('.js-bar', $File)[end ? 'F' : 'css']('width', 0);
							$('.js-progress', $File).display(!end);
						break;

					case 'abort':
					case 'error':
							$File.data('error', true);
						break;

					case 'progress':
							if( !$File.data('progress') ){
								$('.js-loader', $File).display(0);
							}

							if( isNaN(evt.total) )  evt.total = 1;
							if( isNaN(evt.loaded) ) evt.loaded = 0;

							var w = Math.round(evt.loaded/evt.total*100);
							w = Math.round(w/5)*5;

							if( w != $File.data('progress') ){
								$('.js-bar', $File.data('progress', w)).dequeue().animate({ width: w + '%' }, 'slow');
							}
						break;
				}
			},


			_redraw: function (){
				var files = (this._count - this._images) + this._files;

				this.$View.display(this._count);
				this.$hr.display(files && this._images);
				this.$Files.display(files);
				this.$Images.display(this._images);

				$('.upload__file_file', this.$Files).width( Math.max(this.$Files.width() / 3 - 5, 180) );
				$('.js-all-size', this.$View).html(String.sizeFormat(this._size));
				$('.js-all-count', this.$View).html(String.num(this._count, Lang.get('files.plural'), ' '));
				$('.js-files-mailru', this.$View).display(this._files);
				$('.js-adapted-info', this.$View).display(this._images);
			},


		// @public
			getModel: function (){
				return  this._model();
			},

			add: function (file, await, force){
				var
					  fileId    = file.uid
					, isImg     = !file._imgError && ($.support.fileapi || file.isFlash || file.hasPreview) && file.isImage()
					, isFiles   = file.isFiles
					, exists    = document.getElementById(fileId)
					, ext		= String(file.name).match(_rext) && RegExp.$1.toLowerCase()
				;

				if( isImg && !($.support.fileapi || $.support.flashUpload) ){
					isImg = false;
				}


				if( !force && exists ){
					this._redraw();
					return;
				}


				// images section in view
				file._img	= isImg = isImg && _rimg.test(ext);


				if( !this._count ){
					$(window).bind('resize', this._redraw);
				}

				if( !exists ){
					this._count++;
					this._size += file.size;

					if( isImg )     this._images++;
					if( isFiles )   this._files++;
				}

				// Build html item
				var $file = $($.tpl('#compose__attach_ejs', {
					  id:		fileId
					, ext:		String(file.type).match(_rmime) && RegExp.$1 || ext
					, name:		file.name
					, size:		file.size ? String.sizeFormat(file.size) : ''
					, nameHTML:	replaceEntity(file.name)
					, isImg:	isImg
					, isFiles:  isFiles
					, hasTrans: file.hasSupportTransform() && !file.notTransform
					, await:    !!await
					, loaded:	file.loaded
				}));


				if( force && exists ){
					$file.replaceAll('#'+fileId);
				}
				else {
					$file.appendTo(this[isImg ? '$Images' : '$Files']).fadeIn('slow');
				}

				if( isImg ){
					// Build image preview
					file.url = file.previewSrc || (location.protocol + (_isWinDev ? '//ima64.dev' : '//apf') + '.' + mailru.SingleDomainName + '/cgi-bin/readmsg/'+ encodeURIComponent(file.name) +'?id='+ file.PartId +'&exif=1&mode=attachment');
					if( !$.support.fileapi && $.support.flashUpload ) file.isFlash = true;

					file.loadAsImage(function (evt){
						if( evt.type == 'load' ){
							var src = $.support.fileapi && _preview(evt.target, 100, 100);

							if( src ){
								$(new Image)
									.attr('src', src)
									.addClass('js-img')
									.replaceAll('#'+fileId+' .js-img')
								;
							} else {
								$(evt.target)
									.addClass('js-img')
									.replaceAll('#'+fileId+' .js-img')
								;
							}

							if( file.loaded ){
								$('#'+fileId).addClass('upload__file_loaded');
							}
						}
						else if( evt.type == 'error' ){
							file._imgError = true;

							mailru.log('html5.loadAsImage.error', { url: file.name, event: evt }, 1);

							this.remove(file);
							this.add(file, false, true);
						}
					}.bind(this));
				}

				// Bind on upload events
				file.on('uploadstart.upload upload.upload error.upload abort.upload progress.upload uploadend.upload', this._upload.bind(this, fileId));

				// redraw
				this._redraw();
			},

			remove: function (file){
				var $file = $('#'+file.uid).unbind().stop().remove();

				if( $file.size() ){
					this._size -= file.size;
					this._count--;

					if( file._img )		this._images--;
					if( file.isFiles )	this._files--;

					this._redraw();
				}

				if( !this._count ){
					$(window).unbind('resize', this._redraw);
				}
			},

			hold: function (id, s){
				s = s === undef || s;
				$('#'+id)
					.animate({ opacity: s ? .5 : 1 }, 'fast')
					[s ? 'bind' : 'unbind']('mousedown mouseup click', false)
				;
			},

			clear: function (){
				if( this._count ){
					this.$Files.empty();
					this.$Images.empty();

					this._size  = 0;
					this._count = 0;
					this._files = 0;
					this._images= 0;

					this._redraw();
				}
			}

		});



		/**
		 * Create preview
		 *
		 * @param	{Image}		img
		 * @param	{Number}	width
		 * @param	{Number}	height
		 * @return	{DataURL}
		 */
		function _preview(img, width, height){
			try {
				var
					  ratio		= Math.max(width / img.width, height / img.height)
					, newWidth	= img.width * ratio
					, newHeight	= img.height * ratio

					, canvas	= document.createElement('canvas')
					, ctx		= canvas.getContext('2d')
				;

				canvas.width    = width;
				canvas.height   = height;

				ctx.fillStyle = 'rgb(255,255,255)';
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.drawImage(img, 0, 0, img.width, img.height, (width - newWidth)/2, (height - newHeight)/2, newWidth, newHeight);
				ctx = null;

				return	canvas.toDataURL('image/png');
			}
			catch( e ){
				ajs.log('preview.error:', e);
				mailru.radar('uploader', 'errcanvas=1');
			}
		}


		function _rotate(id, v){
			var $Img = $('#'+id+ ' .js-img'), deg;

			$Img[0]._deg = deg = (v * 90 + ($Img[0]._deg|0));

			v = v * 90 + ($Img[0].rotate|0);
			if( v < 0 ) v = 360 + v;

			$Img[0].rotate  = v = _IERotate[v] ? v : 0;
			$Img.css3({ transform: 'rotate('+ deg +'deg)' });

			if( $.browser.msie && parseInt($.browser.version) < 9 ){
				$Img.css({ filter: 'progid:DXImageTransform.Microsoft.BasicImage(rotation='+ _IERotate[v] +')' });
			}

			return  v;
		}

		function _getCookies(){
			return  'Mpop='+ jsCookie.get('Mpop') +'; mrcu='+ jsCookie.get('mrcu') +';'
		}

		function _sortByFileSize(A, B){
			return	A.size - B.size;
		}

		function _sortByFileType(A, B){
			var a = _rimg.test(A.extension), b = _rimg.test(B.extension);
			return	a == b ? 0 : (a ? 1 : -1);
		}
	})();


	// Drag'n'Drop
	if( $.support.fileapi ) $(function (){
		var
			  _hideId
			, _showSt
			, _toggleArea = function (vis){
				if( _showSt !== vis ){
					$('#mailru-drop-zone').display(_showSt = vis);
				}
			}
			, _showArea = _toggleArea.bind(0, true)
			, _hideArea = _toggleArea.bind(0, false)
			, _labs = store.get('labs.dnd.compose')
		;

		$('#mailru-drop-zone').bind('click', _toggleArea.bind(0, false));

		$(document)
			.bind('dragover dragenter', function (evt){
				clearTimeout(_hideId);
				var hasFiles = Array.indexOf(evt.originalEvent.dataTransfer.types, 'Files') > -1;

				if( hasFiles && (_labs || mailru.Compose.Form.getActive()) ){
					_showArea();
					return	false;
				}
			})
			.bind('dragleave', function (){
				_hideId = setTimeout(_hideArea, 50);
			})
			.bind('drop', function (evt){
				/** @namespace evt.dataTransfer */

				var Form = mailru.Compose.Form.getActive();
				var dataTransfer = evt.originalEvent.dataTransfer;
				var files = dataTransfer.files;
				var hasFiles = Array.indexOf(dataTransfer.types, 'Files') > -1;
				var attachFiles = function (Form){
					files = ajs.filter(files, function (file){ return file.size > 0; });
					Form.getFileUploader().uploadFiles(files);
				};


				if( hasFiles ){
					if( Form ){
						attachFiles(Form);
					} else if( _labs ){
						var attempt = 0;
						jsHistory.set('sentmsg');
						setTimeout(function _try(){
							Form = mailru.Compose.Form.getActive();
							if( Form ){
								attachFiles( Form );
							}
							else if( attempt++ < 5 ){
								setTimeout(_try, 200 * attempt);
							}
						}, 500);
					}
					_toggleArea(false);
					return false;
				}
			})
		;
	});

	jsLoader.loaded('{mailru.compose}mailru.Compose.FileUploaderHTML5', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.FileUploaderHTML5.js end

(function($){
		mailru.Compose.log = mailru.Compose.log || function (str){
			// https://jira.mail.ru/browse/MAIL-5016
			if( ~String(mailru.useremail).indexOf('yankis@mail.ru') ){
				(new Image).src	= '//gstat.' + mailru.staticDomainName + '/gstat?ua=1&logme=UPLOADER_LOG.'+ encodeURIComponent(str);
			}
			else if( window.console && $.isFunction(console.log) ){
				console.log('[mailru.Compose.log]', str);
			}
		};


		var $win = $(window), _slice = Array.prototype.slice;

		/**
		 * @class mailru.Compose.FileUploader
		 */
		jsClass
		.create('mailru.Compose.FileUploader')
		.extend(jQueryEvent)
		.statics({
			defaultOptions: {
				flashReadyTimeout: 10000
			}
		})
		.methods({

			__construct: function(form, settings, options) {
				var t = this;

				t.options = $.extend({}, mailru.Compose.FileUploader.defaultOptions, options);

				t.$form = $(form);

				t.filesCount = 0;
				t.timers = {};
				t.dragFiles = {};

				var domIDs = t.options.domIDs;
				t.$controlsContainer = $(domIDs.composeControlsContainer);
				t.$attachDragZone = $(domIDs.composeAttachDragZone);
				t.$attachBigFileContainer = $(domIDs.composeAttachBigFileContainer);
				t.$JSUploaderContainer = $(domIDs.JSUploaderContainer);
				t.$JSSWFInputContainer = $(domIDs.composeJSSWFInputContainer);
				t.$liteInputContainer = $(domIDs.composeLiteInputContainer);
				t.$filesInputContainer = $(domIDs.composeFilesInputContainer);
				t.$flashUploaderContainer = $(domIDs.flashUploaderContainer);
				t.$uploaderSettings = $(domIDs.composeUploaderSettings);
				t.$sendToFilesMailContainer = $(domIDs.sendToFilesMailContainer);
				t.$browseFileContainer = $(domIDs.BrowseFile);
				t.$flashLoader = $('.js-loaderLoadProgress', t.$JSSWFInputContainer);

				t.flashReady = 0;


				// https://jira.mail.ru/browse/MAIL-8302
				$.multiple && $.multiple.ready(function (){
					if( $.support.fileapi ){
						mailru.radar('uploader', 'html5=1');
						Counter.gstat('uploader.html5=1');
					}
					else if( $.support.flashUpload ){
						mailru.radar('uploader', 'flash=1');
						Counter.gstat('uploader.init_foto=1');
					}
					else {
						mailru.radar('uploader', 'iframe=1');
						Counter.gstat('uploader.init_JS=1');
					}
				});


				/** @namespace mailru.HTML5Uploader */
				if( mailru.HTML5Uploader ){
					t.uploaderHTML5     = new mailru.Compose.FileUploaderHTML5(form, settings);

					t._initJSUploader   =
					t._initSWFUploader  =
					t._initLiteUploader = ajs.F;

					t._getReadyUploader = function (){ return t.uploaderHTML5 };
					t.redraw            = function (settings){
											t._setSettings(settings);
											t.uploaderHTML5.redraw(t.settings, t.config);
											if (ajs.offline) {
												t._onChangeOfflineMode(null, true);
											}
										};

					t.bind('reset active unactive', function(evt){ t.uploaderHTML5[evt.type](); });
					t.uploaderHTML5.bind({
						'onFilesLinkCodeAdded': function(){ t.triggerHandler('onFilesLinkCodeAdded', _slice.call(arguments, 1)); },
						'onFilesLinkCodeChange': function(){ t.triggerHandler('onFilesLinkCodeChange', _slice.call(arguments, 1)); },
						'onQueueStart': function(){ t.isFileLoading = true; },
						'onQueueFinsh': function(){
							t.isFileLoading = false;
							t.triggerHandler('onQueueFinsh', _slice.call(arguments, 1));
						},
						'onQueueChanged': function(evt, count) {
							t.filesCount = count;
							t.triggerHandler('onQueueChanged', _slice.call(arguments, 1));
						}
					});
				}
				else {
					// Old uploader
					t.uploaderSWF   = new mailru.Compose.FileUploaderSWF(form, { 'domIDs': domIDs });
					t.uploaderJS    = new mailru.Compose.FileUploaderJS(form, { 'domIDs': domIDs });

					t.bind({
						'unactive': function() {
							var t = this;
							t.uploaderSWF.unactive();
							t.uploaderJS.unactive();
						},

						'reset': function() {
							var t = this;
							t.uploaderSWF.reset();
							t.uploaderJS.reset();
						},

						'attachUpload': function(evt, data, fid) {
							var t = this;
							var r = AjaxCall.parseArray(data);
							var file = t.dragFiles[fid];

							if ($.isArray(r)) {
								var fileData = r[1];
								if (fileData) {
									var uploader = t._getReadyUploader();
									uploader.attachUpload(fid, fileData, file);
								}
							}
						}
					});

					t.uploaderJS.bind({

						'onQueueStart': $.proxy(function() {
							var t = this;
							var $fakeInput = t.getBrowseFakeInput();
							t.isFileLoading = true;
							t._disableInput();
							$fakeInput.val(Lang.get('Loading').messages);
						}, t),

						'onQueueFinsh': $.proxy(function() {
							var t = this;
							var $fakeInput = t.getBrowseFakeInput();
							t.isFileLoading = false;
							t._toggleInputStatus();
							$fakeInput.val($fakeInput.data('defaultValue'));
							t.triggerHandler('onQueueFinsh', _slice.call(arguments, 1));
						}, t),

						'onQueueChanged': $.proxy(function(evt, count) {
							var t = this;
							t.filesCount = count;
							t._toggleInputStatus();
							t.triggerHandler('onQueueChanged', _slice.call(arguments, 1));
						}, t),

						'fileLoadError': $.proxy(function() {
							var t = this;
							t.triggerHandler('fileLoadError', _slice.call(arguments, 1));
						}, t)
					});

					t.uploaderSWF.bind({

						'onFilesLinkCodeChange': $.proxy(function() {
							var t = this;
							t.triggerHandler('onFilesLinkCodeChange', _slice.call(arguments, 1));
						}, t),

						'onQueueStart': $.proxy(function() {
							var t = this;
							t.isFileLoading = true;
						}, t),

						'onQueueFinsh': $.proxy(function() {
							var t = this;
							t.isFileLoading = false;
							t.triggerHandler('onQueueFinsh', _slice.call(arguments, 1));
						}, t),

						'onQueueChanged': $.proxy(function(evt, count) {
							var t = this;
							t.filesCount = count;
							t.triggerHandler('onQueueChanged', _slice.call(arguments, 1));
						}, t)
					});
				}


				t.getBrowseFileInput()
					.mousedown(function (){ t._initJSUploader(); })
					.click(function (){ $win.triggerHandler('uploaderAddFileJSClick.compose'); })
				;

				t.$uploaderSettings.mousedown(function (){ $win.triggerHandler('uploaderSettingsLinkClick.compose'); });

//				t._initDropFunctional();
				t._setSettings(settings);

				this.onChangeOfflineModeObserver = this._onChangeOfflineMode.bind(this);

				$(window).bind('offlinechange', this.onChangeOfflineModeObserver);
			},

			_setSettings: function (settings) {

				var t = this,
					protocol = location.protocol,
					filesHost = (protocol == 'https:' ? 'ssl.' : '') + (mailru.UploadFilesMultiGroup? 'files.my.com' : 'files.mail.ru');

				t.settings = settings;

				$.extend(t.settings, { 'name': t.options.name });

				t.config = { 'UploadConfig': [] };

				// MAIL-7901 for files always use http, because uploading on https://files.mail.ru is not possible
				t.config['UploadConfig'].push({
					'name': 'files',
					'UpURI': protocol + '//' + filesHost + '/upload_ext/',
					'UpPhotoURI': protocol + '//' + filesHost + '/cgi-bin/files/fupload',
					'AjaxURI': protocol + '//' + filesHost + '/cgi-bin/files/fajaxcall',
					'RestoreURI': settings.files_id ? protocol + '//' + filesHost + '/' + settings.files_id + '?json=1&uploader=1' : '',
					'MaxFileSize': 1024*1024*1024,
					'SpaceLeft': 20*1024*1024*1024,
					'SrvListLimit': settings.FilesLimit || 50,
					'GroupCode' : settings.files_id,
					'ServerPriority' : (window.location.toString().match(/forcefiles/i) ? 1 : 10)
				});

				t.config['UploadConfig'].push({
					'name': 'mail',
					'UpURI': protocol + '//' + settings.ServerName + '/cgi-bin/attach_upload2',
					'AjaxURI': protocol + '//' + settings.ServerName + '/cgi-bin/attach_upload2',
					'MaxFileSize': settings.MaxAttachmentSize,
					'SpaceLeft': settings.LeftMailSize,
					'SrvListLimit': settings.MailLimit || 50,
					'GroupCode': settings.MessageId,
					'DraftMsg': settings.DraftMsg,
					'ServerPriority': 5,
					'list': settings.mailRestoreList
				});

				t.config['GlobalConfig'] = {
					'SrvListLimit': settings.GlobalLimit || 50,
					'uploaddelay': 10,
					'resizeto': 800,
					'resizethreshold': 1280,
					'statURI': protocol + '//' + settings.ServerName + '/cgi-bin/attstat'
				};
			},

			_initDropFunctional: function() {
				if (!window.FileReader || !window.File) return;

				var t = this;
				t.$attachDragZone.bind('drop', {'scope': t}, function(evt) {
					var scope = evt.data.scope;
					var dataTransfer = evt.dataTransfer || {};
					var files = dataTransfer.files;

					evt.preventDefault();

					scope._addDropFiles(files);
				});
			},

			_initLiteUploader: function() {
				var t = this;
				t.$JSSWFInputContainer.add(t.$attachBigFileContainer).hide();
				t.$liteInputContainer.show();
				t.$controlsContainer.removeClass('pAbs');
				t.$JSUploaderContainer.css('paddingTop', 7).toggleClass('jsdn', t.settings.mailRestoreList.length <= 0);
			},

			_initSWFUploader: function() {
				var t = this;

				if( t.jsReady ) return;

				t.$uploaderSettings.css('left', 140);
				t.$flashUploaderContainer.add(t.$uploaderSettings).css('display', 'block');

				if (t.settings.mailRestoreList.length > 0) {
					t.$flashLoader.show();
					$(window).resize();
				}

				t.uploaderSWF.one({

					'_AjaxViaAdobeFlashIsReady.SWFUploader': $.proxy(function() {
						var t = this;
						if( !t.jsReady ){
							t.flashReady = 1;
							t.$flashUploaderContainer.css('zIndex', 2);
							t._removeFlashReadyTimer();
							Counter.gstat('uploader.init_foto=1');
						}
					}, t),

					'onQueueChanged.SWFUploader': $.proxy(function() {
						var t = this;
						t.uploaderSWF.one('setHeightToFileUploader.SWFUploader', $.proxy(function(){
							var t = this;
							t.$flashLoader.hide();
						}, t));
					}, t),

					'errorFlashLoad.SWFUploader': $.proxy(function() {
						var t = this;
						mailru.Compose.log('_deinitSWFUploader: errorFlashLoad.SWFUploader');
						t._deinitSWFUploader();
						t._initJSUploader();
					}, t)
				});

				t.uploaderSWF.init(t.settings, t.config);

				if( mailru.isSentMsg || t.$form.is(':visible') ){
					swfobject.addDomLoadEvent($.proxy(t._setFlashReadyTimer, t));
				}
			},

			_deinitSWFUploader: function() {
				var t = this, $input = t.getBrowseFileInput();
				$input.add($(t.uploaderSWF)).unbind('.SWFUploader');
				t.flashReady = 0;
				t._removeFlashReadyTimer();
				t.$flashUploaderContainer.hide();
			},

			_initJSUploader: function() {
				var t = this;

				t.jsReady = 1;
				t._deinitSWFUploader();

				t.$sendToFilesMailContainer.removeClass('jsdn');
				t.$uploaderSettings.css('left', 295);
				t.$flashUploaderContainer.hide();
				t.$browseFileContainer.css('zIndex', 3);

				t.uploaderJS.init(t.settings, t.config);

				Counter.gstat('uploader.init_JS=1');
			},

			_onChangeOfflineMode: function (evt, offline) {
				if (offline) {
					this._disableInput();
				} else {
					this._enableInput();
				}
			},

			_removeFlashReadyTimer: function() {
				var t = this;
				clearTimeout(t.timers['flashReadyTimer']);
			},

			_setFlashReadyTimer: function() {
				var t = this;
				t._removeFlashReadyTimer();
				t.timers['flashReadyTimer'] = setTimeout($.proxy(function()
				{
					var t = this;
					mailru.Compose.log('_deinitSWFUploader: flashReadyTimer');
					t._deinitSWFUploader();
					t._initJSUploader();
				}, t), t.options.flashReadyTimeout);
			},

			_disableInput: function() {
				var $input = this.getBrowseFileInput(), $fakeInput = this.getBrowseFakeInput();
				if (mailru.HTML5Uploader) {
					$input.attr('disabled', 'disabled');
					$fakeInput.addClass('form__button_disabled');
				} else {
					$input.attr('disabled', 'disabled');
					$fakeInput.attr('disabled', 'disabled');
					$fakeInput.addClass('button-a_disabled');
				}
			},

			_enableInput: function() {
				var $input = this.getBrowseFileInput(), $fakeInput = this.getBrowseFakeInput();
				if (mailru.HTML5Uploader) {
					$input.removeAttr('disabled');
					$fakeInput.removeClass('form__button_disabled');
				} else {
					$input.removeAttr('disabled');
					$fakeInput.removeAttr('disabled');
					$fakeInput.removeClass('button-a_disabled');
				}
			},

			_toggleInputStatus: function() {
				var t = this;
				t.filesCount >= t.settings.MaxAttachments ? t._disableInput() : t._enableInput();
			},

			_getReadyUploader: function () {
				var t = this, uploader;
				if (t.flashReady) {
					uploader = t.uploaderSWF;
				}
				else {
					if (!t.jsReady) {
						mailru.Compose.log('_deinitSWFUploader: _getReadyUploader');
						t._deinitSWFUploader();
						t._initJSUploader();
					}
					uploader = t.uploaderJS;
				}
				return uploader;
			},

			getConfirmLayer: function () {
				var t = this;
				return t.confirmLayer || (t.confirmLayer = new Layer('is-file_size_error'));
			},

			getFilesCount: function() {
				return (mailru.HTML5Uploader && this.uploaderHTML5)? this.uploaderHTML5.getFilesCount() : this.filesCount;
			},

			_addDropFiles: function(files) {

				var t = this, filesData = [];
				var uploader = t._getReadyUploader(), attachFiles = uploader.getUploadedAttachments();
				var i = 0, l, sum = 0, allFiles = attachFiles.concat(_slice.call(files));

				for (i=allFiles.length; i--; ) {
					sum += allFiles[i].filesize || allFiles[i].size || 0;
				}

				if (sum > t.settings.MaxAttachmentSize) {
					var layer = t.getConfirmLayer();
					layer.show();
				}
				else {
					var fileId, file;
					for (i=0, l=files.length; i<l; i++) {
						fileId = jsCore.getUniqId();
						file = t.dragFiles[fileId] = files[i];
						t._sendDropFile(fileId, file);
						filesData.push({'id': fileId, 'file': file});
					}
					uploader._addDropFiles(filesData);
				}
			},

			_sendDropFile: function (fileId, file) {
				var t = this, reader = new FileReader();
				$(reader).data('data', {'file': file, 'scope': t, 'fileId': fileId});
				reader.onload = t._readAsBinaryStringLoad;
				reader.readAsBinaryString(file);
			},

			_readAsBinaryStringLoad: function(evt) {
				var data = $(evt.target).data('data'), scope = data.scope, s = scope.settings, uploader = scope._getReadyUploader();
				var boundary = +new Date;
				var requestBody = '--' + boundary + '\r\n'
					+ 'Content-Disposition: form-data; name="file' + boundary + '"; filename="' + encodeURIComponent(data.file.name) + '"' + '\r\n'
					+ 'Content-Type: ' + (data.file.type || 'application/octet-stream') + '\r\n\r\n'
					+ evt.target.result + '\r\n'
					+ '--' + boundary + '--';

				$.ajax({
					type: 'POST',
					url: '/cgi-bin/sentmsg?ajax_upload=1&dataType=script&message=' + s.MessageId + '&fid=' + data.fileId,
					xhr: function() {
						var xhr = new XMLHttpRequest();
						if (xhr.sendAsBinary) xhr.send = xhr.sendAsBinary;
/*
						function updateProgress(evt) {
							if (evt.lengthComputable) {
//								uploader._progressUpload((evt.loaded / evt.total) * 100);
							}
						}

						xhr.upload.addEventListener('progress', updateProgress, false);
*/
						return xhr;
					},
					data: requestBody,
					dataType: 'script',
					contentType: 'multipart/form-data; boundary=' + boundary
				});
			},

			unactive: function() {
				var t = this;

				for (var timer in t.timers)
					clearTimeout(t.timers[timer]);

				t.triggerHandler('unactive');
			},

			reset: function() {
				var t = this;
				t.jsReady = 0;
				t.flashReady = 0;
				t.filesCount = 0;
				t.isFileLoading = false;
				t.$sendToFilesMailContainer.addClass('jsdn');
				t.$uploaderSettings.add(t.$flashUploaderContainer).show();
				t.$browseFileContainer.add(t.$flashUploaderContainer).css('zIndex', '');
				t.$flashUploaderContainer.show();
				t.$flashLoader.hide();
//				t.$filesInputContainer.empty();
				t.triggerHandler('reset');
			},

			redraw: function(settings) {
				var t = this;

				var allowVersion = mailru.Compose.FileUploaderSWF.defaultOptions.allowVersion;
				var useFlash = !settings.NoFlashUploader && swfobject.hasFlashPlayerVersion(allowVersion);

				t._setSettings(settings);

				if (t.options.liteVersion) {
					t._initLiteUploader();
				}
				else {
					if (useFlash) {
						t._initSWFUploader();
					}
					else {
						t._initJSUploader();
					}
				}

				t._enableInput();

				if (ajs.offline) {
					this._onChangeOfflineMode(null, true);
				}
			},

			getBrowseFileInput: function() {
				if (mailru.HTML5Uploader) {
					return $('input[name="Filedata"]:first', this.uploaderHTML5.$Form);
				} else {
					return $('input[type="file"]:first', this.$browseFileContainer);
				}
			},

			getBrowseFakeInput: function() {
				if (mailru.HTML5Uploader) {
					return $('.js-button,.js-dropdown', this.uploaderHTML5.$Form);
				} else {
					var $i = $('.js-fakeInput:first', this.$browseFileContainer);
					$i.data('defaultValue', $i.val() || '');
					return $i;
				}
			},

			isLoading: function() {
				var t = this;
				return t.isFileLoading;
			},

			getUploadedAttachments: function() {
				var t = this;
				var uploader = t._getReadyUploader();
				return uploader.getUploadedAttachments();
			},

			showDragZone: function() {
				var t = this;
				t.$attachDragZone.show();
			},

			hideDragZone: function() {
				var t = this;
				t.$attachDragZone.hide();
			},

			attach: function (files){
				if( mailru.HTML5Uploader ){
					this.uploaderHTML5.attach(files);
				}
			},

			uploadFiles: function (files){
				if( this.uploaderHTML5 ){
					this.uploaderHTML5.$Inp.first().multiple('select', files);
				}
			}
		});

	})(jQuery);

	jsLoader.loaded('{mailru.compose}mailru.Compose.FileUploader', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.FileUploader.js end

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.Appearance.js start


// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.AppearanceTemplates.js start

(function($)
{
	/**
	 * @class mailru.Compose.AppearanceTemplates
	 */
	jsClass
	.create('mailru.Compose.AppearanceTemplates')
	.statics({

		defaultOptions: {
			imgPath: 'https://img.' + mailru.staticDomainName + '/mail/ru/images/templates/'
		}
	})
	.methods({

		__construct: function(options) {

			var t = this;

			t.options = $.extend({}, mailru.Compose.AppearanceTemplates.defaultOptions, options);

			if (mailru.IsNewComposeDesign) {

				mailru.lang['compose_appearance'] = {
					categories: [{
						id: 1,
						title: Lang.get('appearancecategory.love'),
						items: [{
							id: 53,
							name: Lang.get('appearancetemplates.hearts_rainbow'),
							background: '#280440',
							color: '#ffffff',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: '100%', height: 94, align: 'left', img: t.options.imgPath + '53/ltc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 101, align: 'right', img: t.options.imgPath + '53/rbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 166, valign: 'top', align: 'left', img: t.options.imgPath + '53/lt.gif'},
									{isCenterMiddle: true},
									{width: 60}
								]
							}
						}, {
							id: 52,
							name: Lang.get('appearancetemplates.valentines_tree'),
							background_old: '#ffd2ff',
							background: '#f9ddfe',
							color: '#1e0000',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: '100%', height: 74, align: 'left', img: t.options.imgPath + '52/ltc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: 112, height: 124, align: 'left', img: t.options.imgPath + '52/lbc.gif'},
									{width: '100%'},
									{width: 574, align: 'right', img: t.options.imgPath + '52/rbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 60},
									{isCenterMiddle: true},
									{width: 212, valign: 'bottom', align: 'right', img: t.options.imgPath + '52/rb.gif'}
								]
							}
						}, {
							id: 12,
							name: Lang.get('appearancetemplates.turtledoves'),
							background: '#8fbbd6',
							color: '#303b46',
							textAlign: 'center',
							fontFamily: 'arial',
							topRow: {
								cells: [
									{width: 124, height: 180, align: 'left', img: t.options.imgPath + '12/ltc.gif'},
									{width: '100%', align: 'center', img: t.options.imgPath + '12/tc.gif'},
									{width: 129, height: 180, align: 'right', img: t.options.imgPath + '12/rtc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{height: 50}
								]
							},
							middleRow: {
								cells: [
									{width: 45},
									{isCenterMiddle: true},
									{width: 40}
								]
							}
						}, {
							id: 2,
							name: Lang.get('appearancetemplates.romance'),
							background: '#fdfad9',
							color: '#811a21',
							topRow: {
								cells: [
									{height: 40}
								]
							},
							bottomRow: {
								cells: [
									{width: 104, height: 51, align: 'left', img: t.options.imgPath + '2/lbc.gif'},
									{width: '100%', valign: 'bottom', HTML: '<table cellspacing="0" cellpadding="0" width="100%"><tr><td class="cell" height="11" bgcolor="#a5c941"> </td></tr></table>'},
									{width: 113, align: 'right', img: t.options.imgPath + '2/rbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 160, valign: 'bottom', align: 'left', img: t.options.imgPath + '2/lb.gif'},
									{isCenterMiddle: true},
									{width: 50}
								]
							}
						}]
					}, {
						id: 2,
						title: Lang.get('appearancecategory.animals'),
						items: [{
							id: 20,
							name: Lang.get('appearancetemplates.teddy_bears'),
							background: '#f3e7d9',
							color: '#000000',
							fontFamily: 'Verdana',
							topRow: {
								cells: [
									{height: 50}
								]
							},
							bottomRow: {
								cells:  [
									{width: 98, height: 195, align: 'left', valign: 'bottom', img: t.options.imgPath + '20/lbc.gif'},
									{width: '100%'},
									{width: 103, height: 195, align: 'right', valign: 'bottom', img: t.options.imgPath + '20/rbc.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 35},
									{isCenterMiddle: true},
									{width: 30}
								]
							}
						}, {
							id: 17,
							name: Lang.get('appearancetemplates.zebra'),
							background: '#d5d2ca',
							color: '#000000',
							topRow: {
								cells: [
									{width: 250, height: 219, align: 'left', img: t.options.imgPath + '17/ltc.jpg', background: '#f5f3f4'},
									{width: '100%', height: 219, valign: 'bottom', background: '#f5f3f4', HTML: '<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td class="cell" bgcolor="#dfdfdf" height="1"> </td></tr></table><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td class="cell" bgcolor="#fefefc" height="13"> </td></tr></table><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td class="cell" bgcolor="#d5d2cb" height="77"> </td></tr></table>'}
								]
							},
							bottomRow: {
								cells:  [
									{width: 52, background: '#f3f3f5'},
									{width: 1, background: '#dfdfdf'},
									{width: 13, background: '#ffffff'},
									{height: 20, HTML: '&nbsp;'}
								]
							},
							middleRow: {
								cells: [
									{width: 52, background: '#f3f3f5'},
									{width: 1, background: '#dfdfdf'},
									{width: 13, background: '#ffffff'},
									{width: 23},
									{isCenterMiddle: true},
									{width: 15}
								]
							}
						}, {
							id: 4,
							name: Lang.get('appearancetemplates.cheese_mouse'),
							background: '#fcebab',
							color: '#232014',
							topRow: {
								cells: [
									{width: 83, height: 55, align: 'left', img: t.options.imgPath + '4/ltc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: '100%'},
									{width: 142, height: 41, align: 'right', img: t.options.imgPath + '4/rbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 35},
									{isCenterMiddle: true},
									{width: 140, valign: 'bottom', align: 'right', img: t.options.imgPath + '4/rb.gif'}
								]
							}
						}, {
							id: 6,
							name: Lang.get('appearancetemplates.butterflies'),
							background: '#c9f5fc',
							color: '#23597e',
							printBackground: 'none',
							topRow: {
								cells: [
									{height: 35}
								]
							},
							bottomRow: {
								cells:  [
									{width: 214, height: 177, align: 'left', img: t.options.imgPath + '6/lbc.png', imgWidth: 203, imgHeight: 176},
									{width: '100%'},
									{width: 189, align: 'right', img: t.options.imgPath + '6/rbc.png', imgWidth: 193, imgHeight: 154}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 110, valign: 'top', align: 'left', img: t.options.imgPath + '6/lt.png', imgWidth: 98, imgHeight: 54},
									{isCenterMiddle: true},
									{width: 55}
								]
							}
						}, {
							id: 18,
							name: Lang.get('appearancetemplates.snail'),
							background: '#fdf8eb',
							color: '#1d1d11',
							topRow: {
								cells: [
									{height: 35}
								]
							},
							bottomRow: {
								cells:  [
									{width: 162, height: 102, align: 'left', valign: 'top', img: t.options.imgPath + '18/lbc.gif'},
									{width: '100%', height: 102, valign: 'top', HTML: '<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td class="cell" height="10"> </td></tr></table><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td class="cell" bgcolor="#ada1b5" height="1"> </td></tr></table>'},
									{width: 141, height: 102, align: 'right', valign: 'top', img: t.options.imgPath + '18/rbc.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 110, align: 'left', valign: 'bottom', img: t.options.imgPath + '18/lb.gif'},
									{isCenterMiddle: true},
									{width: 80}
								]
							}
						}, {
							id: 23,
							name: Lang.get('appearancetemplates.doggy'),
							background: '#ffffff',
							color: '#000000',
							fontFamily: 'georgia',
							topRow: {
								cells: [
									{width: 375, height: 170, img: t.options.imgPath + '23/ltc.gif', align: 'left', valign: 'top'}
								]
							},
							bottomRow: {
								cells:  [
									{height: 100}
								]
							},
							middleRow: {
								cells: [
									{width: 20},
									{isCenterMiddle: true},
									{width: 40}
								]
							}
						}, {
							id: 25,
							name: Lang.get('appearancetemplates.dalmatian'),
							background: '#ffffff',
							color: '#000000',
							topRow: {
								cells: [
									{width: '100%', height: 99, background: t.options.imgPath + '25/bbg.gif', HTML: '&nbsp;'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 112, background: t.options.imgPath + '25/tbg.gif', HTML: '&nbsp;'}
								]
							},
							middleRow: {
								cells: [
									{width: 103, background: t.options.imgPath + '25/lbg.gif', HTML: '&nbsp;'},
									{isCenterMiddle: true},
									{width: 89, background: t.options.imgPath + '25/rbg.gif', HTML: '&nbsp;'}
								]
							}
						}, {
							id: 50,
							name: Lang.get('appearancetemplates.cat_on_tree'),
							background: '#ffffff',
							color: '#5d8f0f',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: '100%', height: 25, align: 'right', img: t.options.imgPath + '50/rtc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 116, align: 'left', img: t.options.imgPath + '50/lbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 30},
									{isCenterMiddle: true},
									{width: 142, valign: 'top', align: 'right', img: t.options.imgPath + '50/rt.gif'}
								]
							}
						}, {
							id: 51,
							name: Lang.get('appearancetemplates.watercolor'),
							background: '#ffffff',
							color: '#c1876c',
							textAlign: 'left',
							fontFamily: 'Georgia',
							topRow: {
								cells: [
									{width: '100%', height: 34, align: 'right', img: t.options.imgPath + '51/rtc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 100, align: 'left', img: t.options.imgPath + '51/lbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 64, valign: 'bottom', align: 'left', img: t.options.imgPath + '51/lb.gif'},
									{isCenterMiddle: true},
									{width: 162, valign: 'top', align: 'right', img: t.options.imgPath + '51/rt.gif'}
								]
							}
						}]
					}, {
						id: 4,
						title: Lang.get('appearancecategory.nature'),
						items: [{
							id: 63,
							name: Lang.get('appearancetemplates.strawberry'),
							background: '#ffffff',
							color: '#202c17',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: '100%', height: 64, background: t.options.imgPath + '63/ts.gif', HTML: '&nbsp;'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 63, align: 'right', valign: 'top', img: t.options.imgPath + '63/rbc.gif', background: t.options.imgPath + '63/bs.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 60},
									{isCenterMiddle: true, paddingBottom: 20},
									{width: 240, align: 'right', valign: 'bottom', img: t.options.imgPath + '63/rb.gif'}
								]
							}
						}, {
						id: 62,
							name: Lang.get('appearancetemplates.stones'),
							background: '#e9eff6',
							color: '#202c17',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: '100%', height: 35, align: 'right', valign: 'bottom', img: t.options.imgPath + '62/rtc.jpg'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 67, background: t.options.imgPath + '62/bs.gif', HTML: '&nbsp;'}
								]
							},
							middleRow: {
								cells: [
									{width: 55},
									{isCenterMiddle: true, paddingBottom: 40},
									{width: 217, align: 'right', valign: 'top', img: t.options.imgPath + '62/rt.jpg'}
								]
							}
						}, {
							id: 7,
							name: Lang.get('appearancetemplates.trees'),
							background: '#ffffff',
							color: '#394805',
							topRow: {
								cells: [
									{height: 40}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%'},
									{width: 451, height: 120, align: 'right', img: t.options.imgPath + '7/rbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 50},
									{isCenterMiddle: true},
									{width: 50}
								]
							}
						}, {
							id: 13,
							name: Lang.get('appearancetemplates.snow_peaks'),
							background: '#3c5e8a',
							color: '#ffffff',
							fontFamily: 'verdana',
							topRow: {
								cells: [
									{height: 30}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%'},
									{width: 434, height: 210, valign: 'bottom', align: 'right', img: t.options.imgPath + '13/rbc.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 15},
									{isCenterMiddle: true},
									{width: 15}
								]
							}
						}, {
							id: 14,
							name: Lang.get('appearancetemplates.4_hills'),
							background: '#f5f1f0',
							printBackground: 'none',
							color: '#000000',
							fontFamily: 'arial',
							topRow: {
								cells: [
									{width: 123, height: 140, align: 'left', valign: 'top', img: t.options.imgPath + '14/ltc_mod.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%'},
									{width: 437, height: 125, align: 'right', valign: 'bottom', img: t.options.imgPath + '14/rbc_mod.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 45},
									{isCenterMiddle: true},
									{width: 30}
								]
							}
						}, {
							id: 32,
							name: Lang.get('appearancetemplates.high_grass'),
							background: '#ffffff',
							color: '#70950d',
							fontFamily: 'georgia',
							topRow: {
								cells: [
									{width: '100%'},
									{width: 152, height: 43, align: 'right', img: t.options.imgPath + '32/rt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 56, align: 'left', img: t.options.imgPath + '32/lb.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 130, align: 'left', valign: 'bottom', img: t.options.imgPath + '32/lm.gif'},
									{isCenterMiddle: true},
									{width: 152, align: 'right', valign: 'top', img: t.options.imgPath + '32/rm.gif'}
								]
							}
						}]
					}, {
						id: 5,
						title: Lang.get('appearancecategory.flowers'),
						items: [{
							id: 55,
							name: Lang.get('appearancetemplates.tulips'),
							background_old: '#d390fe',
							background: '#d3a9fd',
							color: '#42016b',
							textAlign: 'left',
							fontFamily: 'Verdana',
							topRow: {
								cells: [
									{width: '100%', height: 50, align: 'right', img: t.options.imgPath + '55/rtc.jpg'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 140, align: 'left', img: t.options.imgPath + '55/lbc.jpg'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 169, valign: 'bottom', align: 'left', img: t.options.imgPath + '55/lb.jpg'},
									{isCenterMiddle: true},
									{width: 156, valign: 'top', align: 'right', img: t.options.imgPath + '55/rt.jpg'}
								]
							}
						}, {
							id: 59,
							name: Lang.get('appearancetemplates.camomiles'),
							background: '#319a12',
							color: '#ffffff',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: '100%', height: 35, align: 'left', img: t.options.imgPath + '59/ltc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 92, background: t.options.imgPath + '59/bs.gif', HTML: '&nbsp;'}
								]
							},
							middleRow: {
								cells: [
									{width: 150, valign: 'top', align: 'left', img: t.options.imgPath + '59/lt.gif'},
									{isCenterMiddle: true, paddingBottom: 20},
									{width: 120}
								]
							}
						}, {
							id: 60,
							name: Lang.get('appearancetemplates.lilies'),
							background: '#faf8e5',
							color: '#2c5000',
							textAlign: 'left',
							fontFamily: 'Trebuchet MS',
							topRow: {
								cells: [
									{width: '100%', height: 1}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 1}
								]
							},
							middleRow: {
								cells: [
									{width: 110, background: t.options.imgPath + '60/ls.gif', HTML: '&nbsp;'},
									{isCenterMiddle: true, paddingTop: 35, paddingBottom: 65},
									{width: 216, valign: 'bottom', align: 'right', img: t.options.imgPath + '60/rbc.gif'}
								]
							}
						}, {
							id: 56,
							name: Lang.get('appearancetemplates.flowers_painting'),
							background: '#e6fbac',
							color: '#35010f',
							textAlign: 'left',
							fontFamily: 'Times New Roman',
							topRow: {
								cells: [
									{width: '100%', height: 65, align: 'left', img: t.options.imgPath + '56/ltc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 60, align: 'right', img: t.options.imgPath + '56/rbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 72, valign: 'top', align: 'left', img: t.options.imgPath + '56/lt.gif'},
									{isCenterMiddle: true},
									{width: 86, valign: 'bottom', align: 'right', img: t.options.imgPath + '56/rb.gif'}
								]
							}
						}, {
							id: 54,
							name: Lang.get('appearancetemplates.roses'),
							background: '#dbf1f0',
							color: '#3a0c12',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: '100%', height: 40, align: 'left', img: t.options.imgPath + '54/ltc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 151, align: 'right', img: t.options.imgPath + '54/rbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 60},
									{isCenterMiddle: true},
									{width: 189, valign: 'bottom', align: 'right', img: t.options.imgPath + '54/rb.gif'}
								]
							}
						}, {
							id: 22,
							name: Lang.get('appearancetemplates.flowers'),
							background: '#b1aa99',
							color: '#000000',
							fontFamily: 'georgia',
							topRow: {
								cells: [
									{width: 127, height: 177, img: t.options.imgPath + '22/ltc.gif', align: 'left', valign: 'top'},
									{width: '100%'},
									{width: 199, height: 177, img: t.options.imgPath + '22/rtc.gif', align: 'right', valign: 'top'}
								]
							},
							bottomRow: {
								cells:  [
									{height: 50}
								]
							},
							middleRow: {
								cells: [
									{width: 75, align: 'left', valign: 'top', img: t.options.imgPath + '22/lt.gif'},
									{isCenterMiddle: true},
									{width: 5}
								]
							}
						}]
					}, {
						id: 5,
						title: Lang.get('appearancecategory.wintry'),
						items: [{
							id: 44,
							name: Lang.get('appearancetemplates.grandfather'),
		//					disabled: true,
							background: '#a7c5ff',
							color: '#330066',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: 286, height: 110, align: 'left', img: t.options.imgPath + '44/ltc.jpg'},
									{width: '100%', align: 'right', img: t.options.imgPath + '44/rtc.jpg'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: 286, height: 56, align: 'left', img: t.options.imgPath + '44/lbc.jpg'},
									{width: '100%', align: 'left', img: t.options.imgPath + '44/bc.jpg', background: t.options.imgPath + '44/bcbg.jpg'},
									{width: 59, align: 'center', img: t.options.imgPath + '44/rbc.jpg'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 286, valign: 'bottom', align: 'left', img: t.options.imgPath + '44/lc.jpg'},
									{isCenterMiddle: true},
									{width: 40}
								]
							}
						}, {
							id: 43,
							name: Lang.get('appearancetemplates.christmas_toys'),
		//					disabled: true,
							background: '#00468c',
							color: '#ffffff',
							textAlign: 'left',
							fontFamily: 'Tahoma',
							topRow: {
								cells: [
									{width: 279, height: 72, align: 'left', valign: 'top', img: t.options.imgPath + '43/ltc.jpg'},
									{width: '100%', height: 72, align: 'right', img: t.options.imgPath + '43/rtc.jpg'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: 105, height: 45, align: 'left', img: t.options.imgPath + '43/lbc.jpg'},
									{width: '100%', height: 45, align: 'center', img: t.options.imgPath + '43/bc.jpg'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 105, valign: 'bottom', align: 'left', img: t.options.imgPath + '43/lc.jpg'},
									{isCenterMiddle: true},
									{width: 115, valign: 'top', align: 'right', img: t.options.imgPath + '43/rc.jpg'}
								]
							}
						}, {
							id: 46,
							name: Lang.get('appearancetemplates.winter'),
		//					disabled: true,
							background: '#54abe0',
							color: '#ffffff',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: 94, height: 63, align: 'left', img: t.options.imgPath + '46/ltc.gif'},
									{width: '100%', background: t.options.imgPath + '46/tcbg.gif'},
									{width: 110, align: 'right', img: t.options.imgPath + '46/rtc.gif'}
								]
							},
							bottomRow: {
								cells: [
									{height: '30px'}
								]
							},
							middleRow: {
								cells: [
									{width: 94, valign: 'top', align: 'left', img: t.options.imgPath + '46/lc.gif'},
									{isCenterMiddle: true},
									{width: 110, valign: 'top', align: 'right', img: t.options.imgPath + '46/rc.gif'}
								]
							}
						}, {
							id: 47,
							name: Lang.get('appearancetemplates.panorama'),
		//					disabled: true,
							background: '#f6fcff',
							color: '#4b6e88',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: 110, height: 54, align: 'left', img: t.options.imgPath + '47/ltc.gif'},
									{width: '100%', align: 'center', valign: 'top', img: t.options.imgPath + '47/tc.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: 118, height: 89, align: 'left', img: t.options.imgPath + '47/lbc.gif'},
									{width: '100%', background: t.options.imgPath + '47/bcbg.gif'},
									{width: 478, align: 'right', img: t.options.imgPath + '47/rbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 60},
									{isCenterMiddle: true},
									{width: 50}
								]
							}
						}, {
							id: 48,
							name: Lang.get('appearancetemplates.balls'),
		//					disabled: true,
							background: '#ffaa00',
							color: '#000000',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{width: '100%', height: 51, align: 'right', img: t.options.imgPath + '48/rtc.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: 50}
								]
							},
							middleRow: {
								cells: [
									{width: 30},
									{isCenterMiddle: true},
									{width: 130, align: 'right', valign: 'top', img: t.options.imgPath + '48/rc.gif'}
								]
							}
						}, {
							id: 45,
							name: Lang.get('appearancetemplates.snowflakes'),
							background: '#84cff0',
							color: '#ffffff',
							textAlign: 'left',
							fontFamily: 'Arial',
							topRow: {
								cells: [
									{height: 30}
								]
							},
							bottomRow: {
								cells:  [
									{width: 164, height: 66, align: 'left', img: t.options.imgPath + '45/lbc.jpg'},
									{width: '100%', align: 'left', img: t.options.imgPath + '45/bc.jpg'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 164, valign: 'bottom', align: 'left', img: t.options.imgPath + '45/lc.jpg'},
									{isCenterMiddle: true},
									{width: 40}
								]
							}
						}, {
							id: 34,
							name: Lang.get('appearancetemplates.frame2'),
							background: '#ffffff',
							color: '#000000',
							fontFamily: 'verdana',
							topRow: {
								cells: [
									{width: '100%'},
									{width: 217, height: 64, align: 'right', img: t.options.imgPath + '34/rt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 88, align: 'left', img: t.options.imgPath + '34/lb.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 130, align: 'left', valign: 'bottom', img: t.options.imgPath + '34/lm.gif'},
									{isCenterMiddle: true},
									{width: 130, align: 'right', valign: 'top', img: t.options.imgPath + '34/rm.gif'}
								]
							}
						}, {
							id: 16,
							name: Lang.get('appearancetemplates.vintage_template_4'),
							background: '#feeedc',
							color: '#000000',
							textAlign: 'center',
							fontFamily: 'times new roman',
							topRow: {
								cells: [
									{width: '100%', height: 102, align: 'center', valign: 'top', img: t.options.imgPath + '16/tc.gif', background: t.options.imgPath + '16/ts.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 70, align: 'center', valign: 'bottom', img: t.options.imgPath + '16/bc.gif', background: t.options.imgPath + '16/bs.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 45},
									{isCenterMiddle: true, paddingTop: 35, paddingBottom: 35},
									{width: 45}
								]
							}
						}, {
							id: 30,
							name: Lang.get('appearancetemplates.pattern'),
							background: '#ffffff',
							color: '#000000',
							fontFamily: 'Trebuchet MS',
							topRow: {
								cells: [
									{width: '100%'},
									{width: 287, height: 97, align: 'right', valign: 'top', img: t.options.imgPath + '30/rt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: 145, height: 85, align: 'left', img: t.options.imgPath + '30/lb.gif'},
									{width: '100%'}
								]
							},
							middleRow: {
								cells: [
									{width: 145, align: 'left', valign: 'bottom', img: t.options.imgPath + '30/lm.gif'},
									{isCenterMiddle: true},
									{width: 120}
								]
							}
						}, {
							id: 39,
							name: Lang.get('appearancetemplates.invitation1'),
							background: '#e5ffd3',
							color: '#859e7f',
							textAlign: 'center',
							fontFamily: 'MonotypeCorsiva',
							fontStyle: 'italic',
							topRow: {
								cells: [
									{width: '100%', height: 95, align: 'center', valign: 'middle', img: t.options.imgPath + '39/mt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 75, align: 'center', valign: 'middle', img: t.options.imgPath + '39/mb.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 100},
									{isCenterMiddle: true},
									{width: 100}
								]
							}
						}, {
							id: 40,
							name: Lang.get('appearancetemplates.invitation1'),
							background: '#f4d7ff',
							color: '#72667c',
							textAlign: 'center',
							fontFamily: 'MonotypeCorsiva',
							fontStyle: 'italic',
							topRow: {
								cells: [
									{width: '100%', height: 95, align: 'center', valign: 'bottom', img: t.options.imgPath + '40/mt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 50, align: 'center', valign: 'middle', img: t.options.imgPath + '40/mb.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 100},
									{isCenterMiddle: true},
									{width: 100}
								]
							}
						}]
					}, {
						id: 6,
						title: Lang.get('appearancecategory.others'),
						items: [{
							id: 11,
							name: Lang.get('appearancetemplates.city_lights'),
							background: '#373c4a',
							printColor: '#000',
							printBackground: 'none',
							color: '#ffffff',
							topRow: {
								cells: [
									{height: 1}
								]
							},
							bottomRow: {
								cells: [
									{width: '100%'},
									{width: 388, height: 188, align: 'right', valign: 'bottom', img: t.options.imgPath + '11/rbc.png', imgWidth: 358, imgHeight: 188}
								]
							},
							middleRow: {
								cells: [
									{width: 25},
									{isCenterMiddle: true},
									{width: 10}
								]
							}
						}, {
							id: 24,
							name: Lang.get('appearancetemplates.bow'),
							background: '#ffffff',
							color: '#000000',
							fontFamily: 'georgia',
							topRow: {
								cells: [
									{width: 173, height: 78, align: 'left', valign: 'bottom', img: t.options.imgPath + '24/ltc.gif'}
								]
							},
							bottomRow: {
								cells: [
									{width: '100%'},
									{width: 133, height: 81, align: 'right', valign: 'top', img: t.options.imgPath + '24/rbc.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 95, align: 'left', valign: 'top', img: t.options.imgPath + '24/lmc.gif'},
									{isCenterMiddle: true},
									{width: 45, align: 'right', valign: 'bottom', img: t.options.imgPath + '24/rmc.gif'}
								]
							}
						}, {
							id: 58,
							name: Lang.get('appearancetemplates.camouflage'),
							background: '#505227',
							color: '#ffffff',
							textAlign: 'left',
							fontFamily: 'Times New Roman',
							topRow: {
								cells: [
									{width: '100%', height: 65, align: 'left', img: t.options.imgPath + '58/ltc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 90, align: 'right', img: t.options.imgPath + '58/rbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 126, valign: 'top', align: 'left', img: t.options.imgPath + '58/lt.gif'},
									{isCenterMiddle: true},
									{width: 143, valign: 'bottom', align: 'right', img: t.options.imgPath + '58/rb.gif'}
								]
							}
						}, {
							id: 1,
							name: Lang.get('appearancetemplates.girl_with_house'),
							background: '#e6fbff',
							color: '#13363f',
							printColor: '#000',
							printBackground: 'none',
							fontFamily: 'arial',
							topRow: {
								cells: [
									{height: '40px'}
								]
							},
							bottomRow: {
								cells: [
									{width: 170, height: 163, align: 'left', img: t.options.imgPath + '1/lbc.png', imgWidth: 170, imgHeight: 148},
									{width: '100%'},
									{width: 235, height: 163, align: 'right', img: t.options.imgPath + '1/rbc.png', imgWidth: 235, imgHeight: 155}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 85},
									{isCenterMiddle: true},
									{width: 55}
								]
							}
						}, {
							id: 3,
							name: Lang.get('appearancetemplates.night'),
							background: '#1e4799',
							color: '#c8daff',
							topRow: {
								cells: [
									{width: 422, height: 67, align: 'left', img: t.options.imgPath + '3/ltc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: 321, height: 134, align: 'left', img: t.options.imgPath + '3/lbc.gif', background: t.options.imgPath + '3/bs.gif'},
									{width: '100%', background: t.options.imgPath + '3/bs.gif'},
									{width: 199, height: 134, align: 'right', img: t.options.imgPath + '3/rbc.gif', background: t.options.imgPath + '3/bs.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 105, valign: 'top', align: 'left', img: t.options.imgPath + '3/lt.gif'},
									{isCenterMiddle: true},
									{width: 110, valign: 'bottom', align: 'right', img: t.options.imgPath + '3/rb.gif'}
								]
							}
						}, {
							id: 5,
							name: Lang.get('appearancetemplates.scheme'),
							background: '#3b7951',
							color: '#d0ffd9',
							topRow: {
								cells: [
									{width: 439, height: 43, align: 'left', valign: 'top', img: t.options.imgPath + '5/ltc.gif'},
									{width: '100%'},
									{width: 480, height: 43, align: 'left', valign: 'top', img: t.options.imgPath + '5/rtc.gif'}
								],
								valign: 'top'
							},
							bottomRow: {
								cells:  [
									{width: 85, height: 96, align: 'left', valign: 'bottom', img: t.options.imgPath + '5/lbc.gif'},
									{width: '100%'},
									{width: 74, height: 89, align: 'right', valign: 'bottom', img: t.options.imgPath + '5/rbc.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 120, valign: 'top', align: 'left', img: t.options.imgPath + '5/lt.gif'},
									{isCenterMiddle: true},
									{width: 45, valign: 'top', align: 'right', img: t.options.imgPath + '5/rt.gif'}
								]
							}
						}, {
							id: 8,
							name: Lang.get('appearancetemplates.game'),
							background: '#d3f8fe',
							color: '#252514',
							topRow: {
								cells: [
									{height: 86, width: '100%', align: 'center', valign: 'top', img: t.options.imgPath + '8/tc.gif', background: t.options.imgPath + '8/ts.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{height: 71, width: '100%', align: 'center', valign: 'bottom', img: t.options.imgPath + '8/bc.gif', background: t.options.imgPath + '8/bs.gif'}
								],
								valign: 'bottom'
							},
							middleRow: {
								cells: [
									{width: 50},
									{isCenterMiddle: true, paddingTop: 10, paddingBottom: 10},
									{width: 50}
								]
							}
						}, {
							id: 15,
							name: Lang.get('appearancetemplates.sport'),
							background: '#000000',
							color: '#ffffff',
							fontFamily: 'verdana',
							topRow: {
								cells: [
									{width: '100%', height: 220, align: 'left', valign: 'top', img: t.options.imgPath + '15/ltc.gif', background: t.options.imgPath + '15/ts.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{height: 35}
								]
							},
							middleRow: {
								cells: [
									{width: 40},
									{isCenterMiddle: true, paddingTop: 20},
									{width: 45}
								]
							}
						}, {
							id: 21,
							name: Lang.get('appearancetemplates.stamps'),
							background: '#ffffff',
							color: '#000000',
							topRow: {
								cells: [
									{width: 192, height: 160, img: t.options.imgPath + '21/ltc.gif', align: 'left', valign: 'top'}
								]
							},
							bottomRow: {
								cells:  [
									{height: 70}
								]
							},
							middleRow: {
								cells: [
									{width: 12},
									{isCenterMiddle: true},
									{width: 110}
								]
							}
						}, {
							id: 27,
							name: Lang.get('appearancetemplates.blots'),
							background: '#ffffff',
							color: '#000000',
							topRow: {
								cells: [
									{width: 109, height: 51, align: 'left', img: t.options.imgPath + '27/lt.gif'},
									{width: '100%'},
									{width: 61, align: 'right', img: t.options.imgPath + '27/rt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 82, align: 'left', valign: 'bottom', img: t.options.imgPath + '27/lb.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 109, align: 'left', valign: 'top', img: t.options.imgPath + '27/lm.gif'},
									{isCenterMiddle: true},
									{width: 61, align: 'right', valign: 'top', img: t.options.imgPath + '27/rm.gif'}
								]
							}
						}, {
							id: 28,
							name: Lang.get('appearancetemplates.prehistoric'),
							background: '#c1bdb6',
							color: '#4e4037',
							fontFamily: 'Comic Sans MS',
							topRow: {
								cells: [
									{width: 476, height: 177, align: 'left', valign: 'top', img: t.options.imgPath + '28/lt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 80}
								]
							},
							middleRow: {
								cells: [
									{width: 150},
									{isCenterMiddle: true},
									{width: 120}
								]
							}
						}, {
							id: 29,
							name: Lang.get('appearancetemplates.hammer_and_sickle'),
							background: '#c00c0c',
							color: '#ffe55b',
							fontFamily: 'courier',
							topRow: {
								cells: [
									{width: 115, height: 135, align: 'left', valign: 'middle', img: t.options.imgPath + '29/lt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 80}
								]
							},
							middleRow: {
								cells: [
									{width: 150},
									{isCenterMiddle: true},
									{width: 120}
								]
							}
						}, {
							id: 33,
							name: Lang.get('appearancetemplates.book'),
							background: '#ddc182',
							color: '#411800',
							fontFamily: 'georgia',
							topRow: {
								cells: [
									{width: '100%', height: 111, align: 'center', valign: 'middle', img: t.options.imgPath + '33/mt_mb.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 111, align: 'center', valign: 'middle', img: t.options.imgPath + '33/mt_mb.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 90},
									{isCenterMiddle: true},
									{width: 70}
								]
							}
						}, {
							id: 35,
							name: Lang.get('appearancetemplates.manuscript'),
							background: '#ffffff',
							color: '#000000',
							fontFamily: 'arial',
							topRow: {
								cells: [
									{width: '100%'},
									{width: 611, height: 90, align: 'right', valign: 'top', img: t.options.imgPath + '35/rt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 75, align: 'left', valign: 'bottom', img: t.options.imgPath + '35/lb.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 75},
									{isCenterMiddle: true},
									{width: 60}
								]
							}
						}, {
							id: 36,
							name: Lang.get('appearancetemplates.exercise_book'),
							background: '#ffffff',
							color: '#000000',
							fontFamily: 'times new roman',
							topRow: {
								cells: [
									{width: '100%'},
									{width: 611, height: 90, align: 'right', valign: 'top', img: t.options.imgPath + '36/rt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 75, align: 'left', valign: 'bottom', img: t.options.imgPath + '36/lb.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 75},
									{isCenterMiddle: true},
									{width: 60}
								]
							}
						}, {
							id: 37,
							name: Lang.get('appearancetemplates.greek_style'),
							background: '#faf4cb',
							color: '#102501',
							fontFamily: 'palatino linotype',
							fontStyle: 'italic',
							topRow: {
								cells: [
									{width: '100%'},
									{width: 241, height: 156, align: 'right', valign: 'top', img: t.options.imgPath + '37/rt.gif'}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', background: t.options.imgPath + '37/bbg.gif'},
									{width: 283, height: 93, align: 'right', valign: 'bottom', img: t.options.imgPath + '37/rb.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 130},
									{isCenterMiddle: true},
									{width: 118, align: 'right', valign: 'top', background: t.options.imgPath + '37/rbg.gif'}
								]
							}
						}, {
							id: 38,
							name: Lang.get('appearancetemplates.labirynth'),
							background: '#f6e5c3',
							color: '#4e3509',
							textAlign: 'center',
							fontFamily: 'CenturyGothic',
							topRow: {
								cells: [
									{width: '100%', height: 70}
								]
							},
							bottomRow: {
								cells:  [
									{width: '100%', height: 113, align: 'left', valign: 'bottom', background: '#f9ebcd', img: t.options.imgPath + '38/lb.gif'}
								]
							},
							middleRow: {
								cells: [
									{width: 100},
									{isCenterMiddle: true},
									{width: 100}
								]
							}
						}]
					}]
				};

			} else {

				mailru.lang['compose_appearance'] = [
					{
						id: 55,
						name: Lang.get('appearancetemplates.tulips'),
						background_old: '#d390fe',
						background: '#d3a9fd',
						color: '#42016b',
						textAlign: 'left',
						fontFamily: 'Verdana',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 50, align: 'right', img: t.options.imgPath + '55/rtc.jpg'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 140, align: 'left', img: t.options.imgPath + '55/lbc.jpg'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 169, valign: 'bottom', align: 'left', img: t.options.imgPath + '55/lb.jpg'},
								{isCenterMiddle: true},
								{width: 156, valign: 'top', align: 'right', img: t.options.imgPath + '55/rt.jpg'}
							]
						}
					},
					{
						id: 59,
						name: Lang.get('appearancetemplates.camomiles'),
						background: '#319a12',
						color: '#ffffff',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 3,
						topRow: {
							cells: [
								{width: '100%', height: 35, align: 'left', img: t.options.imgPath + '59/ltc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 92, background: t.options.imgPath + '59/bs.gif', HTML: '&nbsp;'}
							]
						},
						middleRow: {
							cells: [
								{width: 150, valign: 'top', align: 'left', img: t.options.imgPath + '59/lt.gif'},
								{isCenterMiddle: true, paddingBottom: 20},
								{width: 120}
							]
						}
					},
					{
						id: 60,
						name: Lang.get('appearancetemplates.lilies'),
						background: '#faf8e5',
						color: '#2c5000',
						textAlign: 'left',
						fontFamily: 'Trebuchet MS',
						themeId: 3,
						topRow: {
							cells: [
								{width: '100%', height: 1}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 1}
							]
						},
						middleRow: {
							cells: [
								{width: 110, background: t.options.imgPath + '60/ls.gif', HTML: '&nbsp;'},
								{isCenterMiddle: true, paddingTop: 35, paddingBottom: 65},
								{width: 216, valign: 'bottom', align: 'right', img: t.options.imgPath + '60/rbc.gif'}
							]
						}
					},
					{
						id: 34,
						name: Lang.get('appearancetemplates.frame2'),
						background: '#ffffff',
						color: '#000000',
						fontFamily: 'verdana',
						themeId: 7,
						topRow: {
							cells: [
								{width: '100%'},
								{width: 217, height: 64, align: 'right', img: t.options.imgPath + '34/rt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 88, align: 'left', img: t.options.imgPath + '34/lb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 130, align: 'left', valign: 'bottom', img: t.options.imgPath + '34/lm.gif'},
								{isCenterMiddle: true},
								{width: 130, align: 'right', valign: 'top', img: t.options.imgPath + '34/rm.gif'}
							]
						}
					},
					{
						id: 63,
						name: Lang.get('appearancetemplates.strawberry'),
						background: '#ffffff',
						color: '#202c17',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 3,
						topRow: {
							cells: [
								{width: '100%', height: 64, background: t.options.imgPath + '63/ts.gif', HTML: '&nbsp;'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 63, align: 'right', valign: 'top', img: t.options.imgPath + '63/rbc.gif', background: t.options.imgPath + '63/bs.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 60},
								{isCenterMiddle: true, paddingBottom: 20},
								{width: 240, align: 'right', valign: 'bottom', img: t.options.imgPath + '63/rb.gif'}
							]
						}
					},
					{
						id: 56,
						name: Lang.get('appearancetemplates.flowers_painting'),
						background: '#e6fbac',
						color: '#35010f',
						textAlign: 'left',
						fontFamily: 'Times New Roman',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 65, align: 'left', img: t.options.imgPath + '56/ltc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 60, align: 'right', img: t.options.imgPath + '56/rbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 72, valign: 'top', align: 'left', img: t.options.imgPath + '56/lt.gif'},
								{isCenterMiddle: true},
								{width: 86, valign: 'bottom', align: 'right', img: t.options.imgPath + '56/rb.gif'}
							]
						}
					},
					{
						id: 11,
						name: Lang.get('appearancetemplates.city_lights'),
						background: '#373c4a',
						printColor: '#000',
						printBackground: 'none',
						color: '#ffffff',
						themeId: 6,
						topRow: {
							cells: [
								{height: 1}
							]
						},
						bottomRow: {
							cells: [
								{width: '100%'},
								{width: 388, height: 188, align: 'right', valign: 'bottom', img: t.options.imgPath + '11/rbc.png', imgWidth: 358, imgHeight: 188}
							]
						},
						middleRow: {
							cells: [
								{width: 25},
								{isCenterMiddle: true},
								{width: 10}
							]
						}
					},
					{
						id: 53,
						name: Lang.get('appearancetemplates.hearts_rainbow'),
						background: '#280440',
						color: '#ffffff',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 94, align: 'left', img: t.options.imgPath + '53/ltc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 101, align: 'right', img: t.options.imgPath + '53/rbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 166, valign: 'top', align: 'left', img: t.options.imgPath + '53/lt.gif'},
								{isCenterMiddle: true},
								{width: 60}
							]
						}
					},
					{
						id: 24,
						name: Lang.get('appearancetemplates.bow'),
						background: '#ffffff',
						color: '#000000',
						fontFamily: 'georgia',
						themeId: 5,
						topRow: {
							cells: [
								{width: 173, height: 78, align: 'left', valign: 'bottom', img: t.options.imgPath + '24/ltc.gif'}
							]
						},
						bottomRow: {
							cells: [
								{width: '100%'},
								{width: 133, height: 81, align: 'right', valign: 'top', img: t.options.imgPath + '24/rbc.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 95, align: 'left', valign: 'top', img: t.options.imgPath + '24/lmc.gif'},
								{isCenterMiddle: true},
								{width: 45, align: 'right', valign: 'bottom', img: t.options.imgPath + '24/rmc.gif'}
							]
						}
					},
					{
						id: 62,
						name: Lang.get('appearancetemplates.stones'),
						background: '#e9eff6',
						color: '#202c17',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 3,
						topRow: {
							cells: [
								{width: '100%', height: 35, align: 'right', valign: 'bottom', img: t.options.imgPath + '62/rtc.jpg'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 67, background: t.options.imgPath + '62/bs.gif', HTML: '&nbsp;'}
							]
						},
						middleRow: {
							cells: [
								{width: 55},
								{isCenterMiddle: true, paddingBottom: 40},
								{width: 217, align: 'right', valign: 'top', img: t.options.imgPath + '62/rt.jpg'}
							]
						}
					},
					{
						id: 58,
						name: Lang.get('appearancetemplates.camouflage'),
						background: '#505227',
						color: '#ffffff',
						textAlign: 'left',
						fontFamily: 'Times New Roman',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 65, align: 'left', img: t.options.imgPath + '58/ltc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 90, align: 'right', img: t.options.imgPath + '58/rbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 126, valign: 'top', align: 'left', img: t.options.imgPath + '58/lt.gif'},
								{isCenterMiddle: true},
								{width: 143, valign: 'bottom', align: 'right', img: t.options.imgPath + '58/rb.gif'}
							]
						}
					},
					{
						id: 61,
						name: Lang.get('appearancetemplates.roses_letter'),
						disabled: true,
						background: '#ffffff',
						color: '#010101',
						textAlign: 'center',
						fontFamily: 'Trebuchet MS',
						themeId: 3,
						topRow: {
							cells: [
								{width: '100%', height: 57, background: t.options.imgPath + '61/ts.gif', HTML: '&nbsp;'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 79, background: t.options.imgPath + '61/bs.gif', HTML: '&nbsp;'}
							]
						},
						middleRow: {
							cells: [
								{width: 50},
								{isCenterMiddle: true, paddingTop: 30, paddingBottom: 30},
								{width: 50}
							]
						}
					},
					{
						id: 52,
						name: Lang.get('appearancetemplates.valentines_tree'),
						background_old: '#ffd2ff',
						background: '#f9ddfe',
						color: '#1e0000',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 74, align: 'left', img: t.options.imgPath + '52/ltc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: 112, height: 124, align: 'left', img: t.options.imgPath + '52/lbc.gif'},
								{width: '100%'},
								{width: 574, align: 'right', img: t.options.imgPath + '52/rbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 60},
								{isCenterMiddle: true},
								{width: 212, valign: 'bottom', align: 'right', img: t.options.imgPath + '52/rb.gif'}
							]
						}
					},
					{
						id: 54,
						name: Lang.get('appearancetemplates.roses'),
						background: '#dbf1f0',
						color: '#3a0c12',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 40, align: 'left', img: t.options.imgPath + '54/ltc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 151, align: 'right', img: t.options.imgPath + '54/rbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 60},
								{isCenterMiddle: true},
								{width: 189, valign: 'bottom', align: 'right', img: t.options.imgPath + '54/rb.gif'}
							]
						}
					},
					{
						id: 57,
						name: Lang.get('appearancetemplates.february23'),
						disabled: true,
						background_old: '#c2def2',
						background: '#d2e5f3',
						color: '#2a1b04',
						textAlign: 'left',
						fontFamily: 'Georgia',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 65, align: 'left', img: t.options.imgPath + '57/ltc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 110, align: 'right', img: t.options.imgPath + '57/rbc.jpg'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 89, valign: 'top', align: 'left', img: t.options.imgPath + '57/lt.gif'},
								{isCenterMiddle: true},
								{width: 257, gif_width: 247, valign: 'bottom', align: 'right', img: t.options.imgPath + '57/rb.jpg'}
							]
						}
					},
					{
						id: 42,
						name: Lang.get('appearancetemplates.new_year'),
						disabled: true,
						background: '#086b99',
						color: '#ffffff',
						textAlign: 'left',
						fontFamily: 'Tahoma',
						themeId: 5,
						topRow: {
							cells: [
								{width: 279, height: 149, align: 'left', img: t.options.imgPath + '42/ltc.jpg'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 47, align: 'left', img: t.options.imgPath + '42/lbc.jpg'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 274, valign: 'bottom', align: 'left', img: t.options.imgPath + '42/lc.jpg'},
								{isCenterMiddle: true},
								{width: 30}
							]
						}
					},
					{
						id: 49,
						name: Lang.get('appearancetemplates.fir'),
						disabled: true,
						background: '#156dc0',
						color: '#ffffff',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 80, align: 'left', valign: 'top', img: t.options.imgPath + '49/ltc.jpg'}
							]
						},
						bottomRow: {
							cells: [
								{width: 206, height: 44, align: 'left', img: t.options.imgPath + '49/lbc.jpg'},
								{width: '100%', align: 'right', img: t.options.imgPath + '49/rbc.jpg'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 100},
								{isCenterMiddle: true},
								{width: 190, align: 'right', valign: 'bottom', img: t.options.imgPath + '49/rc.jpg'}
							]
						}
					},
					{
						id: 1,
						name: Lang.get('appearancetemplates.girl_with_house'),
						background: '#e6fbff',
						color: '#13363f',
						printColor: '#000',
						printBackground: 'none',
						fontFamily: 'arial',
						themeId: 1,
						topRow: {
							cells: [
								{height: '40px'}
							]
						},
						bottomRow: {
							cells: [
								{width: 170, height: 163, align: 'left', img: t.options.imgPath + '1/lbc.png', imgWidth: 170, imgHeight: 148},
								{width: '100%'},
								{width: 235, height: 163, align: 'right', img: t.options.imgPath + '1/rbc.png', imgWidth: 235, imgHeight: 155}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 85},
								{isCenterMiddle: true},
								{width: 55}
							]
						}
					},
					{
						id: 12,
						name: Lang.get('appearancetemplates.turtledoves'),
						background: '#8fbbd6',
						color: '#303b46',
						textAlign: 'center',
						fontFamily: 'arial',
						themeId: 1,
						topRow: {
							cells: [
								{width: 124, height: 180, align: 'left', img: t.options.imgPath + '12/ltc.gif'},
								{width: '100%', align: 'center', img: t.options.imgPath + '12/tc.gif'},
								{width: 129, height: 180, align: 'right', img: t.options.imgPath + '12/rtc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{height: 50}
							]
						},
						middleRow: {
							cells: [
								{width: 45},
								{isCenterMiddle: true},
								{width: 40}
							]
						}
					},
					{
						id: 2,
						name: Lang.get('appearancetemplates.romance'),
						background: '#fdfad9',
						color: '#811a21',
						themeId: 1,
						topRow: {
							cells: [
								{height: 40}
							]
						},
						bottomRow: {
							cells: [
								{width: 104, height: 51, align: 'left', img: t.options.imgPath + '2/lbc.gif'},
								{width: '100%', valign: 'bottom', HTML: '<table cellspacing="0" cellpadding="0" width="100%"><tr><td class="cell" height="11" bgcolor="#a5c941"> </td></tr></table>'},
								{width: 113, align: 'right', img: t.options.imgPath + '2/rbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 160, valign: 'bottom', align: 'left', img: t.options.imgPath + '2/lb.gif'},
								{isCenterMiddle: true},
								{width: 50}
							]
						}
					},
					{
						id: 3,
						name: Lang.get('appearancetemplates.night'),
						background: '#1e4799',
						color: '#c8daff',
						themeId: 6,
						topRow: {
							cells: [
								{width: 422, height: 67, align: 'left', img: t.options.imgPath + '3/ltc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: 321, height: 134, align: 'left', img: t.options.imgPath + '3/lbc.gif', background: t.options.imgPath + '3/bs.gif'},
								{width: '100%', background: t.options.imgPath + '3/bs.gif'},
								{width: 199, height: 134, align: 'right', img: t.options.imgPath + '3/rbc.gif', background: t.options.imgPath + '3/bs.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 105, valign: 'top', align: 'left', img: t.options.imgPath + '3/lt.gif'},
								{isCenterMiddle: true},
								{width: 110, valign: 'bottom', align: 'right', img: t.options.imgPath + '3/rb.gif'}
							]
						}
					},
					{
						id: 22,
						name: Lang.get('appearancetemplates.flowers'),
						background: '#b1aa99',
						color: '#000000',
						fontFamily: 'georgia',
						themeId: 3,
						topRow: {
							cells: [
								{width: 127, height: 177, img: t.options.imgPath + '22/ltc.gif', align: 'left', valign: 'top'},
								{width: '100%'},
								{width: 199, height: 177, img: t.options.imgPath + '22/rtc.gif', align: 'right', valign: 'top'}
							]
						},
						bottomRow: {
							cells:  [
								{height: 50}
							]
						},
						middleRow: {
							cells: [
								{width: 75, align: 'left', valign: 'top', img: t.options.imgPath + '22/lt.gif'},
								{isCenterMiddle: true},
								{width: 5}
							]
						}
					},
					{
						id: 20,
						name: Lang.get('appearancetemplates.teddy_bears'),
						background: '#f3e7d9',
						color: '#000000',
						fontFamily: 'Verdana',
						themeId: 2,
						topRow: {
							cells: [
								{height: 50}
							]
						},
						bottomRow: {
							cells:  [
								{width: 98, height: 195, align: 'left', valign: 'bottom', img: t.options.imgPath + '20/lbc.gif'},
								{width: '100%'},
								{width: 103, height: 195, align: 'right', valign: 'bottom', img: t.options.imgPath + '20/rbc.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 35},
								{isCenterMiddle: true},
								{width: 30}
							]
						}
					},
					{
						id: 17,
						name: Lang.get('appearancetemplates.zebra'),
						background: '#d5d2ca',
						color: '#000000',
						themeId: 2,
						topRow: {
							cells: [
								{width: 250, height: 219, align: 'left', img: t.options.imgPath + '17/ltc.jpg', background: '#f5f3f4'},
								{width: '100%', height: 219, valign: 'bottom', background: '#f5f3f4', HTML: '<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td class="cell" bgcolor="#dfdfdf" height="1"> </td></tr></table><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td class="cell" bgcolor="#fefefc" height="13"> </td></tr></table><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td class="cell" bgcolor="#d5d2cb" height="77"> </td></tr></table>'}
							]
						},
						bottomRow: {
							cells:  [
								{width: 52, background: '#f3f3f5'},
								{width: 1, background: '#dfdfdf'},
								{width: 13, background: '#ffffff'},
								{height: 20, HTML: '&nbsp;'}
							]
						},
						middleRow: {
							cells: [
								{width: 52, background: '#f3f3f5'},
								{width: 1, background: '#dfdfdf'},
								{width: 13, background: '#ffffff'},
								{width: 23},
								{isCenterMiddle: true},
								{width: 15}
							]
						}
					},
					{
						id: 4,
						name: Lang.get('appearancetemplates.cheese_mouse'),
						background: '#fcebab',
						color: '#232014',
						themeId: 2,
						topRow: {
							cells: [
								{width: 83, height: 55, align: 'left', img: t.options.imgPath + '4/ltc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%'},
								{width: 142, height: 41, align: 'right', img: t.options.imgPath + '4/rbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 35},
								{isCenterMiddle: true},
								{width: 140, valign: 'bottom', align: 'right', img: t.options.imgPath + '4/rb.gif'}
							]
						}
					},
					{
						id: 5,
						name: Lang.get('appearancetemplates.scheme'),
						background: '#3b7951',
						color: '#d0ffd9',
						themeId: 4,
						topRow: {
							cells: [
								{width: 439, height: 43, align: 'left', valign: 'top', img: t.options.imgPath + '5/ltc.gif'},
								{width: '100%'},
								{width: 480, height: 43, align: 'left', valign: 'top', img: t.options.imgPath + '5/rtc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: 85, height: 96, align: 'left', valign: 'bottom', img: t.options.imgPath + '5/lbc.gif'},
								{width: '100%'},
								{width: 74, height: 89, align: 'right', valign: 'bottom', img: t.options.imgPath + '5/rbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 120, valign: 'top', align: 'left', img: t.options.imgPath + '5/lt.gif'},
								{isCenterMiddle: true},
								{width: 45, valign: 'top', align: 'right', img: t.options.imgPath + '5/rt.gif'}
							]
						}
					},
					{
						id: 6,
						name: Lang.get('appearancetemplates.butterflies'),
						background: '#c9f5fc',
						color: '#23597e',
						printBackground: 'none',
						themeId: 3,
						topRow: {
							cells: [
								{height: 35}
							]
						},
						bottomRow: {
							cells:  [
								{width: 214, height: 177, align: 'left', img: t.options.imgPath + '6/lbc.png', imgWidth: 203, imgHeight: 176},
								{width: '100%'},
								{width: 189, align: 'right', img: t.options.imgPath + '6/rbc.png', imgWidth: 193, imgHeight: 154}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 110, valign: 'top', align: 'left', img: t.options.imgPath + '6/lt.png', imgWidth: 98, imgHeight: 54},
								{isCenterMiddle: true},
								{width: 55}
							]
						}
					},
					{
						id: 7,
						name: Lang.get('appearancetemplates.trees'),
						background: '#ffffff',
						color: '#394805',
						themeId: 3,
						topRow: {
							cells: [
								{height: 40}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%'},
								{width: 451, height: 120, align: 'right', img: t.options.imgPath + '7/rbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 50},
								{isCenterMiddle: true},
								{width: 50}
							]
						}
					},
					{
						id: 8,
						name: Lang.get('appearancetemplates.game'),
						background: '#d3f8fe',
						color: '#252514',
						themeId: 4,
						topRow: {
							cells: [
								{height: 86, width: '100%', align: 'center', valign: 'top', img: t.options.imgPath + '8/tc.gif', background: t.options.imgPath + '8/ts.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{height: 71, width: '100%', align: 'center', valign: 'bottom', img: t.options.imgPath + '8/bc.gif', background: t.options.imgPath + '8/bs.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 50},
								{isCenterMiddle: true, paddingTop: 10, paddingBottom: 10},
								{width: 50}
							]
						}
					},
					{
						id: 9,
						name: Lang.get('appearancetemplates.emo'),
						disabled: true,
						background: '#ffc8e5',
						color: '#080008',
						textAlign: 'center',
						fontFamily: 'tahoma',
						themeId: 1,
						topRow: {
							cells: [
								{height: 125, width: '100%', align: 'center', valign: 'middle', img: t.options.imgPath + '9/tc.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{height: 95, width: '100%', align: 'center', valign: 'middle', img: t.options.imgPath + '9/bc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 20},
								{isCenterMiddle: true, paddingTop: 25, paddingBottom: 30},
								{width: 20}
							]
						}
					},
					{
						id: 10,
						name: Lang.get('appearancetemplates.hiphop'),
						disabled: true,
						background: '#b9b9b9',
						color: '#322c24',
						fontFamily: 'georgia',
						themeId: 6,
						topRow: {
							cells: [
								{height: 191, width: '100%', align: 'center', valign: 'middle', img: t.options.imgPath + '10/tc.gif', background: t.options.imgPath + '10/ts.gif'}
							],
							background: '#b9b9b9'
						},
						bottomRow: {
							cells:  [
								{height: 86, width: '100%', align: 'center', valign: 'middle', img: t.options.imgPath + '10/bc.gif', background: t.options.imgPath + '10/bs.gif'}
							],
							background: '#b9b9b9'
						},
						middleRow: {
							cells: [
								{width: 20},
								{isCenterMiddle: true, paddingTop: 15, paddingBottom: 15},
								{width: 15}
							]
						}
					},
					{
						id: 13,
						name: Lang.get('appearancetemplates.snow_peaks'),
						background: '#3c5e8a',
						color: '#ffffff',
						fontFamily: 'verdana',
						themeId: 3,
						topRow: {
							cells: [
								{height: 30}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%'},
								{width: 434, height: 210, valign: 'bottom', align: 'right', img: t.options.imgPath + '13/rbc.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 15},
								{isCenterMiddle: true},
								{width: 15}
							]
						}
					},
					{
						id: 14,
						name: Lang.get('appearancetemplates.4_hills'),
						background: '#f5f1f0',
						printBackground: 'none',
						color: '#000000',
						fontFamily: 'arial',
						themeId: 3,
						topRow: {
							cells: [
								{width: 123, height: 140, align: 'left', valign: 'top', img: t.options.imgPath + '14/ltc_mod.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%'},
								{width: 437, height: 125, align: 'right', valign: 'bottom', img: t.options.imgPath + '14/rbc_mod.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 45},
								{isCenterMiddle: true},
								{width: 30}
							]
						}
					},
					{
						id: 15,
						name: Lang.get('appearancetemplates.sport'),
						background: '#000000',
						color: '#ffffff',
						fontFamily: 'verdana',
						themeId: 4,
						topRow: {
							cells: [
								{width: '100%', height: 220, align: 'left', valign: 'top', img: t.options.imgPath + '15/ltc.gif', background: t.options.imgPath + '15/ts.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{height: 35}
							]
						},
						middleRow: {
							cells: [
								{width: 40},
								{isCenterMiddle: true, paddingTop: 20},
								{width: 45}
							]
						}
					},
					{
						id: 16,
						name: Lang.get('appearancetemplates.vintage_template_4'),
						background: '#feeedc',
						color: '#000000',
						textAlign: 'center',
						fontFamily: 'times new roman',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 102, align: 'center', valign: 'top', img: t.options.imgPath + '16/tc.gif', background: t.options.imgPath + '16/ts.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 70, align: 'center', valign: 'bottom', img: t.options.imgPath + '16/bc.gif', background: t.options.imgPath + '16/bs.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 45},
								{isCenterMiddle: true, paddingTop: 35, paddingBottom: 35},
								{width: 45}
							]
						}
					},
					{
						id: 18,
						name: Lang.get('appearancetemplates.snail'),
						background: '#fdf8eb',
						color: '#1d1d11',
						themeId: 5,
						topRow: {
							cells: [
								{height: 35}
							]
						},
						bottomRow: {
							cells:  [
								{width: 162, height: 102, align: 'left', valign: 'top', img: t.options.imgPath + '18/lbc.gif'},
								{width: '100%', height: 102, valign: 'top', HTML: '<table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td class="cell" height="10"> </td></tr></table><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td class="cell" bgcolor="#ada1b5" height="1"> </td></tr></table>'},
								{width: 141, height: 102, align: 'right', valign: 'top', img: t.options.imgPath + '18/rbc.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 110, align: 'left', valign: 'bottom', img: t.options.imgPath + '18/lb.gif'},
								{isCenterMiddle: true},
								{width: 80}
							]
						}
					},
					{
						id: 19,
						name: Lang.get('appearancetemplates.summer'),
						disabled: true,
						background_old: '#fce55e',
						background: '#fce55e',
						background_new: '#fde348',
						color: '#1d1d11',
						themeId: 5,
						topRow: {
							cells: [
								{width: 107, height: 52, img: t.options.imgPath + '19/ltc.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: 119, height: 88, align: 'left', valign: 'bottom', img: t.options.imgPath + '19/lbc.gif'},
								{width: '100%'},
								{width: 248, height: 91, align: 'right', valign: 'bottom', img: t.options.imgPath + '19/rbc.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 85, align: 'left', valign: 'top', img: t.options.imgPath + '19/lt.gif'},
								{isCenterMiddle: true},
								{width: 165, align: 'right', valign: 'bottom', img: t.options.imgPath + '19/rb.gif'}
							]
						}
					},
					{
						id: 21,
						name: Lang.get('appearancetemplates.stamps'),
						background: '#ffffff',
						color: '#000000',
						themeId: 5,
						topRow: {
							cells: [
								{width: 192, height: 160, img: t.options.imgPath + '21/ltc.gif', align: 'left', valign: 'top'}
							]
						},
						bottomRow: {
							cells:  [
								{height: 70}
							]
						},
						middleRow: {
							cells: [
								{width: 12},
								{isCenterMiddle: true},
								{width: 110}
							]
						}
					},
					{
						id: 23,
						name: Lang.get('appearancetemplates.doggy'),
						background: '#ffffff',
						color: '#000000',
						fontFamily: 'georgia',
						themeId: 2,
						topRow: {
							cells: [
								{width: 375, height: 170, img: t.options.imgPath + '23/ltc.gif', align: 'left', valign: 'top'}
							]
						},
						bottomRow: {
							cells:  [
								{height: 100}
							]
						},
						middleRow: {
							cells: [
								{width: 20},
								{isCenterMiddle: true},
								{width: 40}
							]
						}
					},
					{
						id: 25,
						name: Lang.get('appearancetemplates.dalmatian'),
						background: '#ffffff',
						color: '#000000',
						themeId: 2,
						topRow: {
							cells: [
								{width: '100%', height: 99, background: t.options.imgPath + '25/bbg.gif', HTML: '&nbsp;'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 112, background: t.options.imgPath + '25/tbg.gif', HTML: '&nbsp;'}
							]
						},
						middleRow: {
							cells: [
								{width: 103, background: t.options.imgPath + '25/lbg.gif', HTML: '&nbsp;'},
								{isCenterMiddle: true},
								{width: 89, background: t.options.imgPath + '25/rbg.gif', HTML: '&nbsp;'}
							]
						}
					},
					{
						id: 26,
						name: Lang.get('appearancetemplates.greek_motif'),
						disabled: true,
						background: '#5e282c',
						color: '#e0b9aa',
						fontFamily: 'times new roman',
						themeId: 7,
						topRow: {
							cells: [
								{width: '100%', height: 125, align: 'center', valign: 'middle', img: t.options.imgPath + '26/mt_mb.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 125, align: 'center', valign: 'middle', img: t.options.imgPath + '26/mt_mb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 90},
								{isCenterMiddle: true},
								{width: 90}
							]
						}
					},
					{
						id: 27,
						name: Lang.get('appearancetemplates.blots'),
						background: '#ffffff',
						color: '#000000',
						themeId: 5,
						topRow: {
							cells: [
								{width: 109, height: 51, align: 'left', img: t.options.imgPath + '27/lt.gif'},
								{width: '100%'},
								{width: 61, align: 'right', img: t.options.imgPath + '27/rt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 82, align: 'left', valign: 'bottom', img: t.options.imgPath + '27/lb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 109, align: 'left', valign: 'top', img: t.options.imgPath + '27/lm.gif'},
								{isCenterMiddle: true},
								{width: 61, align: 'right', valign: 'top', img: t.options.imgPath + '27/rm.gif'}
							]
						}
					},
					{
						id: 28,
						name: Lang.get('appearancetemplates.prehistoric'),
						background: '#c1bdb6',
						color: '#4e4037',
						fontFamily: 'Comic Sans MS',
						themeId: 3,
						topRow: {
							cells: [
								{width: 476, height: 177, align: 'left', valign: 'top', img: t.options.imgPath + '28/lt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 80}
							]
						},
						middleRow: {
							cells: [
								{width: 150},
								{isCenterMiddle: true},
								{width: 120}
							]
						}
					},
					{
						id: 29,
						name: Lang.get('appearancetemplates.hammer_and_sickle'),
						background: '#c00c0c',
						color: '#ffe55b',
						fontFamily: 'courier',
						themeId: 6,
						topRow: {
							cells: [
								{width: 115, height: 135, align: 'left', valign: 'middle', img: t.options.imgPath + '29/lt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 80}
							]
						},
						middleRow: {
							cells: [
								{width: 150},
								{isCenterMiddle: true},
								{width: 120}
							]
						}
					},
					{
						id: 30,
						name: Lang.get('appearancetemplates.pattern'),
						background: '#ffffff',
						color: '#000000',
						fontFamily: 'Trebuchet MS',
						themeId: 7,
						topRow: {
							cells: [
								{width: '100%'},
								{width: 287, height: 97, align: 'right', valign: 'top', img: t.options.imgPath + '30/rt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: 145, height: 85, align: 'left', img: t.options.imgPath + '30/lb.gif'},
								{width: '100%'}
							]
						},
						middleRow: {
							cells: [
								{width: 145, align: 'left', valign: 'bottom', img: t.options.imgPath + '30/lm.gif'},
								{isCenterMiddle: true},
								{width: 120}
							]
						}
					},
					{
						id: 31,
						name: Lang.get('appearancetemplates.diamonds'),
						disabled: true,
						background: '#3f273f',
						color: '#ffffff',
						fontFamily: 'arial',
						themeId: 7,
						topRow: {
							cells: [
								{width: '100%', height: 125, align: 'center', valign: 'middle', img: t.options.imgPath + '31/mt_mb.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 125, align: 'center', valign: 'middle', img: t.options.imgPath + '31/mt_mb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 100},
								{isCenterMiddle: true},
								{width: 100}
							]
						}
					},
					{
						id: 32,
						name: Lang.get('appearancetemplates.high_grass'),
						background: '#ffffff',
						color: '#70950d',
						fontFamily: 'georgia',
						themeId: 3,
						topRow: {
							cells: [
								{width: '100%'},
								{width: 152, height: 43, align: 'right', img: t.options.imgPath + '32/rt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 56, align: 'left', img: t.options.imgPath + '32/lb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 130, align: 'left', valign: 'bottom', img: t.options.imgPath + '32/lm.gif'},
								{isCenterMiddle: true},
								{width: 152, align: 'right', valign: 'top', img: t.options.imgPath + '32/rm.gif'}
							]
						}
					},

					{
						id: 33,
						name: Lang.get('appearancetemplates.book'),
						background: '#ddc182',
						color: '#411800',
						fontFamily: 'georgia',
						themeId: 7,
						topRow: {
							cells: [
								{width: '100%', height: 111, align: 'center', valign: 'middle', img: t.options.imgPath + '33/mt_mb.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 111, align: 'center', valign: 'middle', img: t.options.imgPath + '33/mt_mb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 90},
								{isCenterMiddle: true},
								{width: 70}
							]
						}
					},
					{
						id: 35,
						name: Lang.get('appearancetemplates.manuscript'),
						background: '#ffffff',
						color: '#000000',
						fontFamily: 'arial',
						themeId: 1,
						topRow: {
							cells: [
								{width: '100%'},
								{width: 611, height: 90, align: 'right', valign: 'top', img: t.options.imgPath + '35/rt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 75, align: 'left', valign: 'bottom', img: t.options.imgPath + '35/lb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 75},
								{isCenterMiddle: true},
								{width: 60}
							]
						}
					},
					{
						id: 36,
						name: Lang.get('appearancetemplates.exercise_book'),
						background: '#ffffff',
						color: '#000000',
						fontFamily: 'times new roman',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%'},
								{width: 611, height: 90, align: 'right', valign: 'top', img: t.options.imgPath + '36/rt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 75, align: 'left', valign: 'bottom', img: t.options.imgPath + '36/lb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 75},
								{isCenterMiddle: true},
								{width: 60}
							]
						}
					},
					{
						id: 37,
						name: Lang.get('appearancetemplates.greek_style'),
						background: '#faf4cb',
						color: '#102501',
						fontFamily: 'palatino linotype',
						fontStyle: 'italic',
						themeId: 7,
						topRow: {
							cells: [
								{width: '100%'},
								{width: 241, height: 156, align: 'right', valign: 'top', img: t.options.imgPath + '37/rt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', background: t.options.imgPath + '37/bbg.gif'},
								{width: 283, height: 93, align: 'right', valign: 'bottom', img: t.options.imgPath + '37/rb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 130},
								{isCenterMiddle: true},
								{width: 118, align: 'right', valign: 'top', background: t.options.imgPath + '37/rbg.gif'}
							]
						}
					},
					{
						id: 38,
						name: Lang.get('appearancetemplates.labirynth'),
						background: '#f6e5c3',
						color: '#4e3509',
						textAlign: 'center',
						fontFamily: 'CenturyGothic',
						themeId: 7,
						topRow: {
							cells: [
								{width: '100%', height: 70}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 113, align: 'left', valign: 'bottom', background: '#f9ebcd', img: t.options.imgPath + '38/lb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 100},
								{isCenterMiddle: true},
								{width: 100}
							]
						}
					},
					{
						id: 39,
						name: Lang.get('appearancetemplates.invitation1'),
						background: '#e5ffd3',
						color: '#859e7f',
						textAlign: 'center',
						fontFamily: 'MonotypeCorsiva',
						fontStyle: 'italic',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 95, align: 'center', valign: 'middle', img: t.options.imgPath + '39/mt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 75, align: 'center', valign: 'middle', img: t.options.imgPath + '39/mb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 100},
								{isCenterMiddle: true},
								{width: 100}
							]
						}
					},
					{
						id: 40,
						name: Lang.get('appearancetemplates.invitation1'),
						background: '#f4d7ff',
						color: '#72667c',
						textAlign: 'center',
						fontFamily: 'MonotypeCorsiva',
						fontStyle: 'italic',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 95, align: 'center', valign: 'bottom', img: t.options.imgPath + '40/mt.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 50, align: 'center', valign: 'middle', img: t.options.imgPath + '40/mb.gif'}
							]
						},
						middleRow: {
							cells: [
								{width: 100},
								{isCenterMiddle: true},
								{width: 100}
							]
						}
					},
					{
						id: 41,
						name: Lang.get('appearancetemplates.green_form'),
						background: '#edfaf4',
						color: '#67898b',
						textAlign: 'center',
						fontFamily: 'CenturyGothic',
						themeId: 7,
						topRow: {
							cells: [
								{height: 1}
							]
						},
						bottomRow: {
							cells: [
								{height: 1}
							]
						},
						middleRow: {
							cells: [
								{width: 20},
								{isCenterMiddle: true, paddingBottom: 30},
								{width: 60, align: 'right', valign: 'bottom', img: t.options.imgPath + '41/bgm.gif'},
								{width: 114, align: 'right', valign: 'bottom', background: '#d9e9e2', img: t.options.imgPath + '41/rb.gif'}
							]
						}
					},
					{
						id: 50,
						name: Lang.get('appearancetemplates.cat_on_tree'),
						background: '#ffffff',
						color: '#5d8f0f',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 2,
						topRow: {
							cells: [
								{width: '100%', height: 25, align: 'right', img: t.options.imgPath + '50/rtc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 116, align: 'left', img: t.options.imgPath + '50/lbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 30},
								{isCenterMiddle: true},
								{width: 142, valign: 'top', align: 'right', img: t.options.imgPath + '50/rt.gif'}
							]
						}
					},
					{
						id: 51,
						name: Lang.get('appearancetemplates.watercolor'),
						background: '#ffffff',
						color: '#c1876c',
						textAlign: 'left',
						fontFamily: 'Georgia',
						themeId: 2,
						topRow: {
							cells: [
								{width: '100%', height: 34, align: 'right', img: t.options.imgPath + '51/rtc.gif'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: '100%', height: 100, align: 'left', img: t.options.imgPath + '51/lbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 64, valign: 'bottom', align: 'left', img: t.options.imgPath + '51/lb.gif'},
								{isCenterMiddle: true},
								{width: 162, valign: 'top', align: 'right', img: t.options.imgPath + '51/rt.gif'}
							]
						}
					},
					{
						id: 44,
						name: Lang.get('appearancetemplates.grandfather'),
	//					disabled: true,
						background: '#a7c5ff',
						color: '#330066',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 5,
						topRow: {
							cells: [
								{width: 286, height: 110, align: 'left', img: t.options.imgPath + '44/ltc.jpg'},
								{width: '100%', align: 'right', img: t.options.imgPath + '44/rtc.jpg'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: 286, height: 56, align: 'left', img: t.options.imgPath + '44/lbc.jpg'},
								{width: '100%', align: 'left', img: t.options.imgPath + '44/bc.jpg', background: t.options.imgPath + '44/bcbg.jpg'},
								{width: 59, align: 'center', img: t.options.imgPath + '44/rbc.jpg'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 286, valign: 'bottom', align: 'left', img: t.options.imgPath + '44/lc.jpg'},
								{isCenterMiddle: true},
								{width: 40}
							]
						}
					},
					{
						id: 43,
						name: Lang.get('appearancetemplates.christmas_toys'),
	//					disabled: true,
						background: '#00468c',
						color: '#ffffff',
						textAlign: 'left',
						fontFamily: 'Tahoma',
						themeId: 5,
						topRow: {
							cells: [
								{width: 279, height: 72, align: 'left', valign: 'top', img: t.options.imgPath + '43/ltc.jpg'},
								{width: '100%', height: 72, align: 'right', img: t.options.imgPath + '43/rtc.jpg'}
							],
							valign: 'top'
						},
						bottomRow: {
							cells:  [
								{width: 105, height: 45, align: 'left', img: t.options.imgPath + '43/lbc.jpg'},
								{width: '100%', height: 45, align: 'center', img: t.options.imgPath + '43/bc.jpg'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 105, valign: 'bottom', align: 'left', img: t.options.imgPath + '43/lc.jpg'},
								{isCenterMiddle: true},
								{width: 115, valign: 'top', align: 'right', img: t.options.imgPath + '43/rc.jpg'}
							]
						}
					},
					{
						id: 46,
						name: Lang.get('appearancetemplates.winter'),
	//					disabled: true,
						background: '#54abe0',
						color: '#ffffff',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 5,
						topRow: {
							cells: [
								{width: 94, height: 63, align: 'left', img: t.options.imgPath + '46/ltc.gif'},
								{width: '100%', background: t.options.imgPath + '46/tcbg.gif'},
								{width: 110, align: 'right', img: t.options.imgPath + '46/rtc.gif'}
							]
						},
						bottomRow: {
							cells: [
								{height: '30px'}
							]
						},
						middleRow: {
							cells: [
								{width: 94, valign: 'top', align: 'left', img: t.options.imgPath + '46/lc.gif'},
								{isCenterMiddle: true},
								{width: 110, valign: 'top', align: 'right', img: t.options.imgPath + '46/rc.gif'}
							]
						}
					},
					{
						id: 47,
						name: Lang.get('appearancetemplates.panorama'),
	//					disabled: true,
						background: '#f6fcff',
						color: '#4b6e88',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 5,
						topRow: {
							cells: [
								{width: 110, height: 54, align: 'left', img: t.options.imgPath + '47/ltc.gif'},
								{width: '100%', align: 'center', valign: 'top', img: t.options.imgPath + '47/tc.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: 118, height: 89, align: 'left', img: t.options.imgPath + '47/lbc.gif'},
								{width: '100%', background: t.options.imgPath + '47/bcbg.gif'},
								{width: 478, align: 'right', img: t.options.imgPath + '47/rbc.gif'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 60},
								{isCenterMiddle: true},
								{width: 50}
							]
						}
					},
					{
						id: 48,
						name: Lang.get('appearancetemplates.balls'),
	//					disabled: true,
						background: '#ffaa00',
						color: '#000000',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 5,
						topRow: {
							cells: [
								{width: '100%', height: 51, align: 'right', img: t.options.imgPath + '48/rtc.gif'}
							]
						},
						bottomRow: {
							cells:  [
								{width: 50}
							]
						},
						middleRow: {
							cells: [
								{width: 30},
								{isCenterMiddle: true},
								{width: 130, align: 'right', valign: 'top', img: t.options.imgPath + '48/rc.gif'}
							]
						}
					},
					{
						id: 45,
						name: Lang.get('appearancetemplates.snowflakes'),
						background: '#84cff0',
						color: '#ffffff',
						textAlign: 'left',
						fontFamily: 'Arial',
						themeId: 5,
						topRow: {
							cells: [
								{height: 30}
							]
						},
						bottomRow: {
							cells:  [
								{width: 164, height: 66, align: 'left', img: t.options.imgPath + '45/lbc.jpg'},
								{width: '100%', align: 'left', img: t.options.imgPath + '45/bc.jpg'}
							],
							valign: 'bottom'
						},
						middleRow: {
							cells: [
								{width: 164, valign: 'bottom', align: 'left', img: t.options.imgPath + '45/lc.jpg'},
								{isCenterMiddle: true},
								{width: 40}
							]
						}
					}
				];
			}
		},

		getTemplates: function() {
			return mailru.lang['compose_appearance'];
		}
	});

})(jQuery);

jsLoader.loaded('{mailru.compose}mailru.Compose.AppearanceTemplates', 1);
 

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.AppearanceTemplates.js end

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.AppearanceChanger.js start

(function($)
{
	/**
	 * @class mailru.Compose.AppearanceChanger
	 */
	jsClass
	.create('mailru.Compose.AppearanceChanger')
	.methods({

		__construct: function(options)
		{
			var t = this;

			$.extend(t, options);

			t.heightOffset = 0;
		},

		unactive: function()
		{
		},

		clear: function()
		{
			var t = this;
			t.setTemplate({});
		},

		setTemplate: function(template)
		{
			var t = this;
			t._clearRows();

			if (/\.(gif|jpg|png|bmp)$/i.test(template.background))
			{
				t.$mainTable.attr('background', template.background);
			}
			else if (template.background)
			{
				t.$mainTable.attr('bgColor', template.background);
			}
			else
			{
				t.$mainTable.attr({
					'background': '',
					'bgColor': ''
				});
			}

			t._appendRows(template);
		},

		getHeightOffset: function()
		{
			var t = this;
			return t.heightOffset;
		},

		getWidthOffset: function()
		{
			var t = this;
			var width = 0;
			t.$middleRow.children().each($.proxy(function(i, cell)
			{
				if (cell != this.$mainCellHolder[0])
					width += cell.offsetWidth;
			}, t));
			return width;
		},

		_clearRows: function()
		{
			var t = this;

			t.$mainCellHolder.removeAttr('height');

			t.$paddingTopCell.attr('height', 1);
			t.$paddingBottomCell.attr('height', 1);

			t.heightOffset = 0;

			$.each([t.$topRow, t.$bottomRow, t.$middleRow], $.proxy(function(i, $row)
			{
				$($row).children().each($.proxy(function(i, cell)
				{
					var $cell = $(cell);
					if ($cell[0] != this.$mainCellHolder[0])
						$cell.remove();
				}, this));
			}, t));
		},

		_appendRows: function(template)
		{
			var t = this;
			var rows = [t.$topRow, t.$bottomRow, t.$middleRow], rows_sh = [];

			if (template.topRow)
				rows_sh.push(template.topRow);

			if (template.bottomRow)
				rows_sh.push(template.bottomRow);

			if (template.middleRow)
				rows_sh.push(template.middleRow);

			var mainCellPos = 1;
			if (template.middleRow)
			{
				$.each(template.middleRow.cells, function(i, cell_data)
				{
					if (cell_data.isCenterMiddle)
						mainCellPos = i;
				});
			}

			$.each(rows_sh, $.proxy(function(i, row_data)
			{
				var t = this;
				var $row = rows[i];

				if (row_data.align)
					$row.attr('align', row_data.align).css('textAlign', row_data.align);

				if (row_data.valign)
					$row.attr('vAlign', row_data.valign).css('verticalAlign', row_data.valign);

				if (row_data.background)
					$row.attr('bgColor', row_data.background);

				$.each(row_data.cells, $.proxy(function(i, cell_data)
				{
					var t = this;
					var $cell = $('<td/>').addClass('cell');

					if (cell_data.width)
						$cell.attr('width', cell_data.width);

					if (cell_data.height)
						$cell.attr('height', cell_data.height);

					if (cell_data.align)
						$cell.attr('align', cell_data.align).css('textAlign', cell_data.align);

					if (cell_data.valign)
						$cell.attr('vAlign', cell_data.valign).css('verticalAlign', cell_data.valign);

					if (/\.(gif|jpg|png|bmp)$/.test(cell_data.background))
					{
						$cell.attr('background', cell_data.background);
					}
					else if (cell_data.background)
					{
						$cell.attr('bgColor', cell_data.background);
					}

					if (cell_data.img)
					{
						var $img = $('<img title="" alt=""/>').attr('src', cell_data.img);

						if ($.browser.msie && parseInt($.browser.version) < 7)
						{
							if (/\.png($|\?)/i.test(cell_data.img))
							{
								$img.attr('src', '//img.' + mailru.staticDomainName + '/0.gif');
								$img[0].style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + cell_data.img + "',sizingMethod='scale')";
							}
						}

						if (/\.png($|\?)/i.test(cell_data.img))
							$img.addClass('png');

						if (cell_data.imgWidth)
							$img.attr('width', cell_data.imgWidth);

						if (cell_data.imgHeight)
							$img.attr('height', cell_data.imgHeight);

						if (cell_data.imgPrintVisible)
							$img.addClass('visible-' + cell_data.imgPrintVisible);

						if (cell_data.align)
							$img.attr('align', cell_data.align).css('textAlign', cell_data.align);

						$cell.append($img);
					}

					if (cell_data.HTML)
						$cell.html(cell_data.HTML);

					if ($row[0] == t.$middleRow[0] && cell_data.isCenterMiddle)
					{
						if (cell_data.paddingTop)
							t.$paddingTopCell.attr('height', cell_data.paddingTop);

						if (cell_data.paddingBottom)
							t.$paddingBottomCell.attr('height', cell_data.paddingBottom);
					}

					if (!cell_data.isCenterMiddle)
					{
						if ($row[0] == t.$middleRow[0] && i < mainCellPos)
						{
							$cell.insertBefore(t.$mainCellHolder);
						}
						else
						{
							$row.append($cell);
						}
					}

				}, t));

				if ($row[0] != t.$middleRow[0])
					t.heightOffset += $row[0].offsetHeight;

			}, t));
		}
	});

})(jQuery);

jsLoader.loaded('{mailru.compose}mailru.Compose.AppearanceChanger', 1);
 

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.AppearanceChanger.js end

(function($)
	{
		var $win = $(window);

		/**
		 * @class mailru.Compose.Appearance
		 */
		jsClass
		.create('mailru.Compose.Appearance')
		.extend(jQueryEvent)
		.statics({

			defaultOptions: {

				templateClassPrefix: 'mlruTmpId',
				templates: []
			}
		})
		.methods({

			__construct: function($frame, options)
			{
				var t = this;

				t.options = $.extend({}, mailru.Compose.Appearance.defaultOptions, options);

				var domIDs	= t.options.domIDs;

				t.$frame = $($frame);
				t.$container = $(domIDs.composeTemplatesContainer);

				t.$prev = $('.prev', t.$container);
				t.$next = $('.next', t.$container);
				t.$listFrame = $('.listFrame', t.$container);
				t.$list = $('.list', t.$container)
					.bind('click', $.proxy(t._listClick, t))
					.bind('DOMMouseScroll mousewheel', $.proxy(t._listMouseWheel, t));

				t.$topRow = $(domIDs.topRow_sht);
				t.$bottomRow = $(domIDs.bottomRow_sht);
				t.$middleRow = $(domIDs.middleRow_sht);
				t.$middleTable = $(domIDs.middleTable);
				t.$mainTable = $(domIDs.shell__text);
				t.$mainCell = $(domIDs.shell__text_cell);
				t.$mainCellHolder = $(domIDs.shell__text_cell_holder);
				t.$paddingTopCell = $(domIDs.paddingTop_sht);
				t.$paddingBottomCell = $(domIDs.paddingBottom_sht);

				t.templateMap = {};
				t.themesMap = {};

				t.layerVisible = false;

				t.listFrameHeight = 0;

				t._initList();

				t.$prev.add(t.$next)
					.bind('mousedown', $.proxy(t._controlMouseDown, t))
					.bind('click', $.proxy(t._controlClick, t));

				t.changer = new mailru.Compose.AppearanceChanger({
					'$topRow': t.$topRow,
					'$bottomRow': t.$bottomRow,
					'$middleRow': t.$middleRow,
					'$mainTable': t.$mainTable,
					'$mainCell': t.$mainCell,
					'$mainCellHolder': t.$mainCellHolder,
					'$paddingTopCell': t.$paddingTopCell,
					'$paddingBottomCell': t.$paddingBottomCell
				});
			},

			unactive: function()
			{
			},

			reset: function()
			{
				var t = this;
				t.clear();
				t.hideLayer();
			},

			_listMouseWheel: function(evt)
			{
				var t = this;
				var delta = 0;

				if (evt.wheelDelta) delta = evt.wheelDelta/120;
				if (evt.detail) delta = -evt.detail/3;

				t._mouseWheelSlide(delta < 0);

				evt.preventDefault();
			},

			_listClick: function(evt)
			{
				var t = this;
				var $target = $(evt.target);
				if ($target.is('a'))
				{
					var id = $target.data('id');
					if (!id)
					{
						id = $onClick(evt.target);
						$target.data('id', id);
					}
					$win.triggerHandler('editorToolbarButtonStyleChangeClick.compose');
					t.setTemplate(id);
				}

				evt.preventDefault();
			},

			_controlClick: function(evt)
			{
				evt.preventDefault();
			},

			_controlMouseUp: function(evt)
			{
				var t = this;
				t.$list.stop();
				t._updateControlsClasses();
				t.$prev.removeClass('prev-down');
				t.$next.removeClass('next-down');
				$(document).unbind('mouseup', arguments.callee);
			},

			_controlMouseDown: function(evt)
			{
				var t = this;
				var $target = $(evt.target);
				$target.addClass($target.is('.prev') ? 'prev-down' : 'next-down');
				t.$prev.removeClass('prev-disabled');
				t.$next.removeClass('next-disabled');
				t._slide($target.is('.next'));
				$(document).mouseup($.proxy(t._controlMouseUp, t));
			},

			_slide: function(down)
			{
				var t = this;
				var speed = 5000;
				var listHeight = t.getListHeight();
				var frameHeight = t.getListFrameHeight();
				if (listHeight > frameHeight)
				{
					var y = t.getListOffsetY();
					var duration = (listHeight + frameHeight) / speed;
					var distanceTop = listHeight - (down ? frameHeight - y : y + listHeight);
					var newDuration = distanceTop / duration;

					t.$list.stop().animate({
						top: down ? frameHeight - listHeight : 0
					}, newDuration, 'linear', $.proxy(t._updateControlsClasses, t));
				}
			},

			_mouseWheelSlide: function(down)
			{
				var t = this;
				var speed = 100;
				var listHeight = t.getListHeight();
				var frameHeight = t.getListFrameHeight();
				if (listHeight > frameHeight)
				{
					var y = t.getListOffsetY();
					var minY = frameHeight - listHeight;
					var maxY = 0;

					t.$list.stop().animate({
						top: down ? Math.max(minY, y - frameHeight) : Math.min(maxY, y + frameHeight)
					}, speed, $.proxy(t._updateControlsClasses, t));
				}
			},

			_updateControlsClasses: function()
			{
				var t = this;
				var listHeight = t.getListHeight();
				var frameHeight = t.getListFrameHeight();
				var y = t.getListOffsetY();
				t.$prev.toggleClass('prev-disabled', y >= 0);
				t.$next.toggleClass('next-disabled', y <= frameHeight - listHeight);
			},

			_initList: function() {
				if (mailru.IsNewComposeDesign) {
					$.each(this.getTemplates().categories, $.proxy(function(i, category) {
						$.each(category.items, $.proxy(function(i, item) {
							this.templateMap[item.id] = item;
							if (!this.themesMap[category.id]) {
								this.themesMap[category.id] = [];
							}
							this.themesMap[category.id].push(item);
						}, this));
					}, this));
				} else {
					$.each(this.getTemplates(), $.proxy(function(i, template) {
						this.templateMap[template.id] = template;
						if (!this.themesMap[template.themeId]) {
							this.themesMap[template.themeId] = [];
						}
						this.themesMap[template.themeId].push(template);
					}, this));
				}
			},

			getMiddleTable: function()
			{
				var t = this;
				return t.$middleTable;
			},

			getMiddleRow: function()
			{
				var t = this;
				return t.middleRow;
			},

			getMainCell: function()
			{
				var t = this;
				return t.$mainCell;
			},

			getMainCellHolder: function()
			{
				var t = this;
				return t.$mainCellHolder;
			},

			getMainTable: function()
			{
				var t = this;
				return t.$mainTable;
			},

			getHTML: function(content)
			{
				var t = this;
				var template = t.getCurrentTemplate();
				if (template)
				{
					var html = '<font size="2" face="' + (template.fontFamily || '') + '" color="' + (template.color || '') + '">' + content + '</font>';
					var $clone = t.$frame.clone();
					var $mainCell = $('#' + t.$mainCell.attr('id'), $clone);
					var $mainCellHolder = $('#' + t.$mainCellHolder.attr('id'), $clone);
					$mainCell.attr('align', template.textAlign || '').html(html);
					$mainCellHolder.removeAttr('height');
					return $clone.html();
				}
				return content;
			},

			getTemplateId: function(content)
			{
				var t = this;
				var templateId = 0;
				var $node = $('<div>' + content + '</div>');

				var $mainHtmlCell = $(t.options.domIDs.main_html_cell, $node);
				if ($mainHtmlCell.length)
				{
					templateId = $mainHtmlCell.attr('template_id');
				}
				else
				{
					var $mainTable = $('#' + t.$mainTable.attr('id'), $node);
					if ($mainTable.length)
					{
						var templateIdPattern = new RegExp(t.options.templateClassPrefix + '(\\d+)');
						var className = $mainTable[0].className;
						if (templateIdPattern.test(className))
							templateId = className.match(templateIdPattern)[1];
					}
				}
				return templateId;
			},

			removeTemplate: function(content)
			{
				var t = this;
				var $node = $('<div>' + content + '</div>');
				var $mainTable = $('#' + t.$mainTable.attr('id'), $node);

				if ($mainTable.length)
				{
					var $innerNode = $(t.options.domIDs.main_html_cell +' > font:first, #'+ t.$mainCell.attr('id') + ' > font:first', $mainTable);

					if ($innerNode.length)
						$mainTable.replaceWith($innerNode.html());
				}

				return $node.html();
			},

			setListFrameHeight: function(height)
			{
				var t = this;
				t.listFrameHeight = height;

				if (t.isLayerVisible())
				{
					var listHeight = t.getListHeight();
					var y = t.getListOffsetY();

					t.$listFrame.css('height', height);

					if (height - y - listHeight > 0)
						t.$list.css('top', height - listHeight);

					t._updateControlsClasses();
				}
			},

			applyTheme: function(themeId)
			{
				var t = this;
				var html = '';
				html += '<a href="javascript:void(0);" title="' + Lang.get('compose.appearance_without_style') + '" class="empty" onclick="return 0;">' + Lang.get('compose.appearance_without_style') + '</a>';
				$.each(t.getTemplatesByThemeId(themeId), $.proxy(function(i, template)
				{
					if (!template.disabled)
						html += '<a href="javascript:void(0);" title="' + template.name + '" onclick="return ' + template.id + ';" style="background-position: ' + (-68 * (template.id - 1)) + 'px 0;"></a>';

				}, t));
				t.$list.css('top', 0).html(html);
				t._updateControlsClasses();
			},

			showLayer: function()
			{
				var t = this;
				t.layerVisible = true;
				t.$container.show();
				t.setListFrameHeight(t.getListFrameHeight());
				t.triggerHandler('showLayer');
			},

			hideLayer: function()
			{
				var t = this;
				t.layerVisible = false;
				t.$container.hide();
				t.triggerHandler('hideLayer');
			},

			isLayerVisible: function()
			{
				var t = this;
				return t.layerVisible;
			},

			getTemplates: function()
			{
				return mailru.Compose.AppearanceTemplates.getInstance().getTemplates();
			},

			getTemplatesByThemeId: function(themeId)
			{
				var t = this;
				return t.themesMap[themeId] || t.getTemplates();
			},

			getTemplateById: function(id)
			{
				var t = this;
				return t.templateMap[id];
			},

			getCurrentTemplate: function()
			{
				var t = this;
				return t.currentTemplate;
			},

			getHeightOffset: function()
			{
				var t = this;
				return t.getCurrentTemplate() ? t.changer.getHeightOffset() : 0;
			},

			getListOffsetY: function()
			{
				var t = this;
				return parseInt(t.$list.css('top'));
			},

			getListHeight: function()
			{
				var t = this;
				return t.$list.height();
			},

			getListFrameHeight: function()
			{
				var t = this;
				return t.listFrameHeight;
			},

			getWidthOffset: function()
			{
				var t = this;
				return t.getCurrentTemplate() ? t.changer.getWidthOffset() : 0;
			},

			getMainCellHeight: function()
			{
				var t = this;
				return t.changer.getMainCellHeight();
			},

			setTemplate: function(id)
			{
				var t = this;
				var template = t.getTemplateById(id);
				if (template)
				{
					t.$mainTable[0].className = t.options.templateClassPrefix + id;
					t.changer.setTemplate(template);
					t.currentTemplate = template;
					t.triggerHandler('changeTemplate', [template]);
				}
				else
				{
					t.clear();
				}
			},

			clear: function()
			{
				var t = this;
				t.$mainTable[0].className = t.options.templateClassPrefix + '0';
				t.currentTemplate = null;
				t.changer.clear();
				t.triggerHandler('clear');
			}
		});

	})(jQuery);

	jsLoader.loaded('{mailru.compose}mailru.Compose.Appearance', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.Appearance.js end

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.Decoration.js start


// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.DecorationAppearance.js start


// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.DecorationSlider.js start


/**
	 * @class mailru.Compose.DecorationSlider
	 */
	jsClass
	.create('mailru.Compose.DecorationSlider')
	.extend(jQueryEvent)
	.statics({
		defaultOptions: {
		}
	})
	.methods({

		__construct: function($container, options) {

			this.options = $.extend({}, mailru.Compose.DecorationSlider.defaultOptions, options);

			this.$document = $(document);
			this.$container = $($container);

			this.itemClickObserver = this._itemClick.bind(this);
			this.controlMouseDownObserver = this._controlMouseDown.bind(this);
			this.controlMouseUpObserver = this._controlMouseUp.bind(this);
			this.controlClickObserver = this._controlClick.bind(this);
			this.listMouseWheelObserver = this._listMouseWheel.bind(this);
		},

		initialize: function () {
			this.$inner = $('.js-inner', this.$container);
			this.$list = $('.js-list', this.$container);
			this.$prev = $('.js-prev', this.$container);
			this.$next = $('.js-next', this.$container);

			this.$list.delegate('.js-clear', 'click', this.controlClickObserver);
			this.$list.delegate('.js-item', 'click', this.itemClickObserver);

			this.$container.bind('DOMMouseScroll mousewheel', this.listMouseWheelObserver);

			this.$container.delegate('.js-prev,.js-next', 'mousedown', this.controlMouseDownObserver);
		},

		show: function () {
		},

		hide: function () {
		},

		setCategory: function (category) {
			var y = 0, $category = $('.js-category:eq(' + category + ')', this.$list);
			if (category > 0) {
				y = -$category[0].offsetTop;
			}
			this.$list.css('top', y);
			this._slideEnd();
		},

		getListHeight: function () {
			return this.$list.height();
		},

		getWrapHeight: function () {
			return this.$inner.height();
		},

		getListOffset: function () {
			return parseInt(this.$list.css('top')) || 0;
		},

		_itemClick: function (evt) {
			var $item = $(evt.target).closest('.js-item', this.$list);
			this.triggerHandler('select', [$item.data('category'), $item.data('item')]);
			evt.preventDefault();
		},

		_controlMouseDown: function (evt) {
			var $control = $(evt.target).closest('.js-control', this.$inner);
			if ($control.hasClass('js-prev')) {
				this._slide(false);
			} else {
				this._slide(true);
			}
			this.$document.bind('mouseup', this.controlMouseUpObserver);
		},

		_controlClick: function (evt) {
			var $control = $(evt.target).closest('.js-control', this.$list);
			if ($control.hasClass('js-clear')) {
				this.triggerHandler('clear');
			}
		},

		_controlMouseUp: function (evt) {
			this.$list.stop();
			this.$document.unbind('mouseup', this.controlMouseUpObserver);
		},

		_slide: function (down) {
			var speed = 2000;
			var listHeight = this.getListHeight();
			var wrapHeight = this.getWrapHeight();
			var y = this.getListOffset();
			var margin = -y, to = 0;

			if (down) {
				margin = (listHeight - wrapHeight) + y;
				to = wrapHeight - listHeight;
			}

			var percent = 100 - (100 / (listHeight - wrapHeight) * margin);
			var newSpeed = speed - (percent * speed / 100);

			if (listHeight > wrapHeight) {
				if (y != to) {
					this.$list.stop().animate({
						top: to
					}, {
						duration: newSpeed,
						easing: 'linear',
						complete: this._slideEnd.bind(this),
						step: this._slideEnd.bind(this)
					});
				}
			}
		},

		_listMouseWheel: function(evt) {
			var delta = 0;
			if (evt.wheelDelta) delta = evt.wheelDelta/120;
			if (evt.detail) delta = -evt.detail/3;

			var listHeight = this.getListHeight();
			var wrapHeight = this.getWrapHeight();
			var y = this.getListOffset();
			var newY = Math.min(0, Math.max((y + (delta * 100)), wrapHeight - listHeight));

			if (listHeight > wrapHeight) {
				if (y != newY) {
					this.$list.stop().css('top', newY);
					evt.preventDefault();
				}
			}

			this._slideEnd();
		},

		_slideEnd: function () {
			var y = this.getListOffset();
			var listHeight = this.getListHeight();
			var wrapHeight = this.getWrapHeight();
			this.$prev.css('opacity', +(y < 0));
			this.$next.css('opacity', +(y > wrapHeight - listHeight));
		}
	});

	jsLoader.loaded('{mailru.compose}mailru.Compose.DecorationSlider', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.DecorationSlider.js end

/**
	 * @class mailru.Compose.DecorationAppearance
	 */
	jsClass
	.create('mailru.Compose.DecorationAppearance')
	.extend(jQueryEvent)
	.statics({
		defaultOptions: {
			baseSrc: '//img.' + mailru.staticDomainName + '/r/default/compose/appearance',
			templateId: '#compose__decoration_ejs'
		}
	})
	.methods({

		__construct: function($container, options) {
			this.options = $.extend({}, mailru.Compose.DecorationAppearance.defaultOptions, options);

			this.$container = $('.js-decoration_appearance', $container);

			this.slider = new mailru.Compose.DecorationSlider(this.$container, options);

			this.slider.bind({
				clear: function (evt) {
					this.triggerHandler('clear');
				}.bind(this),
				select: function (evt, category, item) {
					this.selectedItem = this.data.categories[category].items[item];
					this.triggerHandler('select', [this.data.categories[category], this.selectedItem]);
				}.bind(this)
			});

			this.cardContainerId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
			this.cardMarkerId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
			this.cardId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
		},

		_initialize: function () {
			this.data = mailru.lang['compose_appearance'];

			$.each(this.data.categories, function (k, category) {
				$.each(category.items, function (k, item) {
					item.preview = item.id + '.png';
				}.bind(this));
				category.path = this.options.baseSrc;
			}.bind(this));

			this.$container.tpl(this.options.templateId, {
				type: 'appearance',
				Categories: this.data.categories
			});
			this.slider.initialize();
		},

		setCategory: function (category) {
			this.slider.setCategory(category);
		},

		show: function () {

			if (this.visible) return;

			if (!this.initialized) {
				this._initialize();
				this.initialized = 1;
			}

			this.$container.show();
			this.slider.show();
			this.visible = 1;
			this.triggerHandler('show');
		},

		hide: function () {
			if (!this.visible) return;
			this.$container.hide();
			this.slider.hide();
			this.visible = 0;
			this.triggerHandler('hide');
		}
	});

	jsLoader.loaded('{mailru.compose}mailru.Compose.DecorationAppearance', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.DecorationAppearance.js end

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.DecorationCards.js start


/**
	 * @class mailru.Compose.DecorationCards
	 */
	jsClass
	.create('mailru.Compose.DecorationCards')
	.extend(jQueryEvent)
	.statics({
		defaultOptions: {
			baseSrc: 'https://img.' + mailru.staticDomainName + '/r/default/compose/cards_v3',
			templateId: '#compose__decoration_ejs',
			previewTemplateId: '#compose__card__template_ejs'
		}
	})
	.methods({

		__construct: function($container, options) {
			this.options = $.extend({}, mailru.Compose.DecorationCards.defaultOptions, options);

			this.$container = $('.js-decoration_cards', $container);

			this.slider = new mailru.Compose.DecorationSlider(this.$container, options);

			this.slider.bind({
				clear: function (evt) {
					this.triggerHandler('clear');
				}.bind(this),
				select: function (evt, category, item) {
					this.selectedItem = this.data.categories[category].items[item];
					this.triggerHandler('select', [this.data.categories[category], this.selectedItem]);
				}.bind(this)
			});

			this.cardContainerId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
			this.cardMarkerId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
			this.cardId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
		},

		_initialize: function () {
			this.data = mailru.lang['compose_cards'];

			$.each(this.data.categories, function (k, category) {
				category.path = this.options.baseSrc + '/' + category.id;
			}.bind(this));

			this.$container.tpl(this.options.templateId, {
				type: 'cards',
				Categories: this.data.categories
			});
			this.slider.initialize();
		},

		setCategory: function (category) {
			this.slider.setCategory(category);
		},

		show: function () {

			if (this.visible) return;

			if (!this.initialized) {
				this._initialize();
				this.initialized = 1;
			}

			this.$container.show();
			this.slider.show();
			this.visible = 1;
			this.triggerHandler('show');
		},

		hide: function () {
			if (!this.visible) return;
			this.$container.hide();
			this.slider.hide();
			this.visible = 0;
			this.triggerHandler('hide');
		},

		getPreviewHTML: function (category, card) {
			var randomKey = Math.rand(0, category.cardTitles.length - 1);
			var title = category.cardTitles[randomKey];
			return $.tpl(this.options.previewTemplateId, {
				imgTitle: title,
				imgWidth: card.img.width,
				imgHeight: card.img.height,
				imgSrc: this.options.baseSrc + '/' + category.id + '/' + card.img.src,
				cardContainerId: this.cardContainerId,
				cardId: this.cardId,
				markerId: this.cardMarkerId
			});
		}
	});

	jsLoader.loaded('{mailru.compose}mailru.Compose.DecorationCards', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.DecorationCards.js end

/**
	 * @class mailru.Compose.Decoration
	 */
	jsClass
	.create('mailru.Compose.Decoration')
	.extend(jQueryEvent)
	.statics({
		defaultOptions: {
		}
	})
	.methods({

		__construct: function($form, options) {
			this.options = $.extend({}, mailru.Compose.Decoration.defaultOptions, options);
			this.$container = $('.js-decoration', $form);

			this.controlClickObserver = this._controlClick.bind(this);

			this.$container.delegate('.js-decoration_control_hide', 'click', this.controlClickObserver);

			this.items = {
				cards: new mailru.Compose.DecorationCards(this.$container, this.options),
				appearance: new mailru.Compose.DecorationAppearance(this.$container, this.options)
			};
		},

		show: function (type, category) {

			$.each(this.items, function (k, v) {
				v.hide();
			});

			if (this.visible) {
				this.items[type].show();
				this.items[type].setCategory(category);
			} else {
				this.$container.show();

				this.items[type].show();
				this.items[type].setCategory(category);

				this.visible = 1;
				this.triggerHandler('show');
			}
		},

		hide: function () {
			if (!this.visible) return;
			this.$container.hide();
			this.visible = 0;
			this.triggerHandler('hide');
		},

		setHeight: function (height) {
			this.$container.css('height', height);
		},

		getItem: function (type) {
			return this.items[type];
		},

		_controlClick: function (evt) {
			var $control = $(evt.target).closest('.js-decoration_control', this.$inner);
			if ($control.hasClass('js-decoration_control_hide')) {
				this.hide();
			}
		}
	});

	jsLoader.loaded('{mailru.compose}mailru.Compose.Decoration', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.Decoration.js end

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.Cards.js start


/**
		 * @class mailru.Compose.Cards
		 */
		jsClass
		.create('mailru.Compose.Cards')
		.extend(jQueryEvent)
		.statics({
			defaultOptions: {

				cardBaseSrc: '//img.' + mailru.staticDomainName + '/r/default/compose/cards_v2',

				templateId: '#compose__cards_ejs',
				previewTemplateId: '#compose__card__template_ejs',

				selectedItemClass: 'compose__cards__slider__item_selected',
				easing: 'swing',
				speed: 500,

				itemGeometry: {
					width: 68,
					height: 68
				}
			}
		})
		.methods({

			__construct: function($form, options) {

				this.options = $.extend({}, mailru.Compose.Cards.defaultOptions, options);
				this.data = mailru.lang['compose_cards'];
				this.$container = $('.js-cards', $form);

				this.cardContainerId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
				this.cardMarkerId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
				this.cardId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);

				this.categoryClickObserver = this._categoryClick.bind(this);
				this.cardClickObserver = this._cardClick.bind(this);
				this.controlClickObserver = this._controlClick.bind(this);

				this.$container.delegate('.js-category', 'click', this.categoryClickObserver);
				this.$container.delegate('.js-card', 'click', this.cardClickObserver);
				this.$container.delegate('.js-prev,.js-next,.js-hide', 'click', this.controlClickObserver);
				this.$container.delegate('.js-card,.js-prev,.js-next,.js-hide', 'mousedown', ajs.retFalse);

				this.selectedCategoryIndex = 0;
				this.selectedCardIndex = -1;

				this.itemCount = 0;
				this.offset = 0;
			},

			show: function () {

				if (this.visible) return;

				if (!this.drawed) {
					this._redraw();
					this.drawed = 1;
				}

				this.$container.show();

				this._update();

				this.visible = 1;
				this.triggerHandler('show');
			},

			hide: function () {
				if (!this.visible) return;
				this.$container.hide();
				this.visible = 0;
				this.triggerHandler('hide');
			},

			redraw: function () {
				this.cardContainerId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
				this.cardMarkerId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
				this.cardId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);
			},

			reset: function () {
				this.hide();
			},

			setSlide: function (index, animate) {

				var min = 0, max = this.cards.length - this.itemCount;

				if (this.cards.length > this.itemCount) {
					this.$prev.toggle(index > min);
					this.$next.toggle(index < max);
				} else {
					this.$prev.add(this.$next).hide();
				}

				if (this.cards.length > this.itemCount) {
					this.offset = index = Math.min(max, Math.max(index, min));
					var offset = -(index * this.options.itemGeometry.width);
					if (animate) {
						this.$list.animate({left: offset}, this.options.speed, this.options.easing);
					} else {
						this.$list.css('left', offset);
					}
				}
			},

			setSelected: function (index) {
				this.selectedCard = this.cards[index];
				this.selectedCardIndex = index;
				if (this.$previosSelected) {
					this.$previosSelected.removeClass(this.options.selectedItemClass);
				}
				this.$previosSelected = this.$list.find('.js-card:eq(' + index + ')').addClass(this.options.selectedItemClass);
			},

			resize: function () {
				if (this.visible) {
					this._update();
				}
			},

			getPreviewHTML: function (category, card) {
				var randomKey = Math.rand(0, category.cardTitles.length - 1);
				var title = category.cardTitles[randomKey];
				return $.tpl(this.options.previewTemplateId, {
					imgTitle: title,
					imgWidth: card.img.width,
					imgHeight: card.img.height,
					imgSrc: this.options.cardBaseSrc + '/' + category.id + '/' + card.img.src + '?4',
					cardContainerId: this.cardContainerId,
					cardId: this.cardId,
					markerId: this.cardMarkerId
				});
			},

			_redraw: function () {

				var selectedCategory = this.data.categories[this.selectedCategoryIndex];

				this.categories = this.data.categories;
				this.cards = selectedCategory.items;

				this.$container.tpl(this.options.templateId, {
					Categories: this.categories,
					Cards: this.cards,
					SelectedCategoryIndex: this.selectedCategoryIndex,
					SelectedCardIndex: this.selectedCardIndex,
					CardPreviewBaseUrl: this.options.cardBaseSrc + '/' + selectedCategory.id
				});

				this.$prev = $('.js-prev', this.$container);
				this.$next = $('.js-next', this.$container);
				this.$inner = $('.js-inner', this.$container);
				this.$list = $('.js-list', this.$container);
			},

			_update: function () {
				this.itemCount = Math.floor(this.$inner.css('width', '').width() / this.options.itemGeometry.width);
				this.$inner.css('width', this.options.itemGeometry.width * this.itemCount);
				this.setSlide(this.selectedCardIndex);
			},

			_categoryClick: function (evt) {
				var $target = $(evt.currentTarget);
				var index = $target.index();
				if (index != this.selectedCategoryIndex) {
					this.selectedCategoryIndex = index;
					this.setSlide(0);
					this.setSelected(-1);
					this._redraw();
					this._update();
				}
				evt.preventDefault();
			},

			_cardClick: function (evt) {
				var $target = $(evt.currentTarget);
				var index = $target.index();
				if (index != this.selectedCardIndex && this.cards[index]) {
					this.setSelected(index);
				}
				this.triggerHandler('click', [this.categories[this.selectedCategoryIndex], this.cards[this.selectedCardIndex]]);
				evt.preventDefault();
			},

			_controlClick: function (evt) {
				var $target = $(evt.currentTarget);
				if ($target.hasClass('js-hide')) {
					this.hide();
				} else if ($target.hasClass('js-prev')) {
					this.setSlide(this.offset - this.itemCount + 1, true);
				} else {
					this.setSlide(this.offset + this.itemCount - 1, true);
				}
				evt.preventDefault();
			}
		});

	jsLoader.loaded('{mailru.compose}mailru.Compose.Cards', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.Cards.js end

mailru.v2 && mailru.toolkit && mailru.toolkit['b-dropdown'] && mailru.toolkit.create('b-compose__head__switcher', 'b-dropdown', {
		/* nothing */
	});

	/** @namespace window.MCompose */
	/** @namespace mailru.UseFSentmsg */
	/** @namespace mailru.IsNewComposeDesign */
	/** @namespace mailru.EnableIMAP */
	/** @namespace String.preg_quote */

	(function($){
		var
			  $win = $(window), $doc = $(document)
			, _rurl717 = /https:[^"]+url717=/g
		;

		/**
		 * @class mailru.Compose.Form
		 */
		jsClass
		.create('mailru.Compose.Form')
		.extend(jQueryEvent)
		.statics({

			M_TEXT: 0,
			M_HTML: 1,

			defaultOptions: {
				autoSaveTimeout: 60000,
				updateEditorGeometryTimeout: 25,
				updateEditorFrameOnResizeTimeout: 25,
				enableSaveTimeout: 500,

				defaultEditorHeight: 436,
				minEditorHeight: 200,
				maxEditorHeight: 570,
				minEditorWithAppearanceHeight: 300,
				maxEditorWithAppearanceHeight: 570,

				hasFormattedPattern: /<(b|strong|em|i|font|u|strike|img)(\s|>)/i,
				issetContentPattern: /<(img)(\s|>)/i,

				resizeDisabled:	false
			},

			getActive: function () {
				var active_form;
				if (('MCompose' in window) && MCompose.isActive()) {
					active_form = MCompose;
				} else {
					var Forms = mailru.Compose.Form, Form, name;
					for (name in Forms) {
						if (Forms.hasOwnProperty(name)) {
							Form = Forms[name];
							if (Form && Form.isActive && Form.isActive()) {
								active_form = Form;
							}
						}
					}
				}
				return active_form;
			}
		})
		.methods({
			__construct: function(form, options)
			{
				var t = this;

				t.$form		= $(form);
				t.options	= $.extend({}, mailru.Compose.Form.defaultOptions, options);


				if( t.$form.attr('data-form-inited') ){
					// https://jira.mail.ru/browse/MAIL-15569
					mailru.gstat('COMPOSE-FORM-DOUBLE-INITED', void 0, 'cfdi');
				}

				t.$form.attr('data-form-inited', 'yes');
				mailru.log('compose.form.init', options);


				t.mobileVersion	= $.browser.operamini;
				t.deviceVersion	= tinyMCE.isIDevice || $.browser.operamobi;

				t.supportBeforeUnload = true;

				t.xhrs = {};
				t.timers = {};
				t.intervals = {};
				t.popups = {};
				t.attachFromFileSearch = {};
				t.attachFromFileSearchSizes = {};
				t.attachFromFileSearchSize = 0;

				t.RealNamesSignatures = [];

				if(t.options.RealNames) {
					$.each(t.options.RealNames, function (k, v) {
						if ($.trim(v.signature)) {
							t.RealNamesSignatures.push(v);
						}
					});
				}

				// MAIL-3843
				// opera need root container
				if (t.options.html && $.browser.opera) {
					t.options.html = '<div>' + t.options.html + '</div>';
				}

				t.sentmsgUrl = '/compose/'; // ajax-handler

				if (mailru.UseFSentmsg) {
					t.sentmsgUrl = '/fsentmsg';
				}

				t.validator = new mailru.Compose.FormValidator(t.$form);
				t.fileUploader = new mailru.Compose.FileUploader(t.$form, t.options.fileUploaderSettings, {
					  'name': t.options.name
					, 'domIDs': t.options.domIDs
					, 'liteVersion': t.mobileVersion
				});

				this.fileSearchManager = new mailru.ui.FileSearch({loadData: {folder_id: 0}, filesLimit: this.fileUploader.settings.MaxAttachments});

				t.cards = new mailru.Compose.Cards(form);

				t.decoration = new mailru.Compose.Decoration(form);

				this.beforeUnloadObserver = $.proxy(this.supportBeforeUnload ? this._onBeforeUnload : this._onBeforeUnloadFix, this);
				this.keyboardObserver = $.proxy(this._formKeyboard, this);

				mailru.v2 && this._iV2();

				t.bind('ready', function () {
					if ( !(this.isNew() || this.isForward()) ) {
						t.setCaretPositionInStart();
					}
					jsHistory.oneTop($.proxy(t.unactive, t));
					$win.triggerHandler('showForm.compose');
				});

				$('input[name="Priority"]', t.$form).click(function () {
					$win.triggerHandler('priorityCheckboxClick.compose');
				});

				$('input[name="Receipt"]', t.$form).click(function () {
					$win.triggerHandler('receiptCheckboxClick.compose');
				});

				t.oldEditorFlags = mailru.EditorFlags;

				if (mailru.IsNewComposeDesign) {
					if (mailru.EnableIMAP) {
						var compose__select_email      = $('.js-compose__select_email', this.$form);
						var compose__select_email_text = $('.dropdown__button-inline__text', compose__select_email);

						compose__select_email.dropdown({
							link: '.dropdown__button-inline',
							container: '.dropdown__list',
							onClick: function (event, dropdown) {
								var email = $(event.target).data('email') || mailru.useremail;

								compose__select_email_text.text(email);
								dropdown.hide();
							}
						});
					}

					if (this.fileUploader.uploaderHTML5) {
						t.fileSearchManager.bind('select', function (evt, files) {
							$.each(files, function (k, file) {
								file.partId = file.PartID;
								file.onlyPartId = true;
							});

							t.fileUploader.uploaderHTML5.one('attachFiles', function (evt, files) {

								var attachedSize = 0;
								$.each(files, function (k, file) {
									t.attachFromFileSearch[file.uid] = file.PartId;
									t.attachFromFileSearchSizes[file.uid] = file.size;
									attachedSize += file.size;
								});

								t.attachFromFileSearchSize += attachedSize;
								t.fileUploader.uploaderHTML5._spaceLeft -= attachedSize;

								var ids = [];
								$.each(t.attachFromFileSearch, function (k, partId) {
									ids.push(partId);
								});

								t._formElm('files_ids').val(ids.join(','));
							});

							t.fileUploader.attach(files);
						});

						this.fileUploader.uploaderHTML5.List.bind('remove', function (evt, uid) {
							delete t.attachFromFileSearch[uid];
							var size = t.attachFromFileSearchSizes[uid];
							if (size) {
								t.fileUploader.uploaderHTML5._spaceLeft += size;
								t.attachFromFileSearchSize -= size;
								delete t.attachFromFileSearchSizes[uid];
							}

							var ids = [];
							$.each(t.attachFromFileSearch, function (k, partId) {
								ids.push(partId);
							});
							t._formElm('files_ids').val(ids.join(','));
						});

						t.uploaderDropDown = $('.js-dropdown-uploader', this.$form).dropdown({
							hideByMousedown: true,
							hideByBlur: true,
							timeout: 0,
							link: '.js-dropdown',
							container: '.js-dropdown-list',
							onToggle: function(isOpen, dropdown){ // mail-11956
								Counter.sb(1345750);
								if( mailru.v2 ){
									mailru.toolkit.toggleMod(dropdown._node.find('.b-dropdown'), 'expanded', !!isOpen);
								}
							},
							onClick: function (evt, dropdown) {
								var $item = $(evt.target).closest('.js-filesearchlink', dropdown.$container);
								if ($item.length) {
									var spaceLeft = this.fileUploader.uploaderHTML5._spaceLeft;
									var filesCount = this.fileUploader.getFilesCount();
									this.fileSearchManager.show(spaceLeft, filesCount);
									Counter.sb(1345751);
									// hide dropdown
									dropdown.hide();
								}
								else {
									if ($.browser.opera || ($.browser.mozilla && $.browser.intVersion < 4)) {
										// mail-14457 don't hide dropdown until browse files dialog is closed
										// opera hacks
										setTimeout(function(){
											// wait for browse dialog is open
											$doc.one('mousemove', function(e){
												dropdown.hide();
											})
										}, 1000);
									} else {
										dropdown.hide();
									}
								}
							}.bind(this)
						}).dropdown('widget');
					}

					$('.js-dropdown-select-notify', this.$form).dropdown({
						link: '.dropdown__button-inline',
						container: '.dropdown__list',
						orientation: 'auto',
						onClick: function (evt, dropdown) {
							var $item = $(evt.target).closest('.dropdown__list__item', dropdown.$container);
							var itemValue = $('.dropdown__list__item__link__text', $item).text();
							var $mainLink = $('.dropdown__button-inline__text', dropdown.$link);
							var time = $item.data('time');
							if ($item.length) {
								if (time) {
									$mainLink.text(itemValue);
									this._formElm('remind').val(time);
								}
							}
							if(time == '3600') // mail-11956
								Counter.sb(1345741);
							else if (time == '7200')
								Counter.sb(1345742);
							else if (time == '86400')
								Counter.sb(1345744);
							else if (time == '172800')
								Counter.sb(1345747);
							else if (time == '432000')
								Counter.sb(1345749);

							dropdown.hide();
						}.bind(this)
					});
					this.updateNotify();

					this.$selectFieldsDropdown = $('.js-dropdown-select-fields', this.$form).dropdown({
						link: '.button-a',
						container: '.dropdown__list',
						orientation: 'auto',
						onToggle: function(isOpen, dropdown) {
							Counter.sb(1345721); // mail-11956
						},
						onClick: function (evt, dropdown) {

							var $item = $(evt.target).closest('.dropdown__list__item', dropdown.$container);
							var type = $item.data('type'), bit = parseInt($item.data('bit'));

							if (type) {

								var $row = $('.js-row-' + type, this.$form);

								var enabled = !$item.hasClass('dropdown__list__item__link_selected');

								if (enabled) {
									$row.show();
								} else {
									$row.hide();
									if(type == 'CC' || type == 'BCC') {
										// clear invisible fields
										$row.find('input[type="text"], textarea').val('');
										if (mailru.ComposeLabels) {
											var widget = $row.find('.js-compose-labels').first().composeLabels("widget")
											if (widget) widget.clear();
										}
									}
								}

								$item.toggleClass('dropdown__list__item__link_selected', enabled);

								if (type == 'Notify' || type == 'Priority' || type == 'Receipt') {
									var $propertyRow = $('.js-row-Property', this.$form);
									var $propertyCollection = $('.js-row-Notify,.js-row-Priority,.js-row-Receipt', this.$form);
									$propertyRow.toggle(enabled || $propertyCollection.filter(':visible').length > 0);
									$row.find('input[type="checkbox"]').attr('checked', enabled ? 'checked' : '');
								}

								// mail-12747 save new mask after user change
								if ($item.hasClass('dropdown__list__item__link_selected')) {
									mailru.EditorFlags |= bit; // turn on
								} else {
									mailru.EditorFlags &= ~bit; // turn off
								}
								this.setEditorFlags();

								// mail-11956
								if (type == 'CC')
									Counter.sb(1345723);
								else if (type == 'BCC')
									Counter.sb(1345726);
								else if (type == 'From')
									Counter.sb(1345730);
								else if (type == 'Receipt')
									Counter.sb(1345731);
								else if (type == 'Priority')
									Counter.sb(1345737);
								else if (type == 'Notify')
									Counter.sb(1345740);

								this._updateComposeLabelsDND();

								$win.triggerHandler('changeFieldVisible.compose');
							}

							dropdown.hide();

						}.bind(this)
					});

					this.$selectFieldsDropdownItems = $('.dropdown__list__item', this.$selectFieldsDropdown);

					t.changeNameDropDown = $('.js-dropdown-select-name', this.$form).dropdown({
						link: '.dropdown__button-inline',
						container: '.dropdown__list',
						orientation: 'auto',
						onClick: function (evt) {
							this._setActiveName(evt);
						}.bind(this)
					}).dropdown('widget');

					$win.bind('changeFieldVisible.compose', function () {
						$('.js-expand-field, .js-compose-labels', this.$form).each(function () {
							var $input = $(this);
							if ($input.is(':visible')) {
								$input.change();
							}
						});
					}.bind(this));

				} else {
					t.$changeNameLink = $('.changeNameLink:first', t.$form).bind('click', t._preventDefault);
					t.$changeNameSubMenu = $('.changeNameSubMenu:first', t.$form);

					$('.changeOneRealName', t.$form).mousedown(function () {
						$win.triggerHandler('realNameLinkClick.compose');
					});

					$('.settingRealName', t.$form).mousedown(function () {
						$win.triggerHandler('realNameSettingsLinkClick.compose');
					});

					t.changeNameDropDown = new Dropdown(t.$changeNameLink, t.$changeNameSubMenu);
					$('.item a', t.$changeNameSubMenu).click(this._setActiveName.bind(this));

					$win.bind('changeFieldVisible.compose', function () {
						$('.mlr-snd_input_expand .mlr-snd_itxt', this.$form).each(function () {
							var $input = $(this);
							if ($input.is(':visible')) {
								$input.change();
							}
						});
					}.bind(this));
				}

				var domIDs = t.options.domIDs;

				t.$frame = $(domIDs.composeFrame);
				t.$composeEditorFrame = $(domIDs.composeEditorFrame);
				t.$composeDisableFormLayer = $(domIDs.composeDisableFormLayer);
				t.$toolbarComposeTop = $(domIDs.toolbarComposeTop);

				t.$showCustomFieldsLink = $('.mlr-snd_rw_safld .mlr-psd_lnk', t.$form).bind('click', {'scope': t}, t._showCustomFieldsLinkClick);

				if(mailru.v2) {
					t.$sendButton = $('[data-name="send"]', '.b-toolbar');
					t.$draftButton = $('[data-name="saveDraft"]', '.b-toolbar');
					t.$cancelButton = $('[data-name="cancel"]', '.b-toolbar');
				}
				else {
					t.$sendButton = $('.js-send', t.$form);
					t.$draftButton = $('.js-draft', t.$form);
					t.$cancelButton = $('.js-cancel', t.$form);
				}

				t.$removeDraftContainer = $('.js-removeDraftContainer', t.$form);

				this.onChangeOfflineModeObserver = this._onChangeOfflineMode.bind(this);

				$(window).bind('offlinechange', this.onChangeOfflineModeObserver);

				t._updateFrameHeight();

				if (options.name) {
					mailru.Compose.Form[options.name] = this;
				}

				if ( t.mobileVersion)
				{
					t._mobileVersionInit();
				}
				else
				{
					if (t.deviceVersion)
					{
						t._deviceVersionInit();
					}
					else
					{
						t._initExpandFields();
						t._initComposeLabels();
						t._initEditor();
					}

					t._initAddressBook();
					t._initAddressBookAutocomplete();
				}

//				jsHistory.one($.proxy(t.unactive, t));

				// Check Avatar by ready event
				this.bind('ready', $.proxy(function (){
					var
						  t		= this
						, $img	= $(new Image)
									.attr('src', t.options.checkAvatarUrl)
									.one('load error', function (evt){
										$(this).unbind();
										t._checkAvatar(evt);
									})
					;
				}, this));

				Counter.d(326613);

				this.trigger('inited');
			},


			_iV2: function (){
				var $form = this.$form;

				$form.delegate('[data-compose-btn]', 'click', function (evt){
					evt.preventDefault();

					var name = $.attr(evt.currentTarget, 'data-compose-btn');
					if( name == 'send' ){
						this._send(evt);
					}
					else if( name == 'cancel' ){
						this._cancel(evt);
					}
				}.bind(this));

				// Initialization v2 components
				this.ModeSwitcher = new mailru.toolkit['b-compose__head__switcher']({
					el: this.$form.find('.b-compose__head__switcher'),
					select: function (mode){
						var $el = this.$('[data-name="'+mode+'"]');
						this.$('__ctrl')
							.find('.js-text').text($el.find('.js-text').text()).end()
							.find('.ico').replaceWith($el.find('.ico').clone())
						;
					},
					onMode: function (evt, ui){
						this.select(ui.name);
						$form.trigger('composeswitchmode', ui);
					}
				});
			},

			_onChangeOfflineMode: function (evt, offline) {

				var editor = this.getEditor();
				var appearance = this.getAppearance();

				if (editor) { // check if controlManager exist

					var controls = [
						editor.controlManager.get('design'),
						editor.controlManager.get('cards'),

						editor.controlManager.get('appspelling'),
						editor.controlManager.get('apptransfer'),
						editor.controlManager.get('apptranslit'),
						editor.controlManager.get('appkeyboard'),

						editor.controlManager.get('appspelling2'),
						editor.controlManager.get('apptransfer2'),
						editor.controlManager.get('apptranslit2'),
						editor.controlManager.get('appkeyboard2')
					];

					$.each(controls, function (k, control) {
						if (control) {
							control.setDisabled(offline);
						}
					});
				}

				if (this.uploaderDropDown) {
					this.uploaderDropDown.$link.toggleClass('form_disabled', offline);
				}

				if (this.$addressbookLinks) {
					this.$addressbookLinks.toggleClass('compose__header__label__box_addressbook', !offline);
				}

				if (offline) {

					this._disableSave();

					if (mailru['IsNewComposeDesign']) {
						this.decoration.hide();
					} else {
						appearance.hideLayer();
						if (mailru['ComposeCards']) {
							this.cards.hide();
						}
					}
				} else {
					this._enableSave();
				}
			},

			_formElm: function (name) {
				return	$('input[name="'+name+'"], textarea[name="'+name+'"]', this.$form);
			},

			isActive: function () {
				return	this.$form && this.$form.is(':visible');
			},

			unactive: function()
			{
				var t = this;

				for (var xhr in t.xhrs)
				{
					// error in IE7 (in jQuery 1.4.4 its fixed)
					try
					{
						t.xhrs[xhr].abort();
					}
					catch(e){}
				}

				for (var timer in t.timers)
					clearTimeout(t.timers[timer]);

				for (var interval in t.intervals)
					clearInterval(t.intervals[interval]);

				$win.add($doc).add(this.$form).unbind('.composeinner').unbind('.' + this.uniqId);;

				t.triggerHandler('unactive');
			},

			reset: function()
			{
				var t = this, domIDs = t.options.domIDs;
				var $mainFrame = t.getMainFrame();

				t._hideCustomFields();
				t._enableControls();
				t.enableEdit();

				t.getSaveMailSuccessMessageContainer()
					.add(t.getSaveMailErrorMessageContainer())
					.hide();

				this._formElm('To')
					.add( this._formElm('CC') )
					.add( this._formElm('BCC') )
					.add( $('input[name="Subject"]', t.$form) )
					.val('').triggerHandler('clearPreviousValue');

				$('input[name="Priority"], input[name="Receipt"]', t.$form)
					.attr('checked', '');

				$([domIDs.composeEditor_toolbar1, domIDs.composeEditor_toolbar3, domIDs.composeEditor_toolbar4].join(','), t.$form)
					.css('visibility', 'hidden');

				$mainFrame.addClass('jsvh');

				t.triggerHandler('reset');
				return	this;
			},

			resetNotify: function()
			{
				var  $notifyRow = $('.js-row-Notify', this.$form)
					,$notifyInput = $('.js-input', $notifyRow)
					,$notifyDropdown = $('.js-dropdown-select-notify', this.$form)
					,$notifyDropdownDefaultItem = $('.js-default', $notifyDropdown)
					,$notifyDropdownDefaultItemText = $('.dropdown__list__item__link__text', $notifyDropdownDefaultItem)
					,$notifyDropdownMainLink = $('.dropdown__button-inline__text', $notifyDropdown);
				$notifyDropdownMainLink.text($notifyDropdownDefaultItemText.text());
				$notifyInput.val($notifyDropdownDefaultItem.data('time'));
			},

			updateNotify: function()
			{
				var  $notifyRow = $('.js-row-Notify', this.$form)
					,$notifyInput = $('.js-input', $notifyRow)
					,time = $notifyInput.val()
					,$notifyDropdown = $('.js-dropdown-select-notify', this.$form)
					,$notifyDropdownSelectedItem = $('.dropdown__list__item[data-time="' + time + '"]')
					,$notifyDropdownSelectedItemText = $('.dropdown__list__item__link__text', $notifyDropdownSelectedItem)
					,$notifyDropdownMainLink = $('.dropdown__button-inline__text', $notifyDropdown);

				$notifyDropdownMainLink.text($notifyDropdownSelectedItemText.text());
			},

			setTo: function (to) {
				this._formElm('To').val(to).trigger('change');
				return	this;
			},

			setCC: function (cc) {
				if (mailru.IsNewComposeDesign) {
					this._formElm('CC')
						.val(cc)
						.closest('.js-row-CC', this.$form)
							.toggle(!!cc)
							.end()
						[!cc ? 'F' : 'trigger']('change')
					;
				} else {
					this._formElm('CC')
						.val(cc)
						.closest('tr.mlr-snd_h')
							.toggleClass('jsdn', !cc)
							.end()
						[!cc ? 'F' : 'trigger']('change')
					;
				}
				return	this;
			},

			setSubject: function (subj) {
				this._formElm('Subject').val(subj);
				return	this;
			},

			getFieldsByType: function (mode, Msg) {
				var result = {
					're_msg': '',
					'draft_msg': '',
					'fwd_msg': '',
					'To': '',
					'CC': '',
					'BCC': '',
					'Subject': ''
				};

				var id	= Msg && Msg.Id;

				if ($.type(Msg) == 'string') {
					Msg = mailru.Messages.get(id = Msg);
				}

				result['re_msg'] = /reply/.test(mode) ? id : '';
				result['fwd_msg'] = /forward/.test(mode) ? id : '';

				if (Msg) {
					result['To'] = mode == 'forward' ? '' : replaceEntity(Msg[mode == 'reply' ? 'ReplyTo' : 'ReplyAllTo'] || Msg.ReplyTo);
					result['CC'] = mode == 'replyall' ? replaceEntity(Msg.ReplyAllCC) : '';
					result['Subject'] = replaceEntity(Msg[mode == 'forward' ? 'SubjectFwd' : 'SubjectRe']);
				}

				return result;
			},

			setMode: function (mode, Msg) {
				var data = this.getFieldsByType(mode, Msg);

				this._hideCustomFields();

				this._formElm('re_msg').val(data['re_msg']);
				this._formElm('fwd_msg').val(data['fwd_msg']);
				this._formElm('draft_msg').val(data['draft_msg']);

				this
					.setTo(data['To'])
					.setCC(data['CC'])
					.setSubject(data['Subject'])
				;

				this.currentFormData = this.$form.serialize();

				this._loadGstat();

				return	this;
			},

			getData: function (o)
			{
				var
					  data		= $.extend({}, this.options.fileUploaderSettings, this.options)
					, form		= this.$form.toObject()
				;

				$.each('files_id,message,old_charset,draft_msg,template_id,re_msg,fwd_msg,To,CC,BCC,Subject'.split(','), function (i, k)
				{
					data[k]	= form[k];
				});

				data.HTMLCompose	= form.HTMLMessage;
				data.NeedRcpt		= form.Receipt;
				data.HighPriority	= form.Priority;
				data.remind			= form.remind;

				if( o )
				{
					if( o.attachments === false )
					{
						data.mailRestoreList	= void 0;
						var i = 1, pr = 'AttachedFiles_', pk = pr + i;
						while( data[pk + '_Id'] )
						{
							data[pk + '_Id']	= void 0;
							pk = pr + (++i);
						}
					}
				}

				return	data;
			},

			redraw: function(data)
			{
				var t = this;

				var formData = {
					value: {
						actionId: data.actionId || '',
						files_id: data.files_id == null ? '' : data.files_id.toString(),
						files_ids: data.files_ids || '',
						message: data.MessageId || '',
						old_charset: data.old_charset || '',
						draft_msg: data.draft_msg || '',
						template_id: data.template_id || '',
						re_msg: data.re_msg || '',
						fwd_msg: data.fwd_msg || '',
						To: data.To || '',
						CC: data.CC || '',
						BCC: data.BCC || '',
						Subject: data.Subject || '',
						HTMLMessage: mailru['ForceHtmlCompose'] || data.HTMLCompose ? 1 : 0
					},
					checked: {
						remind: data.remind,
						Priority: !!data.HighPriority,
						Receipt: !!data.NeedRcpt
					}
				};

				var fileUploaderSettings = {
					ServerName: data.ServerName || '',
					NoFlashUploader: !!data.NoFlashUploader,
					MaxAttachmentSize: parseInt(data.MaxAttachmentSize),
					MessageId: formData.value.message,
					DraftMsg: formData.value.draft_msg,
					LeftMailSize: parseInt(data.LeftMailSize),
					files_id: formData.value.files_id,
					UploadOnlyFiles: !!data.UploadOnlyFiles,
					MaxAttachments: parseInt(data.MaxAttachments),
					mailRestoreList: []
				};

				var i = 1, pr = 'AttachedFiles_', pk = pr + i;

				while (data[pk + '_Id']) {
					fileUploaderSettings['mailRestoreList'].push({
						fileid: data[pk + '_Id'] || '',
						filename: (data[pk + '_FileName'] || ''),
						partid: data[pk + '_partID'] || '',
						isRFC822: data[pk + '_isRFC822'] >>> 0,
						filesize: parseInt(data[pk + '_Size'])
					});
					pk = pr + (++i);
				}

				if (data.RADAR_ON)
					fileUploaderSettings['radar_config'] = {'t': data.radar_type, 'p': 'mail3', 'f': data.front_name2};

				var o = t.options;

				//MAIL-16081
				var FromName = null;

				if(!mailru.v2) {
					$.each(t.options.RealNames, function (k, v) {
						if(v.selected) {
							FromName = v.name;
							return false;
						}
					});
				}

				var options = {
					editorId: o.editorId,
					MessageId: data.MessageId || '',
					AbjsHash: data.AbjsHash || '',
					checkAvatarUrl: mailru.Utils.getAvatarSrc(mailru.useremail, FromName, 90 ),
					fileUploaderSettings: fileUploaderSettings,
					map_inline_img: {},
					isNewMessage: 0,
					html: '' + (data.letbody_html || ''),
					text: '' + (data.letbody_plain_Text_HTML || data.letbody_plain || '')
				};

				options.text = options.text.replace(/\r/g, '');

				if (data.map_inline_img && $.type(data.map_inline_img) == 'string' ) {
					options['map_inline_img'] = eval('({' + data.map_inline_img + '})');
				}

				if (!(formData.value.re_msg || formData.value.draft_msg || formData.value.fwd_msg || formData.value.actionId)) {
					options['isNewMessage'] = 1;
				}

				this.options = $.extend({}, this.options, options);

				this.$toolbarComposeTop.toggleClass(this.options.toolberTopCornerClass, mailru.isSentMsg);

				this.attachFromFileSearch = {};
				this.attachFromFileSearchSizes = {};
				this.attachFromFileSearchSize = 0;


				if (mailru.IsNewComposeDesign) {

					if (mailru.v2) {
						// https://jira.mail.ru/browse/MAIL-15612
						if (GET.To) {
							formData.value.To = GET.To;
						}
						else if (GET.mailto) {
							var mailto = GET.mailto.match(/(^mailto:)(.*)/);
							formData.value.To = mailto && mailto[2];
						}
						else if (GET.CC) {
							formData.value.CC = GET.CC;
						}
						else if (GET.BCC) {
							formData.value.BCC = GET.BCC;
						}
					}

					this.$selectFieldsDropdownItems.each(function (k, v) {
						var $item = $(v), type = $item.data('type'), bit = parseInt($item.data('bit'));
						var $row = $('.js-row-' + type, this.$form);
						var value = formData.value[type], checked = formData.checked[type];
						var enabled = !!(value || checked);

						// show fields using editor flags + non-empty fields
						enabled = enabled || (mailru.EditorFlags & bit) === bit;

						if (enabled) {
							$row.show();
						} else {
							$row.hide();
						}

						$item.toggleClass('dropdown__list__item__link_selected', enabled);

						if (type == 'Notify' || type == 'Priority' || type == 'Receipt') {
							var $propertyRow = $('.js-row-Property', this.$form);
							var $propertyCollection = $('.js-row-Notify,.js-row-Priority,.js-row-Receipt', this.$form);
							$propertyRow.toggle(enabled || $propertyCollection.filter(':visible').length > 0);
						}
					}.bind(this));
					this._updateComposeLabelsDND();

					if(formData.checked && formData.checked.remind) {
						var $input = this._formElm('remind');
						$input.val(formData.checked.remind);
						this.updateNotify();
					} else {
						this.resetNotify();
					}

					$.each(formData.value, function (name, value) {
						var $input = this._formElm(name);
						$input.val(value);
						$input.triggerHandler('clearPreviousValue');
					}.bind(this));

					$.each(formData.checked, function (name, checked) {
						var $input = this._formElm(name);
						$input.attr('checked', checked ? 'checked' : '').triggerHandler('change');
					}.bind(this));

				} else {
					$.each(formData.value, function (name, value) {
						var $input = this._formElm(name);
						if (value && (name == 'CC' || name == 'BCC')) {
							$input.parents('tr.mlr-snd_h:first').removeClass('jsdn');
						}
						$input.val(value);
						$input.triggerHandler('clearPreviousValue');
					}.bind(this));

					$.each(formData.checked, function (name, checked) {
						var $input = this._formElm(name);
						$input.attr('checked', checked ? 'checked' : '').triggerHandler('change');
					}.bind(this));
				}

				var dropdown = t.changeNameDropDown; // mail-8335 update dropdown selected value
				var editor = this.getEditor();
				var signId;

				$.each(t.options.RealNames, function (k, v) {
					if(v.selected) {
						signId = v.id;
						return false;
					}
				});

				if (editor) {
					var control = editor.controlManager.get('signature');

					if (control) {
						control.setActiveRealName(signId);
					}
				}

				this._setRealName(signId);

				$win.triggerHandler('changeFieldVisible.compose');

				this.messageMode = this._getMessageMode();

				if (t.mobileVersion) {
					t._mobileVersionReady();
				} else {
					if (t.deviceVersion) {
						t._deviceVersionReady();
					} else {
						t._fullVersionReady();
					}
				}

				if(this.fileSearchManager)
					this.fileSearchManager.reset();

				t.triggerHandler('redraw');

				if (ajs.offline) {
					this._onChangeOfflineMode(null, true);
				}

				if (mailru.ComposeLabels) {
					$('.js-compose-labels', this.$form).each(function() {
						if ( $(this).composeLabels("widget") )
							$(this).composeLabels("widget").redraw();
					});
					Counter.d(1708705);
				}

				return	this;
			},

			resizeDisabled: function (status) {
				this.options.resizeDisabled = !!status;
				return	this;
			},

			_formKeyboard: function(evt){
				var t = this;

				if( evt.ctrlKey || evt.metaKey ){
					var keyCode = evt.keyCode || evt.which;
					if( keyCode == 13 ){
						// Enter
						evt.preventDefault();
						t.$form.submit();
					}
					else if (keyCode == 83) // S
					{
						evt.preventDefault();
						t.$draftButton.first().click();
					}
				}
			},

			_setUnloadConfirm: function (){
				var t = this;

				t._removeUnloadConfirm();

				if( t.supportBeforeUnload ){
					$win.bind('beforeunload.' + t.uniqId, t.beforeUnloadObserver);
				}
				else {
					$doc.bind('click.' + t.uniqId, t.beforeUnloadObserver);
				}
			},

			_removeUnloadConfirm: function (){
				var t = this;
				$win.unbind('.' + t.uniqId);
				$doc.unbind('.' + t.uniqId);
			},

			_onBeforeUnload: function(){
				var t = this, editor = t.getEditor();

				if (t.isHTMLMode()) {
					editor.save({'format': 'raw'});
				}

				var currentFormData = t.$form.serialize();
				if (currentFormData != t.currentFormData || t.getFileUploader().isLoading() ){
					return Lang.get('compose.before_unload_confirm_text');
				}
			},

			_onBeforeUnloadFix: function(evt){
				var t = this, editor = t.getEditor(), currentFormData = t.$form.serialize();

				if (t.isHTMLMode())
					editor.save({'format': 'raw'});

				if (currentFormData != t.currentFormData || t.getFileUploader().isLoading() ){
					var $target = $(evt.target);
					if ($target.is('a') && !/^(javascript|#)/.test($target.attr('href')))
					{
						if (!confirm(Lang.get('compose.before_unloadfix_confirm_text')))
							evt.preventDefault();
					}
				}
			},

			_editorSetup: function(ed)
			{
				var t = this;
				ed[$.browser.opera ? 'onKeyPress' : 'onKeyDown'].add(function(ed, evt){
					this._formKeyboard($.event.fix(evt));
				}, t);
			},

			_initEditor: function()
			{
				var t = this;
				var options = {
					oninit: $.proxy(t._fullVersionInit, t),
					setup: $.proxy(t._editorSetup, t),
					doctype: '',
					language: 'ru',
					language_load: false,
					mode: 'exact',
					elements: t.getEditorId(),
					theme: 'compose',
					plugins: 'lists,pagebreak,table',
					add_form_submit_trigger: false,
					submit_patch: false,
					convert_fonts_to_spans: false,
					add_unload_trigger: false,
					cleanup: false,
//					fix_ie_paragraphs: false,
					update_styles: false,
					keep_values: false,
					gecko_spellcheck: true,
					forced_root_block: false,
					force_br_newlines: true,
					force_p_newlines: false,
					remove_linebreaks: false,
					no_content_load: true,
					extended_valid_elements: 'style',
					font_size_style_values: '8px,10px,12px,14px,18px,24px,36px',
					theme_compose_toolbar_location: 'external',
					theme_compose_toolbar_external_id: t.options.domIDs.toolbar_external.substr(1),
					theme_compose_toolbar_align: 'left',
					theme_compose_more_colors: 0,
					real_names: t.RealNamesSignatures,
					moreactions_controls: {
						expand_controls: ['undo', 'redo', 'appspelling', 'apptransfer'],
						controls: []
					}
				};

				if (mailru['IsNewComposeDesign']) {

					options['theme_compose_buttons1'] = 'bold,italic,underline,forecolor,backcolor,fontactions,justifyselect,textindentactions,bullistactions,|,emotions,|,undo,redo,|,appspelling,apptransfer,|,moreactions,|,enableTextEditor';
					options['theme_compose_buttons2'] = 'design';

					if (mailru['IsSingleDomain']) {
						if (mailru.LANG !== 'en_US' && mailru.LANG !== 'es_ES') {
							options['theme_compose_buttons3'] = 'appspelling2,apptransfer2,apptranslit2,|,enableHTMLEditor';
							options['moreactions_controls']['controls'] = ['hr', 'addlink', 'strikethrough', 'apptranslit', 'removeformat'];
						}
						else {
							options['theme_compose_buttons3'] = 'appspelling2,apptransfer2,|,enableHTMLEditor';
							options['moreactions_controls']['controls'] = ['hr', 'addlink', 'strikethrough', 'removeformat'];
						}

					} else {
						if (mailru.LANG !== 'en_US' && mailru.LANG !== 'es_ES') {
							options['theme_compose_buttons3'] = 'appspelling2,apptransfer2,apptranslit2,appkeyboard2,|,enableHTMLEditor';
							options['moreactions_controls']['controls'] = ['hr', 'addlink', 'strikethrough', 'apptranslit', 'appkeyboard', 'removeformat'];
						}
						else {
							options['theme_compose_buttons3'] = 'appspelling2,apptransfer2,appkeyboard2,|,enableHTMLEditor';
							options['moreactions_controls']['controls'] = ['hr', 'addlink', 'strikethrough', 'appkeyboard', 'removeformat'];
						}
					}

				} else {
					options['theme_compose_buttons1'] = 'bold,italic,underline,forecolor,backcolor,fontactions,justifyselect,textindentactions,bullistactions,emotions,moreactions,enableTextEditor';

					if (mailru['IsSingleDomain']) {
						options['theme_compose_buttons2'] = 'apptransfer,appspelling,moreapps';
					} else {
						options['theme_compose_buttons2'] = 'apptransfer,appkeyboard,appspelling,moreapps';
					}

					options['theme_compose_buttons2_title'] = Lang.get('compose.app_title') + ':';
					options['theme_compose_buttons3'] = 'design';
					options['theme_compose_buttons4'] = 'enableHTMLEditor';
				}

				if (mailru['ComposeCards']) {
					if (mailru['IsNewComposeDesign']) {
						options['theme_compose_buttons2'] += ',cards';
					} else {
						options['theme_compose_buttons3'] += ',cards';
					}
				}

				if (mailru['IsNewComposeShowSignature']) {
//					if (t.RealNamesSignatures.length > 1) {  // MAIL-11117 always show signature button
						options['theme_compose_buttons2'] = 'signature,' + options['theme_compose_buttons2'];
//					}
				}

				if ($.browser.opera) {
					options['forced_root_block'] = 'p';
				}

				if (!$.browser.msie && !$.browser.opera) {

					options['plugins'] += ',paste';

					$.extend(options, {
						paste_preprocess: $.proxy(function(pl, o) {
							o.content = this._prepareContentOnPaste(o.content);
						}, t),
						paste_auto_cleanup_on_paste: true,
						paste_auto_process_on_paste: false,
						paste_enable_default_filters: false
					});
				}

				if (mailru['WithoutIECompatible']) {
					options['convert_urls'] = false;
				}

				tinyMCE.init(options);

				// MAIL-9947
				if (!mailru['WithoutIECompatible']) {
					// someting problem with AJAX version where HTML editor is hidden. Need timeout
					setTimeout(function() {
						try {
							tinymce.dom.Event._pageInit();
						} catch(e) {
							ajs.log('[fail] _initEditor:', e);
							t._deviceVersionInit();
						}
					}, 0);
				}
			},

			_initAddressBookAutocomplete: function() {
				this.prevEmailList = [];

				if(mailru.CanUseNewAddressbookSuggests) {
					$('.js-ac-addressbook', this.$form).addressbookSuggest();

				} else {
					$('.js-ac-addressbook', this.$form)
						.bind('focus keyup', function _fn(){
							mailru.Utils.getAddressBook();
							$(this).unbind('focus keyup', _fn);
						})
						.each(function(){
							$.Autocompleter.addressbook(this, true);
						})
					;
				}

				if( store.get('labs.compose.ava') ){
					$('.js-ac-addressbook', this.$form).bind('keyup result', this._funkyAva.debounce(100, this))
				}
			},

			_funkyAva: function (){
				var prevEmailList = this.prevEmailList;
				var emailList = mailru.Utils.extractEmails([this._formElm('To').val(), this._formElm('CC').val(), this._formElm('BCC').val()].join(''));
				var $box = $(this.options.domIDs.composeAvatar).toggleClass('b-compose__head__avatar_small', !!(emailList && emailList.length));

				var i = prevEmailList.length, changed;

				while( i-- ){
					var idx = Array.indexOf(emailList, prevEmailList[i].data('email'));
					if( idx == -1 ){
						prevEmailList.splice(i, 1)[0].css('opacity', 0).bind('TransitionEnd webkitTransitionEnd mozTransitionEnd', function (){
							$(this).remove();
						});
						changed = true;
					}
					else {
						emailList.splice(idx, 1);
					}
				}

				ajs.each(emailList, function (email){
					var $img = $(new Image)
						.data('email', email)
						.attr('src', mailru.Utils.getAvatarSrc(email, email, 40))
						.addClass('b-compose__head__ava')
						.css('zIndex', prevEmailList.length+1)
						.appendTo($box.parent())
					;
					changed = true;
					prevEmailList.push($img);
				});

				changed && setTimeout(function (){
					var cx = 0, cy = 55, len = prevEmailList.length;
					prevEmailList.forEach(function ($img, i){
						$img.css({
							  top:  cy + (i < len-1)*Math.rand(-10, 10)
							, left: cx + (i < len-1)*Math.rand(-10, 10)
							, opacity: .99
						})
						.css($.support.cssPrefix+'Transform', 'rotate('+(i < len-1)*Math.rand(-10, 10)+'deg)')
					});
				}, 1);
			},

			_initAddressBook: function() {
				if (mailru['IsNewComposeDesign']) {
					this.$addressbookLinks = $('.js-addressbook-link', this.$form).click(function(evt) {
						var $item = $(evt.currentTarget), type = $item.data('type');
						if ($item.hasClass('compose__header__label__box_addressbook')) {
							this._openAddressBook(type);
							$win.triggerHandler('addressBookLinksClick.compose');
						}
					}.bind(this));
				} else {
					$('.mlr-snd_rw_ab', this.$form).each(function(scope) {
						var $parent = $(this), $label = $('label', $parent), data = $onClick($label[0]);
						$label.html('<a href="javascript:void(0);">' + $label.text() + '</a>');
						$('.mlr-snd_lbl a, .mlr-snd_book a', $parent).bind('click', {'data': data, 'scope': scope}, function(evt) {
							if (!ajs.offline) {
								evt.preventDefault();
								evt.data.scope._openAddressBook(evt.data.data.type);
								if ($(this).parent().hasClass('mlr-snd_book')) {
									$win.triggerHandler('addressBookIconsClick.compose');
								} else {
									$win.triggerHandler('addressBookLinksClick.compose');
								}
							}
						});
					}, [this]);
				}
			},

			_initExpandFields: function() {
				if (mailru.IsNewComposeDesign) {
					$('.js-expand-field', this.$form).expandField({fixedWidth: false});
				} else {
					$('.mlr-snd_input_expand input', this.$form).expandField({fixedWidth: false});
				}
			},

			_initComposeLabels: function() {
				var dndEnabled = $('.js-row-CC', this.$form).is(':visible') || $('.js-row-BCC', this.$form).is(':visible');
				if(mailru.ComposeLabels) {
					var names = ['To', 'CC', 'BCC'], i = 0;
					for( ; i < names.length; i++) {
						this._formElm(names[i])
							.composeLabels(null, {'dragNDropEnabled': dndEnabled});
					}
				}
			},

			_updateComposeLabelsDND: function() {
				var dndEnabled = $('.js-row-CC', this.$form).is(':visible') || $('.js-row-BCC', this.$form).is(':visible');
				$('.js-compose-labels', this.$form).each(function() {
					$(this).composeLabels("widget").toggleDragNDrop(dndEnabled);
				});
			},

			_checkAvatar: function(evt) {

				var lang = Lang.get('compose.avatar')['add'];
				if (evt.type != 'error') {

					//MAIL-16081
					var FromName;

					$.each(this.options.RealNames, function (k, v) {
						if(v.selected) {
							FromName = v.name;
							return false;
						}
					});

					$(this.options.domIDs.composeAvatar).css('backgroundImage', 'url('+mailru.Utils.getAvatarSrc(mailru.useremail, FromName, 90 )+')');
					lang = Lang.get('compose.avatar')['change'];
				}
				$('span.mlr-snd_av_ttl:first', this.$form).text(lang);
			},

			_preventDefault: function(evt) {
				evt.preventDefault();
			},

			_setActiveName: function(evt) {

				evt.preventDefault();

				var editor = this.getEditor();
				var id = $onClick(evt.target, 1);

				if (mailru.IsNewComposeDesign) {
					var $item = $(evt.target).closest('.dropdown__list__item', this.changeNameDropDown.$container);

					if ($item.length) {
						id = $item.data('type');
					}
				}

				if(editor) {
					var control = editor.controlManager.get('signature');

					if (control) {
						control.setActiveRealName(id);
					}
				}

				this._setRealName(id);

				this.changeNameDropDown.hide();
			},

			_setRealName: function (id) {

				var data = this.options.RealNames[id];

				if (data) {

					var name = data.name.replace(/&apos;|&#39;/g, '\'')
										.replace(/&amp;|&#38;/g, '&');

					if (mailru.IsNewComposeDesign) {
						if(!!this.changeNameDropDown.$link) {
							$('.dropdown__button-inline__text', this.changeNameDropDown.$link).text(name);
						}
					} else {
						$('.js-realname', this.$form).text(name);
					}

					$('input[name="RealName"]:first', this.$form).val(data.id);

					var text = this.getContent();
					var find = false;
					var isHTML = this.isHTMLMode();
					var SignatureBeforeQuotation = this.options.SignatureBeforeQuotation;

					var prepareSignature = function () {
						var pattern = /\r/g;
						return function (str) {
							return str.replace(pattern, '') || '--';
						}
					}();

					var replaceEntities = function () {
						var replaceMap = {'#39':"'", 'quot':'"', 'amp':'&', 'lt':'<', 'gt':'>'}, pattern = /&(#39|quot|amp|lt|gt);/g;
						return function (str) {
							return str.replace(pattern, function(a,b) {
								return replaceMap[b] || b;
							});
						}
					}();

					var newSignature = prepareSignature(data.signature);
					if (isHTML) {
						newSignature = newSignature.replace(/\n/g, '<br>');
					} else {
						// ascii symbols not converted automatically
						newSignature = replaceEntities(newSignature);
					}

					if (!this.signatures) {
						this.signatures = []; // MAIL-9336 use array because iterate order is important
						var signatures = this.signatures; // shortcut

						var current = mailru.UserSignature || '';
						if (current) {
							current = current.replace(/<br>/g, '\n');
							signatures.push({id:'current', signature:current});
						}

						$.each(this.options.RealNames, function (k, v) {
							signatures.push(v);
						});
					}

					$.each(this.signatures, function (k, v) {

						var signaturePatternStr = prepareSignature(v.signature);

						signaturePatternStr = String.preg_quote(signaturePatternStr);

						if (isHTML) {
							signaturePatternStr = signaturePatternStr
								.replace(/\n/g, '(\\n+)?(\\s+)?(<br>)?(\\n+)?')
								.replace(/&quot;|&#34;/g, '\"')  // "
								.replace(/&apos;|&#39;/g, '\''); // '
						} else {
							// MAIL-8335
							signaturePatternStr = replaceEntities(signaturePatternStr);
						}

						if (SignatureBeforeQuotation) {
							// mail-11117 search for first matched, no matter what is before the signature
							signaturePatternStr = '([\\s\\S]*?)' + signaturePatternStr;
						} else {
							// mail-11117 search last match from the beginning
							signaturePatternStr = '([\\s\\S]*)' + signaturePatternStr;
						}

						var signaturePattern = new RegExp(signaturePatternStr, 'i');

						if (find = signaturePattern.test(text)) {
							text = text.replace(signaturePattern, function(m0, m1) {
								return m1 + newSignature;
							});
						}

						return !find;
					});
				}

				if (find) {
					// update current signature
					if(this.signatures[0].id == 'current') {
						this.signatures[0].signature = newSignature.replace(/<br>/g, '\n');
					}
					else {
						// no current signature, add it at the first position
						this.signatures.splice(0, 0, {id: 'current', signature: newSignature.replace(/<br>/g, '\n')});
					}
					this.setContent(text);
				}

				$win.triggerHandler('realNameChange.compose');
			},

			_showCustomFieldsLinkClick: function(evt)
			{
				evt.preventDefault();
				var scope = evt.data.scope;
				scope._showCustomFields();
				$win.triggerHandler('showAllFieldsLinkClick.compose');
			},

			_removeUpdateEditorGeometryTimeout: function()
			{
				var t = this;
				clearTimeout(t.timers['updateEditorGeometry']);
			},

			_setUpdateEditorGeometryTimeout: function()
			{
				var t = this, o = t.options;
				t._removeUpdateEditorGeometryTimeout();
				t.timers['updateEditorGeometry'] = setTimeout($.proxy(t._updateEditorGeometry, t), o.updateEditorGeometryTimeout);
			},

			_removeUpdateEditorFrameOnResizeTimeout: function()
			{
				var t = this;
				clearTimeout(t.timers['updateEditorFrameOnResize']);
			},

			_setUpdateEditorFrameOnResizeTimeout: function()
			{
				var t = this, o = t.options;
				t._removeUpdateEditorFrameOnResizeTimeout();
				t.timers['updateEditorFrameOnResize'] = setTimeout($.proxy(t._updateGeometry, t), o.updateEditorFrameOnResizeTimeout);

				if (!mailru.IsNewComposeDesign) {
					t.cards.resize();
				}
			},

			_clearEditorGeometry: function()
			{
				var t = this;
				var appearance = t.getAppearance();
				var $middleTable = appearance.getMiddleTable();
				var $editorElement = t.getEditorElement();

				$middleTable.css('width', '');
				$editorElement.css('width', '100%');

				if ($.browser.msie && parseInt($.browser.version) < 8)
				{
					var $mainTable = appearance.getMainTable();
					$mainTable.css('width', '');
				}
			},

			_parentHeightFunc: function (){
				try {
					return	ajs.windowHeight() - this.getMainFrame().offset().top + ajs.scrollTop();
				} catch (err){ }
			},

			_updateFrameHeight: function()
			{
				if( !this.options.resizeDisabled )
				{
					var
						  t = this, o = t.options
						, $editorElement	= t.getEditorElement()
						, $captchaContainer	= t.getCaptchaContainer()
						, bottomControlsHeight = t.getBottomControlsHeight()
						, availableHeight	= this.parentHeight() - bottomControlsHeight - $captchaContainer[0].offsetHeight
						, frameHeight		= Math.max(o.minEditorHeight, Math.min(o.maxEditorHeight, availableHeight))
					;
					$editorElement.css('height', frameHeight);
				}
			},

			parentHeight: function (func)
			{
				if( $.isFunction(func) )
				{
					this._parentHeightFunc	= func;
					return	this;
				}
				return	this._parentHeightFunc.call(this, this);
			},

			_updateEditorGeometry: function() {

				var $editorElement = this.getEditorElement();
				var appearance = this.getAppearance();
				var $mainFrame = this.getMainFrame();

				// @todo refactoring
				if( this.options.resizeDisabled && (this.__uEGHM === this.isHTMLMode()) ) return;
				this.__uEGHM = this.isHTMLMode();

				if (this.isHTMLMode()) {
					var currentTemplate = appearance.getCurrentTemplate();
					var editor = this.getEditor();
					var $editorFrame = this.getEditorFrame();
					var $mainTable = appearance.getMainTable();
					var $middleTable = appearance.getMiddleTable();
					var $mainCellHolder = appearance.getMainCellHolder();
					var widthOffset = appearance.getWidthOffset();
					var doc = editor.getDoc();
					var body = editor.getBody();
					var $editorFrameBody = this.getEditorFrameBody();
					var frame = $mainFrame[0];
					var frameHeight = frame.offsetHeight;
					var tableWidth = '';
					var newTableWidth = 0;

					if (currentTemplate) {
						if (body.scrollWidth + widthOffset > frame.offsetWidth) {
							if ($.browser.msie) {
								$editorFrameBody.css('display', 'inline');

								newTableWidth = body.scrollWidth + widthOffset;

								if (newTableWidth > frame.offsetWidth) {
									tableWidth = newTableWidth;
								}

								$middleTable.css('width', tableWidth);
								$editorFrameBody.css('display', '');
							} else {
								$editorFrameBody.css('display', 'inline-block');

								newTableWidth = body.offsetWidth + widthOffset;

								if (newTableWidth > frame.offsetWidth) {
									tableWidth = newTableWidth;
								}

								$middleTable.css('width', tableWidth);
								$editorFrameBody.css('display', '');
							}
						}

						if ($.browser.msie && parseInt($.browser.version) < 8) {
							$mainTable.css('width', '');

							if (frame.scrollHeight > frame.clientHeight) {
								$mainTable.css('width', frame.offsetWidth - 16);
							}
						}

						frameHeight = body.scrollHeight;

						if (!$.browser.msie) {
							var lastChild = body.appendChild(doc.createElement('div'));
							frameHeight = lastChild.offsetTop - lastChild.offsetHeight;
							body.removeChild(lastChild);
						}

						frameHeight += 35;

						var newMainCellHolderHeight = frame.offsetHeight - appearance.getHeightOffset();
						if (frame.scrollWidth > frame.clientWidth) {
							newMainCellHolderHeight -= 16;
						}

						$mainCellHolder.attr('height', newMainCellHolderHeight);
					}

					frameHeight = defined(height, frameHeight);

					$editorFrame.css('height', frameHeight);

				} else {
					var $captchaContainer = this.getCaptchaContainer();
					var bottomControlsHeight = this.getBottomControlsHeight();

					var minHeight = this.options.minEditorHeight;
					var maxHeight = this.options.maxEditorHeight;

					var height = this.parentHeight() - bottomControlsHeight - $captchaContainer[0].offsetHeight;

					height = Math.max(minHeight, Math.min(maxHeight, height));

					if ($.browser.msie && parseInt($.browser.version) < 8) {
						height -= 16;
					}

					$editorElement.css({
						height: height
					});

					appearance.setListFrameHeight(height - 38);
				}
			},

			_updateFrameGeometry: function(width, height) {

				this._clearEditorGeometry();

				if (this.options.resizeDisabled && (this.__uFGHM === this.isHTMLMode())) {
					return;
				}

				this.__uFGHM = this.isHTMLMode();

				if (this.isHTMLMode()) {
					var $mainFrame = this.getMainFrame();
					var appearance = this.getAppearance();
					var currentTemplate = appearance.getCurrentTemplate();
					var bottomControlsHeight = this.getBottomControlsHeight();
					var $captchaContainer = this.getCaptchaContainer();

					$mainFrame.css('width', '');

					var minHeight = this.options.minEditorHeight;
					var maxHeight = this.options.maxEditorHeight;

					if (currentTemplate) {
						minHeight = this.options.minEditorWithAppearanceHeight;
						maxHeight = this.options.maxEditorWithAppearanceHeight;
					}

					width = defined(width, $mainFrame.width());

					if (!defined(height)) {
						height = this.parentHeight() - bottomControlsHeight - $captchaContainer[0].offsetHeight;
						height = Math.max(minHeight, Math.min(maxHeight, height));
					}

					appearance.setListFrameHeight(height - 38);

					if (mailru.IsNewComposeDesign) {
						this.decoration.setHeight(height);
						$mainFrame.css('height', height);
//						$mainFrame.css('width', width); ???
					} else {
						$mainFrame.css({
							width: width,
							height: height
						});
					}
				}
			},

			_updateGeometry: function() {
				$win.triggerHandler('changeFieldVisible.compose');
				this._updateFrameGeometry();
				this._updateEditorGeometry();
			},

			_frameClick: function(evt)
			{
				evt.data.scope.focus();
			},

			_setAutoSaveInterval: function()
			{
				var t = this, o = t.options;
				t._removeAutoSaveInterval();
				t.intervals['autoSave'] = setInterval($.proxy(t._autosave, t), o.autoSaveTimeout);
			},

			_removeAutoSaveInterval: function()
			{
				var t = this;
				clearInterval(t.intervals['autoSave']);
			},

			_autosaveCompleteCallback: function(result){
				var t = this;
				var data = null;

				t._autosaveActive = false;

				if (result.isOK()) {
					data = result.getData();
				}

				if (data){
					if (data.Id){
						$('input[name="draft_msg"]:first', t.$form).val(data.Id);

//						var Folder = mailru.Folders.getSafe();
//						if (Folder && Folder.Id != mailru.Folder.DRAFTS && (this.isReply() || this.isForward())) {
//							this.$removeDraftContainer.display(1);
//						}

						this._updateAffectedMessage(data.Id);

						var ReadmsgCompose = jsView.get('readmsg_compose');
						var SentmsgView = jsView.get('sentmsg');

						if (mailru.isComposePage()) {
							SentmsgView.mode = 'drafts';
						} else if (ReadmsgCompose && mailru.isReadMsgPage()) {
							ReadmsgCompose.mode = 'drafts';
						}

						if (t.isHTMLMode()) {
							t.getEditor().save({'format': 'raw'});
						}

						t.currentFormData = t.$form.serialize();

						t._disableSave();
						t._showSuccessSaveMailMessage(true);

						t.attachFromFileSearchSize = 0; //     .
					}
				}
			},

			_saveCompleteCallback: function(result) {
				var t = this, data = null, success = false, errorStr = Lang.get('compose.save_mail_error');

				t._autosaveActive = false;

				if (result.isOK()) {
					data = result.getData();
				}

				t._hideLoading();

				if (data) {
					if (data.Id) {
						success = true;

						$('input[name="draft_msg"]:first', t.$form).val(data.Id);

//						var Folder = mailru.Folders.getSafe();
//						if (Folder && Folder.Id != mailru.Folder.DRAFTS && (this.isReply() || this.isForward())) {
//							this.$removeDraftContainer.display(1);
//						}

						this._updateAffectedMessage(data.Id);

						var ReadmsgCompose = jsView.get('readmsg_compose');
						var SentmsgView = jsView.get('sentmsg');

						if (mailru.isComposePage()) {
							SentmsgView.mode = 'drafts';
						} else if (ReadmsgCompose && mailru.isReadMsgPage()) {
							ReadmsgCompose.mode = 'drafts';
						}

						if (t.isHTMLMode()) {
							t.getEditor().save({'format': 'raw'});
						}

						t.currentFormData = t.$form.serialize();

						t.attachFromFileSearchSize = 0; //     .
					} else if (data.Error) {
						errorStr = data.Error;
					}
				}

				if (success) {
					t._disableSave();
					t._showSuccessSaveMailMessage();
				} else {
					t._showErrorSaveMailMessage(errorStr, !!mailru.v2);
				}
			},

			_autosave: function() {
				if (!this._autosaveActive) {
					if (this.isHTMLMode()) {
						this.getEditor().save({format: 'raw'});
					}
					if (!this.$draftButton.attr('disabled')) {
						var currentFormData = this.$form.serialize();
						if (currentFormData != this.currentFormData){
							this._autosaveActive = true;
							this._saveProcess(this._autosaveCompleteCallback);
						}
					}
				}
			},

			_save: function(){
				var t = this;

				if( !t._autosaveActive ){
					t._autosaveActive = true;

					t._showLoading(Lang.get('compose.save_mail_progress'));
					t._saveProcess(t._saveCompleteCallback, true);
					t._sendGstat();
				}
			},

			_saveProcess: function(completeCallback, force)
			{
				var t = this;
				var editor = t.getEditor();
				var $editorElement = t.getEditorElement();
				var appearance = t.getAppearance();
				var $charsetInput = $('input[name="old_charset"]:first', t.$form);
				var charset = $charsetInput.val();

				if (t.isHTMLMode())
				{
					var editorContent = appearance.getHTML(editor.getContent({'format': 'raw'}));
					$editorElement.val(t._prepareContent(editorContent));
				}

				$charsetInput.val('utf-8');

				var attachIds = [], attachments = t.fileUploader.getUploadedAttachments();
				if ($.isArray(attachments)) {
					for (var i=attachments.length; i--; ) {
						attachIds.push(attachments[i].fileid);
					}
				}
				$('input[name="attached_ids"]', t.$form).val(attachIds.join(','));

				if (t.xhrs['save'])
					t.xhrs['save'].abort();

				var formData = t.$form.toObject();

				delete formData['send'];
				delete formData['draft'];
				delete formData['cancel'];
				delete formData['Filedata'];

				t.xhrs['save'] = mailru.Ajax({
					type: 'POST',
					url: '/compose/?func_name=message_to_draft&draft=1',
					data: formData,
					isUser: !!force,
					complete: $.proxy(completeCallback, t)
				});

				$charsetInput.val(charset);
			},

			_enableSave: function() {
				if (!ajs.offline) {
					this._enableSaveControl();
					this._removeEnableSaveInterval();
					this._setAutoSaveInterval();
				}
			},

			_disableSave: function() {
				this._disableSaveControl();
				this._removeAutoSaveInterval();
				this._setEnableSaveInterval();
			},

			_enableControls: function() {
				this._enableSendControl();
				this._enableSaveControl();
				this._enableCancelControl();
			},

			_disableControls: function() {
				this._disableSendControl();
				this._disableSaveControl();
				this._disableCancelControl();
			},

			_enableSendControl: function() {
				if (mailru.v2) {
					mailru.toolkit.toggleMod(this.$sendButton, 'disabled', false);
				} else {
					this.$sendButton.removeAttr('disabled').removeClass('button-a_disabled');
				}
			},

			_disableSendControl: function() {
				if (mailru.v2) {
					mailru.toolkit.toggleMod(this.$sendButton, 'disabled', true);
				} else {
					this.$sendButton.attr('disabled', 'disabled').addClass('button-a_disabled');
				}
			},

			_enableSaveControl: function() {
				if (mailru.v2) {
					mailru.toolkit.toggleMod(this.$draftButton, 'disabled', false);
				} else {
					this.$draftButton.removeAttr('disabled').removeClass('button-a_disabled');
				}
			},

			_disableSaveControl: function() {
				if (mailru.v2) {
					mailru.toolkit.toggleMod(this.$draftButton, 'disabled', true);
				} else {
					this.$draftButton.attr('disabled', 'disabled').addClass('button-a_disabled');
				}
			},

			_enableCancelControl: function() {
				if (mailru.v2) {
					mailru.toolkit.toggleMod(this.$cancelButton, 'disabled', false);
				} else {
					this.$cancelButton.removeAttr('disabled').removeClass('button-a_disabled');
				}
			},

			_disableCancelControl: function() {
				if (mailru.v2) {
					mailru.toolkit.toggleMod(this.$cancelButton, 'disabled', true);
				} else {
					this.$cancelButton.attr('disabled', 'disabled').addClass('button-a_disabled');
				}
			},

			_checkEnableSave: function() {
				var t = this;

				if (t.isHTMLMode())
					t.getEditor().save({'format': 'raw'});

				var currentFormData = t.$form.serialize();
				if (currentFormData != t.currentFormData) {
					t._enableSave();
				}
			},

			_setEnableSaveInterval: function() {
				var t = this, o = t.options;
				t._removeEnableSaveInterval();
				t.intervals['enableSave'] = setInterval($.proxy(t._checkEnableSave, t), o.enableSaveTimeout);
			},

			_removeEnableSaveInterval: function() {
				var t = this;
				clearInterval(t.intervals['enableSave']);
			},

			_showSuccessSaveMailMessage: function(auto)
			{
				var t = this;
				var date = new Date();
				var $success = t.getSaveMailSuccessMessageContainer();
				var $error = t.getSaveMailErrorMessageContainer();
				var $load = t.getLoadingContainer();
				if (mailru.v2)
					$success.html(Lang.get('compose.save_mail_success'));
				$('.auto:first', $success).toggle(!!auto);
				$('.time:first', $success).text(date.getLocaleTime());
				$error.add($load).hide();
				$success.show();
			},

			_showErrorSaveMailMessage: function(message, withTable) {
				var t = this;
				var $success = t.getSaveMailSuccessMessageContainer();
				var $error = t.getSaveMailErrorMessageContainer();
				var $load = t.getLoadingContainer();
				$success.add($load).hide();

				var errorHTML = withTable ? message : String.sprintf(Lang.get('ErrorTable'), message);

				if (mailru['v2']) {

					if (withTable) {
						var mathes = errorHTML.replace(/\n/g, '').match(/<\/tr><tr><td class="oranzhe">(.*?)<\/td><\/tr><\/table>$/);
						if (mathes) {
							errorHTML = mathes[1];
						}
					}

					mailru.Notify.add('error', {
						text: errorHTML
					});

				} else {
					$error.html(errorHTML).show();
				}
			},

			_applyTranslit: function(text)
			{
				var t = this;
				var editor = t.getEditor();
				var $editorElement = t.getEditorElement();

				if (text)
				{
					if (t.isHTMLMode())
					{
						editor.setContent(text, {'format': 'raw'});
					}
					else
					{
						$editorElement.val(text);
					}
				}
			},

			_onSubmit: function(evt, options) {

				var t = this, o = t.options;

				if (!this.isActive()) {
					evt.preventDefault();
					return;
				}

				options = options || {};

				if (!options.force) {
					evt.preventDefault();

					if (t.submitting) {
						return;
					}

					mailru.log('compose.submit', options);

					var editor = t.getEditor();
					var $editorElement = t.getEditorElement();
					var appearance = t.getAppearance();
					var fileUploader = t.getFileUploader();

					if (!t.validator.validate()) {
						// pass
					}
					else if (fileUploader.isLoading()) {
						t._disableControls();

						mailru.Notify.add('send', {
							group: 'ajax',
							delay: 0
						});

						fileUploader.one('onQueueFinsh', {'scope': t}, function(evt) {
							evt.data.scope.$form.trigger('submit');
						});
					}
					else {
						var isShowEmptyConfirm = !fileUploader.filesCount && o.isNewMessage &&
								(t.isEmptyContent() || t.isDefaultContent());

						var from = t.$form.find('.js-compose__select_email .dropdown__button-inline__text')
								.text() || mailru.useremail;

						var collector_edit = {};

						// MAIL-16130
						if (mailru.hasCollectors()) {
							Object.forEach(mailru.collectors, function(collector) {
								if (collector.email == from && /auth|extra_auth/.test(collector.error)) {
									collector_edit = collector;
								}
							});
						}

						if (isShowEmptyConfirm && !(t.isDraft() || t.isForward())) {
							var layer = t.getSubmitEmptyMessageConfirmLayer();

							layer.one('callback', function(evt, status) {
								if (status) {
									t._submitEmptyMessageConfirmSuccess();
								}
							})[0].show();
						}
						else if (collector_edit.error) {
							LayerManager.show('collector_edit', {
								id:       collector_edit.id,
								notify:   false,
								complete: function(layer, response) {
									if (response.isOk()) {
										t._submitEmptyMessageConfirmSuccess();
									}
								}
							});
						}
						else {
							t.submitting = 1;

							if (t.isHTMLMode()) {
								var editorContent = appearance.getHTML(editor.getContent({'format': 'raw'}));
								$editorElement.val(t._prepareContent(editorContent));
							}

							if( mailru.uiRadar )
								mailru.uiRadar('sendmsgok')('all')('prepare');

							t.triggerHandler('submit', [this]);

							var $charsetInput = $('input[name="old_charset"]:first', t.$form);
							var charset = $charsetInput.val();

							$charsetInput.val('utf-8');

							var attachIds = [], attachments = t.fileUploader.getUploadedAttachments();

							if ($.isArray(attachments)) {
								for (var i=attachments.length; i--; ) {
									attachIds.push(attachments[i].fileid);
								}
							}
							$('input[name="attached_ids"]', t.$form).val(attachIds.join(','));

							var requestId = jsCore.getUniqId() + jsCore.getRandomHash(10, false, true, false);

							if (t.xhrs['send']) {
								t.xhrs['send'].abort();
							}

							var formData = t.$form.toObject();

							if (mailru.IsNewComposeDesign) {
								var name_header;

								if (mailru.IsExternalAccount) {
									if (formData.Name) {
										name_header = formData.Name = formData.Name.trim();
									}
								}
								else if (mailru.EnableIMAP && mailru.hasCollectors() &&
									t.$form.find('.js-compose__select_email')[0])
								{
									name_header = this.options.RealNames[formData.RealName];

									if (name_header) {
										name_header = name_header.name;
									}
									else {
										name_header = mailru.username;
									}
								}

								if (name_header) {
									name_header = name_header + ' <' + from + '>';
									formData.From = name_header.replace(/\s+/g, ' ');
								}

								// MAIL-11677
								if (/artamonova@corp|anti_gona@mail/i.test(mailru.useremail)) {
									this._logEditorFlags(this.oldEditorFlags, mailru.EditorFlags, formData, this.isNew(), requestId);
								}

								// mail-12747 always save editor flags
								formData['EditorFlags'] = this.oldEditorFlags = mailru.EditorFlags;
							}

							if (this.isForward() || this.isReply()) {
								var folder = mailru.Folders.getSafe();
								if (folder) {
									formData['folder'] = folder.Id;
								}
							}

							formData['SocialBitmask'] = mailru['SocialBitmask'];

							delete formData['send'];
							delete formData['draft'];
							delete formData['cancel'];
							delete formData['Filedata'];

							t.xhrs['send'] = mailru.Ajax({
								type: 'POST',
								url: t.sentmsgUrl + '?func_name=send&send=1&logid=' + requestId,
								data: formData,
								isUser: true,
								sentmsg: true,
								loading: 'send',
								storeMe: 'sentmsg',
								complete: t._sendComplete.bind(t, requestId, formData)
							});

							mailru.HTMLCompose = t.isHTMLMode();

							$charsetInput.val(charset);

							if( mailru.uiRadar ) mailru.uiRadar('sendmsgok')('prepare', 1);

							t._removeUnloadConfirm();
							t._disableControls();
							t._removeAutoSaveInterval();
							t._sendGstat();
							t.disableEdit();
						}
					}

					$win.triggerHandler('sendClick.compose');
				}
			},

			_logEditorFlags: function (before, after, formData, isnew, requestId) {
				var _log = {
					log: 'MAIL_11677_' + (isnew ? 'new' : 'other'),
					before: String(before),
					after: String(after)
				};
				$.each(['To', 'CC', 'BCC', 're_msg', 'draft_msg', 'fwd_msg'], function (k, v) {
					_log[v] = String(Number($.trim(formData[v]) !== ''));
				});
				_log.requestId = requestId;
				_log.email = mailru.useremail;
				mailru.gstat(_log, 'ua=1');
			},

			getEditorFlags: function () {
				// mail-12747 instead of iterating $selectFieldsDropdownItems we always use mailru.EditorFlags and update it on every change
				return mailru.EditorFlags;
			},

			setEditorFlags: function() {
				// mail-12747 send editor flags mask
				var tokens = mailru.tokens['ajax_settings'];
				if (tokens && tokens['form_sign'] && tokens['form_token']) {
					this.saveEditorFlags(tokens['form_sign'], tokens['form_token']);
				} else {
					mailru.API.post('tokens', function (result) {
						if (result.isOK()) {
							var tokens = String(result.getBody().token).split(':');
							mailru.tokens['ajax_settings'] = {
								form_sign: tokens[0],
								form_token: tokens[1]
							};
							this.saveEditorFlags(tokens[0], tokens[1]);
						}
					}.bind(this) );
				}
			},

			saveEditorFlags: function(form_sign, form_token) {
				if (this.xhrs['flags']) {
					this.xhrs['flags'].abort();
				}

				this.xhrs['flags'] = mailru.Ajax({
					url: '/settings/ajax_settings?ajax_call=1&func_name=set_editorflags&editor_flags=' + mailru.EditorFlags,
					type: 'GET',
					data: {
						form_sign:  form_sign,
						form_token: form_token
					} // @todo error log
				});
			},

			_sendComplete: function(requestId, formData, result) {

				if( mailru.uiRadar ) mailru.uiRadar('sendmsgok')('all', 1)(true);

				var t = this, xhr = result.getXHR(), data, success, _log, errorStr = Lang.get('compose.send_mail_error');

				if (result.isOK()) {
					data = result.getData();
				} else {

					if (result.getStatus() == 'parsererror') {
						_log = {
							log: 'sentmsgparseerror3',
							statusText: xhr.statusText,
							error: result.getError().toString(),
							email: mailru.useremail
						};
					} else {
						_log = {
							log: 'sentmsg',
							logid: requestId,
							status: 'no_result_ok',
							result: result.getStatus(),
							email: mailru.useremail
						};
					}
				}

				if (data) {

					if (data.ShowSecurityImage) {
						t._showCaptcha(data.AccountVerified);
					} else if (data.Error) {

						t.triggerHandler('submiterror', [this, data]);
						t._showErrorSaveMailMessage(data.Error, 1);

//						_log = {
//							log: 'sentmsg',
//							logid: requestId,
//							status: 'error',
//							value: data.Error,
//							email: mailru.useremail
//						};
					} else {

						if (data.Ok) {
							success = 1;

							var view = jsView.get('sendmsgok');

							if( mailru.v2 && mailru.view && mailru.view.compose ){
								mailru.view.compose.SENT_HTML = data.Ok;
							}
							else if( view ){
								view.preload(data.Ok);
								t.enableEdit();
							}

							if (data.redir_url) {
								if( !mailru.isReadMsgPage() || !store.get('labs.compose.stay_in_letter') ){
									jsHistory.set(data.redir_url);
								}
								else {
									mailru.Notify.add('ok', 'letter.sent');
									this.$form.trigger('lettersent');
								}
							} else {
								_log = {
									log: 'sentmsg',
									logid: requestId,
									status: 'empty_field_redir_url',
									email: mailru.useremail
								};
							}

						} else {
							_log = {
								log: 'sentmsg',
								logid: requestId,
								status: 'empty_field_ok',
								email: mailru.useremail
							};
						}
					}
				} else if (!result.isAbort()) {

					if (!_log) {
						_log = {
							log: 'sentmsg',
							logid: requestId,
							status: 'no_data',
							email: mailru.useremail
						};
					}

					setTimeout(function() {
						// in some case notify.error can be launched, hide it.
						mailru.Notify.hide('ajax');
					}, 1000);
					// mail-11275 show bubble instead of error block
					mailru.Notify.add('error', { text: Lang.get('notify.send.error'), delay: 6 });
//					t._showErrorSaveMailMessage(errorStr);
				}

				if (_log) {
					_log.xstatus = xhr.status;
					_log.xstate = xhr.readyState;
					_log.responseText = xhr.responseText;

					if (xhr.getAllResponseHeaders) {
						_log.headers = xhr.getAllResponseHeaders();
					}

					(new Image).src = '//gstat.' + mailru.staticDomainName + '/gstat?ua=1&logme=' + encodeURIComponent($.param(_log));
				}

				if (success) {
					// MAIL-6939
					var names = ['To', 'CC', 'BCC']
						, i = names.length
						, $input
						, value
					;

					for( ; i--; ) {
						$input = t._formElm(names[i]);
						if( value = $input.val() ) {
							if( mailru.ComposeLabels || mailru.CanUseNewAddressbookSuggests ) {
								var widget = mailru.ComposeLabels ?
											$input.closest('.js-compose-labels').composeLabels("widget")
											: $input.addressbookSuggest("widget");
								if( widget ){ // @see  https://jira.mail.ru/browse/MAIL-13780
									mailru.Utils.addToAddressBook( widget.getUsed() );
								}
							}
							else {
								mailru.Utils.addToAddressBook( $.Autocompleter.trimWords( value ) );
							}
						}
					}

					// if external account we'd show <from> and hide <name> field
					if (mailru.IsExternalAccount && formData.Name) {
						this.$form.find('.js-compose__header__from').show()
							.addClass('js-row-From')
								.find('.js-compose__header__from_name')
									.text(formData.Name);

						this.$form.find('.js-compose__header__name')
							.remove();
					}

					this._updateAffectedMessage(null);
					t.triggerHandler('submitsuccess', [this, data]);
					Counter.sb(326613);
				}
				else {
					t._enableControls();
					t._setUnloadConfirm();
				}

				t.submitting = 0;

				t._hideLoading();
				t.enableEdit();
			},

			_updateAffectedMessage: function (draftId) {
				var message = this._getAffectedMessage(), mode = this.getDraftModeForSave();
				if (mailru.MessageFromDraft && message) {
					if (draftId) {
						message[mode + '_draft'] = message.last_draft = draftId;
						message.last_draft_type = mode;
					} else {
						message[mode + '_draft'] = message.last_draft = message.last_draft_type = null;
						$.each(['reply','replyall','forward'], function (k, v) {
							if (message[v + '_draft']) {
								message.last_draft = message[v + '_draft'];
								message.last_draft_type = v;
							}
						});
					}
				}
			},

			getDraftModeForSave: function () {
				var mode = this.messageMode;
				var replyall = !!(~this._formElm('To').val().indexOf(',') || this._formElm('CC').val());
				if (mode == 'replyall' && !replyall) {
					mode = 'reply';
				}
				return mode;
			},

			_getAffectedMessage: function () {
				var message, affectedId = this._formElm('re_msg').val() || this._formElm('fwd_msg').val();
				if (affectedId) {
					message = mailru.Messages.get(affectedId);
				}
				return message;
			},

			_getMessageMode: function () {
				var mode = 'reply';
				var url = jsHistory.get() || '';
				var ReadmsgCompose = jsView.get('readmsg_compose');

				if( ReadmsgCompose ){
					if (mailru.isReadMsgPage()) {
						url = ReadmsgCompose._query;
					}

					var matches = url.match(/(replyall)/i);
					if (matches) {
						mode = matches[1];
					} else if (matches = url.match(/(reply|forward)/i)) {
						mode = matches[1];
					}
				}

				return mode;
			},

			_closeDraftContainer: function () {
				this.$removeDraftContainer.display(0);
				mailru.Balloon.updateStatus(mailru.HelperIndex.draftInfomessage);
				Counter.sb(1186800);
			},

			_removeDraftContainer: function (evt) {
				evt.preventDefault();
				var draftId = this._formElm('draft_msg').val();
				if (draftId) {
					mailru.Ajax({
						url: '/cgi-bin/movemsg',
						type: 'POST',
						data: {
							id: draftId,
							remove: 1,
							noredir: 1,
							folder: mailru.Folder.TRASH
						},
						complete: function (response) {

							var url = jsHistory.get();
							var ReadmsgCompose = jsView.get('readmsg_compose');
							var SentmsgView = jsView.get('sentmsg');

							if (mailru.isReadMsgPage()) {
								url = ReadmsgCompose._query;
							}

							this._updateAffectedMessage(null);

							if (mailru.isComposePage()) {
								SentmsgView.load(url);
							} else if (mailru.isReadMsgPage()) {
								ReadmsgCompose.load(url, this.messageMode);
							}
							Counter.sb(1033805);
						}.bind(this)
					});
				}
			},

			_submitEmptyMessageConfirmSuccess: function()
			{
				var t = this, o = t.options;
				o.isNewMessage = 0;
				t.$form.trigger('submit');
			},

			_send: function(evt) {

				evt.preventDefault();

				var t = this;

				if (t.$sendButton.attr('disabled')) {
					return;
				}

				t.$form.trigger('submit');
			},

			_toDrafts: function(evt)
			{
				var t = this;

				if (t.$draftButton.attr('disabled')) {
					return;
				}

				var fileUploader = t.getFileUploader();

				if (fileUploader.isLoading()) {
					t._disableSaveControl();
					t._removeAutoSaveInterval();
					fileUploader.one('onQueueFinsh', {'scope': t}, function(evt) {
						var scope = evt.data.scope;
						scope._enableSave();
						scope.$draftButton.first().click();
					});
				} else {
					t._save();
				}

				$win.triggerHandler('saveClick.compose');
				evt.preventDefault();
			},

			_cancel: function(evt)
			{
				evt.preventDefault();

				var t = this;

				if (t.$cancelButton.attr('disabled')) {
					return;
				}

				if (t.triggerHandler('cancel') !== false) {
					jsHistory.set(jsHistory.previous || '/messages/inbox');
				}

				$win.triggerHandler('cancelClick.compose');
				t.$form.trigger('composecancel');
			},

			_openAddressBook: function(addto)
			{
				mailru.Utils.openAddressbookPopup(addto);
			},

			_mobileVersionInit: function()
			{
				var t = this, o = t.options;
				var $editorToolbar = t.getEditorToolbar();
				$editorToolbar.hide();
				$('.mlr-snd_book', t.$form).hide();

				if (o.isStatic) {
					t._mobileVersionReady();
					t.triggerHandler('redraw');
				}

				t.triggerHandler('init');
				$win.triggerHandler('init.'+o.name);

				jsCore.notify(o.name+'.init');
			},

			_mobileVersionReady: function()
			{
				var t = this, o = t.options;
				var text = o.text;
				var $mainFrame = t.getMainFrame();

				t._HTMLToTextSuccessCallback(text);

				$mainFrame.removeClass('jsvh');

				t.defaultBodyText = text;
				t.currentFormData = t.$form.serialize();

				t.triggerHandler('ready');
			},

			_deviceVersionInit: function()
			{
				var t = this, o = t.options;
				var $editorToolbar = t.getEditorToolbar();
				var $mainFrame = t.getMainFrame();

				$mainFrame.removeClass('jsvh');

				$editorToolbar.hide();


				t.$form.bind('submit', $.proxy(t._onSubmit, t));


				if(mailru.v2) {
					t.bind('send', $.proxy(t._send, t));
				} else {
					t.$sendButton.bind('click', $.proxy(t._send, t));
				}
				t.$draftButton.bind('click', $.proxy(t._toDrafts, t));
				t.$cancelButton.bind('click', $.proxy(t._cancel, t));

				if (o.isStatic) {
					t._deviceVersionReady();
					t.triggerHandler('redraw');
				}

				this._fileUploaderInit();

				t.triggerHandler('init');
				$win.triggerHandler('init.'+o.name);

				jsCore.notify(o.name+'.init');
			},

			_deviceVersionReady: function()
			{
				var t = this, o = t.options;
				var text = o.text;
				var $mainFrame = t.getMainFrame();

				t._HTMLToTextSuccessCallback(text);

				$mainFrame.removeClass('jsvh');

				t.defaultBodyText = text;
				t.currentFormData = t.$form.serialize();

				t._setResizeEvent();
				t._setKeyboardEvent();
				t._setUnloadConfirm();
				t._activeJsView();
				t._updateGeometry();

				t.triggerHandler('ready');
				setTimeout(function (){ $win.triggerHandler('ready.'+o.name); }, 0);
			},

			_fileUploaderInit: function (){
				var fileUploader = this.getFileUploader(), _this = this;

				fileUploader.bind({
					'fileLoadError': function(evt, fileData) {
						_this._showErrorSaveMailMessage(fileData.Error.replace('</center>', ''));
					},

					'onFilesLinkCodeChange': function(evt, filesId) {
						$('input[name="files_id"]', _this.$form).val(filesId);
					},

					'onFilesLinkCodeAdded': function(evt, filesId) {
						var $inp = $('input[name="files_id"]', _this.$form), val = $.trim($inp.val());
						$inp.val( [].concat(filesId, val ? val.split(',') : []).join(',') );
					},

					'onQueueChanged': function() {
						_this._enableSave();
					}
				});

				this.bind('unactive reset redraw', function(evt) {
					var type = evt.type;
					if( type == 'unactive' ){
						fileUploader.unactive();
					}
					else if( type == 'reset' ){
						fileUploader.reset();
					}
					else if( type == 'redraw' ){
						fileUploader.redraw(this.options.fileUploaderSettings);
					}
				});
			},

			_fullVersionInit: function()
			{
				var t = this, o = t.options;
				var editor = t.getEditor();
				var appearance = t.getAppearance();
				var $editorElement = t.getEditorElement();
				var $mainFrame = t.getMainFrame();
				var $editorFrame = t.getEditorFrame();

				if ($.browser.opera) {
					$editorElement[0].spellcheck = editor.getBody().spellcheck = 0;
				}

				this._fileUploaderInit();

				t.$form.bind('submit', $.proxy(t._onSubmit, t));

				if (mailru.v2) {
					t.bind('send', $.proxy(t._send, t));
				} else {
					t.$sendButton.bind('click', $.proxy(t._send, t));
				}
				t.$draftButton.bind('click', $.proxy(t._toDrafts, t));
				t.$cancelButton.bind('click', $.proxy(t._cancel, t));

				t.$sendButton.attr('title', 'Ctrl+Enter');
				t.$draftButton.attr('title', 'Ctrl+S');

//				t.$removeDraftContainer.find('.js-link').bind('click', t._removeDraftContainer.bind(this));
				t.$removeDraftContainer.find('.js-close').bind('click', t._closeDraftContainer.bind(this));

				$mainFrame.bind('click', {'scope': t}, t._frameClick);

				$editorFrame.attr({
					'hideFocus': 'true',
					'tabindex': $editorElement.attr('tabindex'),
					'allowtransparency': 'true'
				});

				$editorElement.click(function(evt) {
					evt.stopPropagation();
				});

				if (mailru.IsNewComposeDesign) {

					this.decoration.getItem('cards').bind({
						select: function (evt, category, item) {

							var cards = evt.currentTarget, $subject = this._formElm('Subject'), subject = $.trim($subject.val());

							if (!subject || subject == this.previosSubject) {
								$subject.val(this.previosSubject = item.title);
							}

							var editor = this.getEditor();
							editor.focus();

							var selection = editor.selection;

							if (selection.getNode() == editor.getDoc()) {
								var rng = selection.dom.createRng();
								rng.setStart(editor.getBody(), 0);
								rng.setEnd(editor.getBody(), 0);
								selection.setRng(rng);
							}

							var cardHTML = cards.getPreviewHTML(category, item);

							var $cardContainer = $(editor.dom.get(cards.cardContainerId));

							if ($cardContainer.length) {
								$cardContainer.replaceWith(cardHTML);
							} else {
								selection.setContent(cardHTML);
							}

							var $newCardContainer = $(editor.dom.get(cards.cardContainerId));

							var marker = editor.dom.get(cards.cardMarkerId);

							selection.select(marker);
							selection.collapse();

							this._updateFrameGeometry(undefined, $newCardContainer.height() + 150);
							this._updateEditorGeometry();

							$win.triggerHandler('editorToolbarButtonCardSelect.compose');
						}.bind(this),

						clear: function (evt) {

							var cards = evt.currentTarget, $subject = this._formElm('Subject'), subject = $.trim($subject.val());
							var editor = this.getEditor(), $cardContainer = $(editor.dom.get(cards.cardContainerId));

							if (subject == this.previosSubject) {
								$subject.val('');
							}

							if ($cardContainer.length) {
								$cardContainer.remove();
							}

							this.decoration.hide();

						}.bind(this)
					});

					this.decoration.getItem('appearance').bind({
						select: function (evt, category, item) {
							var appearance = this.getAppearance();
							appearance.setTemplate(item.id);
						}.bind(this),

						clear: function (evt) {
							var appearance = this.getAppearance();
							appearance.reset();

							this.decoration.hide();
						}.bind(this)
					});

					this.decoration.bind('show hide', function (evt) {
						var editor = this.getEditor();
						var controls = {
							cards: editor.controlManager.get('cards'),
							appearance: editor.controlManager.get('design')
						};
						if (evt.type == 'hide') {
							$.each(controls, function (k, control) {
								if (control) {
									control.setActive(false);
								}
							});
						}
						this._updateGeometry();
					}.bind(this));

				} else {

					if (mailru.ComposeCards) {

						$(o.domIDs.composeEditor_toolbar2, this.$form).css('left', '54%');

						this.cards.bind({
							'click': function (evt, category, card) {

								var $subject = this._formElm('Subject'), subject = $.trim($subject.val());

								if (!subject || subject == this.previosSubject) {
									$subject.val(this.previosSubject = card.title);
								}

								var editor = this.getEditor();
								editor.focus();

								var selection = editor.selection;

								if (selection.getNode() == editor.getDoc()) {
									var rng = selection.dom.createRng();
									rng.setStart(editor.getBody(), 0);
									rng.setEnd(editor.getBody(), 0);
									selection.setRng(rng);
								}

								var cardHTML = this.cards.getPreviewHTML(category, card);

								var $cardContainer = $(editor.dom.get(this.cards.cardContainerId));

								if ($cardContainer.length) {
									$cardContainer.replaceWith(cardHTML);
								} else {
									selection.setContent(cardHTML);
								}

								var $newCardContainer = $(editor.dom.get(this.cards.cardContainerId));

								var marker = editor.dom.get(this.cards.cardMarkerId);

								selection.select(marker);
								selection.collapse();

								this._updateFrameGeometry(undefined, $newCardContainer.height() + 150);
								this._updateEditorGeometry();

							}.bind(this),

							'show hide': function (evt) {
								var editor = this.getEditor();
								var control = editor.controlManager.get('cards');
								if (control) {
									control.setActive(evt.type == 'show');
								}

								this._updateGeometry();

							}.bind(this)
						});
					}
				}

				if (mailru.ComposeCards) {

					this.bind('submit', function(evt) {
						var $editorElement = this.getEditorElement(), selectedCard;

						if (mailru.IsNewComposeDesign) {
							var cards = this.decoration.getItem('cards');
							selectedCard = cards.selectedItem;
							if (selectedCard && selectedCard.counter && $editorElement.val().indexOf(cards.cardId) !== -1) {
								new Image().src = '//rs.' + mailru.SingleDomainName + '/d' + selectedCard.counter + '.gif?' + Math.random();
							}
						} else {
							selectedCard = this.cards.selectedCard;
							if (selectedCard && selectedCard.counter && $editorElement.val().indexOf(this.cards.cardId) !== -1) {
								new Image().src = '//rs.' + mailru.SingleDomainName + '/d' + selectedCard.counter + '.gif?' + Math.random();
							}
						}

					}.bind(this));
				}

				appearance.bind({

					'changeTemplate': $.proxy(function(evt, template)
					{
						var t = this;
						var $editorFrame = t.getEditorFrame();
						var $editorFrameBody = t.getEditorFrameBody();

						$editorFrameBody.css({
							'backgroundColor': template.background || '',
							'color': template.color || '',
							'fontFamily': template.fontFamily || '',
							'textAlign': template.textAlign || '',
							'overflow': 'hidden'
						});

						$editorFrame.attr('scrolling', 'no');
					}, t),

					'clear': $.proxy(function()
					{
						var t = this;
						var $editorFrame = t.getEditorFrame();
						var $editorFrameBody = t.getEditorFrameBody();

						$editorFrameBody.css({
							'backgroundColor': '',
							'color': '',
							'fontFamily': '',
							'textAlign': '',
							'overflow': 'auto'
						});

						$editorFrame.attr('scrolling', 'auto');
					}, t),

					'showLayer hideLayer': $.proxy(function(evt)
					{
						var t = this;
						var editor = t.getEditor();
						var control = editor.controlManager.get('design');
						if (control)
							control.setActive(evt.type == 'showLayer');
					}, t),

					'showLayer hideLayer changeTemplate clear': $.proxy(t._updateGeometry, t),

					'changeTemplate clear': $.proxy(function()
					{
						var t = this;
						var currentTemplate = t.getAppearance().getCurrentTemplate();
						$('input[name="template_id"]:first', t.$form).val(currentTemplate ? currentTemplate.id : '');
					}, t)
				});

				t.bind('enableTextEditor', function()
				{
					var $mainFrame = this.getMainFrame();
					$mainFrame.css({
						'width': 'auto',
						'height': 'auto'
					});
				});

				// mega fix for opera (not change textarea value)
				if ($.browser.opera)
				{
					t.one('enableTextEditor', function()
					{
						var t = this, $editorElement = t.getEditorElement();
						setTimeout(function()
						{
							$editorElement.css('display', 'block');
						}, 0);
					});
				}

				this.bind('unactive reset redraw', function(evt) {
					var type = evt.type;
					if (type == 'unactive') {
						this.appearance.unactive();
					} else if (type == 'reset') {
						this.appearance.reset();
						if (mailru.IsNewComposeDesign) {
							this.decoration.hide();
						} else {
							this.cards.reset();
						}
					} else if (type == 'redraw') {
						if (!mailru.IsNewComposeDesign) {
							this.cards.redraw(this.options.fileUploaderSettings);
						}
					}
				});

				if (o.ShowSecurityImage) {
					t.one('ready', function() {
						this._showCaptcha(mailru.AccountVerified);
					});
				}

				editor.selection.onSetContent.add(t._setUpdateEditorGeometryTimeout, t);
				editor.onEvent.add(t._setUpdateEditorGeometryTimeout, t);
				editor.onSetContent.add(t._setUpdateEditorGeometryTimeout, t);
				editor.onClick.add(function(ed, evt) {
					if (evt.target.nodeName == 'A')
						window.open(evt.target.href);
				}, t);

				function buttonDropDownClick(c) {
					var id = c.id.replace(editor.id + '_', '');
					$win.triggerHandler('editorToolbarButtonDropDownClick.compose', [id]);
				}

				$.each(['emotions', 'forecolor','backcolor','fontactions','justifyselect','textindentactions','bullistactions'], function (k, v) {
					editor.controlManager.get(v).onShowMenu.add(buttonDropDownClick);
				});

				var signatureControl = editor.controlManager.get('signature');
				if(signatureControl) { // MAIL-12142
					signatureControl.onShowMenu.add(buttonDropDownClick);
				}

				editor.onExecCommand.add(function(ed, cmd, ui, val, a) {

					var appearance = this.getAppearance();
					var controls = {
						cards: ed.controlManager.get('cards'),
						appearance: ed.controlManager.get('design')
					};

					if (cmd == 'mceAppKeyboard') {
						this.keyboard();
					} else if (cmd == 'mceAppTransfer') {
						this.transfer();
					} else if (cmd == 'mceAppTranslit') {
						this.translit();
					} else if (cmd == 'mceAppSpelling') {
						this.spelling();
					} else if (cmd == 'mceEnableTextEditor') {
						this.enableTextEditor();
					} else if (cmd == 'mceEnableHTMLEditor') {
						this.enableHTMLEditor();
					} else if (cmd == 'mceSetSignature') {
						this._setRealName(val);
						$win.triggerHandler('editorToolbarSignatureClick.compose');
					}

					if (mailru.IsNewComposeDesign) {

						if (cmd == 'mceShowCards' || cmd == 'mceHideCards' || cmd == 'mceShowTemplates' || cmd == 'mceHideTemplates') {
							this.decoration.hide();
						}

						if (cmd == 'mceShowCards') {
							this.decoration.show('cards', 0);
							controls['cards'].setActive(true);
						} else if (cmd == 'mceShowTemplates') {
							this.decoration.show('appearance', 0);
							controls['appearance'].setActive(true);
						}

					} else {
						if (cmd == 'mceShowCards') {
							this.cards.show();
						} else if (cmd == 'mceHideCards') {
							this.cards.hide();
						} else if (cmd == 'mceShowTemplates') {
							appearance.applyTheme(0);
							appearance.showLayer();
						} else if (cmd == 'mceHideTemplates') {
							appearance.hideLayer();
						}
					}

					$win.triggerHandler('editorToolbarButtonClick.compose', [cmd]);
				}, t);

				t._initDropFunctional();

				if (o.isStatic) {
					t._fullVersionReady();
					t.triggerHandler('redraw');
				}

				t.triggerHandler('init');
				$win.triggerHandler('init.'+o.name);

				jsCore.notify(o.name+'.init');
			},

			_fullVersionReady: function()
			{
				var t = this, o = t.options;
				var editor = t.getEditor();
				var $mainFrame = t.getMainFrame();
				var appearance = t.getAppearance();
				var isHTMLMessage = $('input[name="HTMLMessage"]', t.$form).val() > 0;
				var text = o.text, html = o.html;

				editor.undoManager.clear();

				// problem in IE6
				try {
					if (isHTMLMessage)
					{
						var templateId = appearance.getTemplateId(html);

						if (templateId)
						{
							appearance.setTemplate(templateId);
							html = appearance.removeTemplate(html);
						}

						t._textToHTMLSuccessCallback(html);
					}
					else
					{
						t._HTMLToTextSuccessCallback(text);
						editor.setContent(html, { 'format': 'raw' });
					}
				} catch (e){}

				$mainFrame.removeClass('jsvh');

				this.inlineFiles = [];
				this.defaultBodyHTML = editor.getContent({'format': 'raw'});
				this.defaultBodyText = text;

				t._setResizeEvent();
				t._setKeyboardEvent();
				t._enableSave();
				t._setUnloadConfirm();
				t._loadGstat();

				t._activeJsView();

				editor.onInit.dispatch(editor);

				t._updateGeometry();

				t.focus();

				this.currentFormData = t.$form.serialize();

				t.triggerHandler('ready');

				mailru.Utils.getAddressBook();

				var Folder = mailru.Folders.getSafe();
				if (Folder && Folder.Id != mailru.Folder.DRAFTS && this.isDraft() && (this.isReply() || this.isForward())) {
					if (!mailru.Balloon.isClosed(mailru.HelperIndex.draftInfomessage)) {
						this.$removeDraftContainer.display(1);
						Counter.d(1186799);
					}
				} else {
					this.$removeDraftContainer.display(0);
				}

				if (mailru.IsNewComposeDesign) {
					// mail-12925
					var balloon = mailru.Balloon.getItemById(mailru.HelperIndex.composeSelectFields);
					if(balloon) {
						mailru.Balloon.itemRedraw(balloon);
					}
				}

				setTimeout(function (){ $win.triggerHandler('ready.'+o.name); }, 0);
			},

			_activeJsView: function (){
				ajs.wait('mailru.Views.ready', $D(this, function (){
					var t = this, view = jsView.get(t.options.name);
					if( view ){
						view.$Loader && view.$Loader.hide();

						if( view.isActive() ){
							view.getView().show();
							$win.resize();

							if ($.browser.msie && parseInt($.browser.version) < 8) {
								setTimeout(function (){
									var $editorFrameBody = t.getEditorFrameBody();
									$editorFrameBody[0].innerHTML = $editorFrameBody[0].innerHTML + '';
									t.setCaretPositionInStart();
								}, 0);
							}
						}
						t.focus();
					}
				}));
			},

			_showCaptcha: function(verified)
			{
				if (verified)
				{
					$R('{mailru'+'.compose}mailru.Compose.Captcha', $.proxy(function()
					{
						var t = this, captcha = t.captcha;
						if (!captcha)
						{
							captcha = t.captcha = new mailru.Compose.Captcha({is_verified: true});
							captcha.bind('checkSuccess', {'scope': t}, t._captchaCheckSuccess);
						}
						captcha.show();
					}, this));
				}
				else
				{
					$R('{mailru'+'.compose}mailru.Compose.CaptchaCombine', $.proxy(function()
					{
						var t = this, captcha = t.captchaVerified;
						if (!captcha)
						{
							captcha = t.captchaVerified = new mailru.Compose.CaptchaCombine({is_verified:false});
							captcha.bind('verifySuccess', {'scope': t}, t._captchaCheckSuccess);
						}
						captcha.show();
					}, this));
				}
			},

			_captchaCheckSuccess: function(evt, code)
			{
				var t = this, scope = evt.data.scope;
				$('input[name="security_image_word"]', scope.$form).val(code || '');
				t.hide();
				scope.$form.trigger('submit');
			},

			_initDropFunctional: function()
			{
				if( true ) return; // MAIL-1642: Disbaled
				if (!window.FileReader || !window.File) return;

				var t = this, editor = t.getEditor(), fade = LayerFade.getInstance(), timer;

				var $div = $('<div class="dragFilesTooltip"><span>' + Lang.get('compose.drag_files') + '</span></div>').appendTo($('body:first,#ScrollBodyInner').last());

				$(editor.getDoc().documentElement).add($win).bind('dragstart', {'scope': t}, function(evt) {
					var scope = evt.data.scope;
					scope.isDrag = 1;
					var $col = $(evt.currentTarget).add($(evt.target));
					$col.one('dragend.drag', {'$col': $col, 'scope': scope}, function(evt) {
						evt.data.scope.isDrag = 0;
						evt.data.$col.unbind('.drag');
					});
				})
				.bind('dragenter dragover dragleave dragexit drop dragend', {'scope': t}, function(evt) {

					var scope = evt.data.scope;

					if (scope.isDrag) return;

					evt.stopPropagation();
					evt.preventDefault();

					clearTimeout(timer);

					if (evt.type == 'dragenter' || evt.type == 'dragover' || evt.type == 'drag') {
						var windowHeight = ajs.windowHeight();
						var scrollTop = Math.max($doc.scrollTop(), $('#ScrollBody').scrollTop());
						var y = scrollTop + ((windowHeight / 2) * 0.6);

						fade.show();
						$div.css('top', y).show();
					}
					else {
						timer = setTimeout(function() {
							$div.hide();
							fade.hide();
						}, 100);
					}
				})
				.last().bind('drop', {'scope': t}, function(evt) {

					var scope = evt.data.scope;

					if (scope.isDrag) return;

					var dataTransfer = evt.dataTransfer || {};
					var files = $.grep(dataTransfer.files || [], function(v) {
						return v.type || v.size;
					});

					evt.preventDefault();

					$div.hide();
					fade.hide();

					clearTimeout(timer);

					scope.fileUploader._addDropFiles(files);
//					scope._addDropFiles(files);
				});
			},

			_addDropFiles: function(files)
			{
				var t = this;
				for (var file, i=0, l=files.length; i<l; i++)
				{
					file = files[i];
					if (/^image\//i.test(file.type))
					{
						t._addDropImage(file);
					}
					else
					{
						t.fileUploader._addDropFile(file);
					}
				}
			},

			_addDropImage: function(file)
			{
				var t = this;
				var editor = t.getEditor();
				var previewId = 'id' + +new Date;
				var previewHTML = '<img id="' + previewId + '" src="//img.' + mailru.staticDomainName + '/0.gif" alt="" style="display: none;"/>';
				var selection = editor.selection;

				if (selection.getNode() == editor.getDoc())
				{
					var rng = selection.dom.createRng();
					rng.setStart(editor.getBody(), 0);
					rng.setEnd(editor.getBody(), 0);
					selection.setRng(rng);
				}

				selection.setContent(previewHTML);

				var $preview = $(editor.dom.get(previewId));

				selection.select($preview[0]);
				selection.collapse();

				var reader1 = new FileReader();
				$(reader1).data('data', {'$preview': $preview});
				reader1.onload = t._readAsDataURLLoad;
				reader1.readAsDataURL(file);

				var reader2 = new FileReader();
				$(reader2).data('data', {'cid': previewId, 'file': file, 'scope': t});
				reader2.onload = t._readAsBinaryStringLoad;
				reader2.readAsBinaryString(file);
			},

			_readAsDataURLLoad: function(evt)
			{
				var data = $(evt.target).data('data');
				data.$preview.load(function()
				{
					$(this).removeAttr('_mce_src').css({
						'opacity': 0.3, 'display': ''
					});
				}).attr('src', evt.target.result);
			},

			_readAsBinaryStringLoad: function(evt)
			{
				var data = $(evt.target).data('data'), t = data.scope, o = t.options;
				var boundary = +new Date;
				var requestBody = '--' + boundary + '\r\n'
					+ 'Content-Disposition: form-data; name="file' + boundary + '"; filename="' + encodeURIComponent(data.file.name) + '"' + '\r\n'
					+ 'Content-Type: ' + (data.file.type || 'application/octet-stream') + '\r\n\r\n'
					+ evt.target.result + '\r\n'
					+ '--' + boundary + '--';

				$.ajax({
					type: 'POST',
					url: '/cgi-bin/sentmsg?ajax_upload=1&dataType=script&cid=' + data.cid + '&message=' + o.MessageId,
					xhr: function()
					{
						var xhr = new XMLHttpRequest();
						if (xhr.sendAsBinary) xhr.send = xhr.sendAsBinary;
						return xhr;
					},
					data: requestBody,
					dataType: 'script',
					contentType: 'multipart/form-data; boundary=' + boundary
				});
			},

			_setKeyboardEvent: function () {
				this.$form.bind(($.browser.opera ? 'keypress' : 'keydown') + '.composeinner', this.keyboardObserver);
			},

			_setResizeEvent: function() {
				$win.bind('resize.composeinner', $.proxy(this._setUpdateEditorFrameOnResizeTimeout, this));
			},

			_prepareContent: function(text) {
				var t = this, o = t.options;

				text = t._prepareContentOnPaste(text);

				text = text.replace(/<meta[^>]*>/gim, '');

				text = mailru.Utils.Fishing.removeRedirectorFromText(text);

				$.each(o.map_inline_img, function(key, value) {
					var p = new RegExp('\\/\\/((ap?f\\d+(-\\d+)?)|(ima\\d+(-\\d+)?\\.dev))\\.mail\\.ru\\/cgi-bin\\/readmsg\\?id=' + key + '\\&(amp;)?mode=attachment[^"]*', 'gi');
					text = text.replace(p, value);
				});

				var rcid = function(m0, m1) {
					return m0.replace(/src="[^"]+"/, 'src="cid:' + m1 + '"');
				};

				$.each(t.inlineFiles, function(key, value) {
					text = text.replace(new RegExp('<img\\s+id="(' + value + ')"[^>]+>', 'gim'), rcid);
				});

				text = text.replace(_rurl717, 'http://');

				return text;
			},

			_prepareContentOnPaste: function(text)
			{
				if (!$.browser.msie)
					text = text.replace(/(^|(?:!(?:<a[^>]+)(?:\s+|)>))((?:https?|ftp):\/\/[^\s<>)\]'"!]+)/gim, '$1<a href="$2">$2</a>');
				text = text.replace(/"(?:[^"]+)?link\?check=1(?:[^"]+)url=([^"&]+).*?"/gi, function(m0, m1) {
					return '"' + unescape(m1) + '"';
				});
				return text;
			},

			_enableTextEditorConfirmSuccess: function()
			{
				var t = this;
				t._convertHTMLToText();
			},

			_enableTextEditor: function() {
				var editor = this.getEditor();
				var $editorElement = this.getEditorElement();
				var $editorContainer = this.getEditorContainer();
				var appearance = this.getAppearance();

				$editorElement.show();	// text
				$editorContainer.hide();	// html

				this.editorMode = mailru.Compose.Form.M_TEXT;
				this.$form.addClass('editorTextMode').removeClass('editorHTMLMode');

				appearance.reset();

				if (mailru.IsNewComposeDesign) {
					this.decoration.hide();
				} else {
					this.cards.hide();
				}

				$('input[name="HTMLMessage"]:first', this.$form).val(0);


				if( editor )
				{
					var controls = [
						editor.controlManager.get('design'),
						editor.controlManager.get('cards')
					];

					$.each(controls, function (k, control) {
						if (control) {
							control.setDisabled(true);
						}
					});
				}

				var domIDs	= this.options.domIDs;

				if (mailru.IsNewComposeDesign) {
					$(domIDs.composeEditor_toolbar1, this.$form).css('visibility', 'hidden');
					$(domIDs.composeEditor_toolbar3, this.$form).css('visibility', 'visible');
				} else {
					$(domIDs.composeEditor_toolbar1+','+domIDs.composeEditor_toolbar3, this.$form).css('visibility', 'hidden');
					$(domIDs.composeEditor_toolbar4, this.$form).css('visibility', 'visible');
				}

				this._updateGeometry();
			},

			_convertHTMLToText: function()
			{
				var t = this;
				var editor = t.getEditor();
				var text = editor.getContent({'format': 'raw'});

				if (t.xhrs['HTMLToText'])
					t.xhrs['HTMLToText'].abort();

				if ($.trim(text))
				{
					if (text === t.defaultBodyHTML)
					{
						t._HTMLToTextSuccessCallback(t.defaultBodyText);
					}
					else
					{
						t.xhrs['HTMLToText'] = AjaxCall.send(
							'/cgi-bin/ajax_text_utils',
							'to_text',
							[text],
							$.proxy(t._HTMLToTextSuccessCallback, t),
							$.proxy(t._HTMLToTextErrorCallback, t)
						);
					}
				}
				else
				{
					t._HTMLToTextSuccessCallback('');
				}
			},

			_enableTextEditorConfirmError: function()
			{
				var t = this;
				var editor = t.getEditor();
				editor.focus();
			},

			_HTMLToTextSuccessCallback: function(text)
			{
				var t = this, $editorElement = t.getEditorElement();
				t._enableTextEditor();
				$editorElement.val(text).show();
				t.setCaretPositionInStart();
				t.triggerHandler('enableTextEditor');
			},

			_HTMLToTextErrorCallback: function()
			{
			},

			_textToHTMLSuccessCallback: function(text)
			{
				var t = this;
				var editor = t.getEditor();
				var $editorContainer = t.getEditorContainer();

				t._enableHTMLEditor();
				//$editorContainer.show();

				editor.setContent(text, {'format': 'raw'});
				editor.save({'format': 'raw'});
				t.setCaretPositionInStart();
				t.triggerHandler('enableHTMLEditor');
			},

			_textToHTMLErrorCallback: function()
			{
			},

			_enableHTMLEditor: function()
			{
				var t = this;
				var editor = t.getEditor();
				var $editorElement = t.getEditorElement();
				var $editorContainer = t.getEditorContainer();

				$editorElement.hide();
				$editorContainer.show();

				t.editorMode = mailru.Compose.Form.M_HTML;
				t.$form.removeClass('editorTextMode').addClass('editorHTMLMode');

				$('input[name="HTMLMessage"]:first', t.$form).val(1);

				if( editor )
				{
					var controls = [
						editor.controlManager.get('design'),
						editor.controlManager.get('cards')
					];

					$.each(controls, function (k, control) {
						if (control) {
							control.setDisabled(false);
						}
					});
				}

				var domIDs	= t.options.domIDs;

				if (mailru.IsNewComposeDesign) {
					$(domIDs.composeEditor_toolbar1, this.$form).css('visibility', 'visible');
					$(domIDs.composeEditor_toolbar3, this.$form).css('visibility', 'hidden');
				} else {
					$(domIDs.composeEditor_toolbar1 +',' +domIDs.composeEditor_toolbar3, t.$form).css('visibility', 'visible');
					$(domIDs.composeEditor_toolbar4, t.$form).css('visibility', 'hidden');
				}

				t._updateGeometry();
			},

			_convertTextToHTML: function()
			{
				var t = this;
				var $editorElement = t.getEditorElement();
				var text = $editorElement.val();

				if (t.xhrs['textToHTML'])
					t.xhrs['textToHTML'].abort();

				if ($.trim(text))
				{
					if (text === t.defaultBodyText)
					{
						t._textToHTMLSuccessCallback(t.defaultBodyHTML);
					}
					else
					{
						t.xhrs['textToHTML'] = AjaxCall.send(
							'/cgi-bin/ajax_text_utils',
							'to_html',
							[text],
							$.proxy(t._textToHTMLSuccessCallback, t),
							$.proxy(t._textToHTMLErrorCallback, t)
						);
					}
				}
				else
				{
					t._textToHTMLSuccessCallback('');
				}
			},

			isEmptyContent: function()
			{
				var t = this, o = t.options;
				var $editorElement = t.getEditorElement();

				if (t.isHTMLMode())
				{
					var $editorFrameBody = t.getEditorFrameBody();
					return !o.issetContentPattern.test($editorFrameBody.html()) && !$.trim($editorFrameBody.text());
				}
				else
				{
					return !$.trim($editorElement.val());
				}
			},

			isDefaultContent: function()
			{
				var
					  t		= this
					, def	= $.trim(t.isHTMLMode() ? t.defaultBodyHTML : t.defaultBodyText)
					, cur	= $.trim(t.isHTMLMode() ? t.getEditor().getContent({'format': 'raw'}) : t.getEditorElement().val())
				;
				return	def == cur;
			},

			isNew: function () {
				return this.options['isNewMessage'];
			},

			isReply: function () {
				return this._formElm('re_msg').val() != '';
			},

			isReplyAll: function () {
				return this._formElm('re_msg').val() != '';
			},

			isDraft: function () {
				return !this.isNew() && this._formElm('draft_msg').val() != '';
			},

			isForward: function () {
				return this._formElm('fwd_msg').val() != '';
			},

			_hasFormatted: function()
			{
				var t = this, o = t.options;
				var editor = t.getEditor();
				return t.isHTMLMode() && o.hasFormattedPattern.test(editor.getContent({'format': 'raw'}));
			},

			_showCustomFields: function()
			{
				var t = this;
				t.$showCustomFieldsLink.parents('.mlr-snd_rw:first').hide();
				$('.mlr-snd_h', t.$form).removeClass('jsdn');
				$win.resize();
			},

			_hideCustomFields: function()
			{
				var t = this;
				t.$showCustomFieldsLink.parents('.mlr-snd_rw:first').show();
				$('.mlr-snd_h', t.$form).addClass('jsdn');
				$win.resize();
			},

			_loadGstat: function()
			{
				var t = this;
				var HTMLMessage = t.defaultHTMLMessage = $('input[name="HTMLMessage"]:first', t.$form).val() > 0;
				var re_msg = $('input[name="re_msg"]:first', t.$form).val();
				var draft_msg = $('input[name="draft_msg"]:first', t.$form).val();
				var fwd_msg = $('input[name="fwd_msg"]:first', t.$form).val();

				if (!draft_msg)
				{
					if (re_msg || fwd_msg)
					{
						Counter.gstat('compose.reply_' + (HTMLMessage ? 'new' : 'old') + '=1');
					}
					else
					{
						Counter.gstat('compose.compose_' + (HTMLMessage ? 'new' : 'old') + '=1');
					}
				}
			},

			_sendGstat: function()
			{
				var t = this;
				var HTMLMessage = $('input[name="HTMLMessage"]:first', t.$form).val() > 0;
				var re_msg = $('input[name="re_msg"]:first', t.$form).val();
				var draft_msg = $('input[name="draft_msg"]:first', t.$form).val();
				var fwd_msg = $('input[name="fwd_msg"]:first', t.$form).val();
				if (!draft_msg && HTMLMessage != t.defaultHTMLMessage)
				{
					if (re_msg || fwd_msg)
					{
						Counter.gstat('compose.reply_' + (HTMLMessage ? 'old2new' : 'new2old') + '=1');
					}
					else
					{
						Counter.gstat('compose.compose_' + (HTMLMessage ? 'old2new' : 'new2old') + '=1');
					}
				}
			},

			_openPopup: function(url, windowName, windowFeatures) {
				var t = this;
				try {
					var w = t.popups[windowName] = window.open(url, windowName, windowFeatures);
					w.focus();
				}
				catch(e){}
			},

			_showLoading: function(str)
			{
				var t = this;
				var $success = t.getSaveMailSuccessMessageContainer();
				var $error = t.getSaveMailErrorMessageContainer();
				var $load = t.getLoadingContainer();
				$success.add($error).hide();
				$load.text(str || Lang.get('Loading').messages).show();
			},

			_hideLoading: function()
			{
				var t = this;
//				var $success = t.getSaveMailSuccessMessageContainer();
//				var $error = t.getSaveMailErrorMessageContainer();
				var $load = t.getLoadingContainer();
//				$success.add($error).add($load).hide();
				$load.hide();
			},

			disableEdit: function()
			{
				var t = this;
				if ($.browser.msie && parseInt($.browser.version) < 8)
					t.$composeDisableFormLayer.css('height', t.$composeDisableFormLayer.parent()[0].offsetHeight);
				t.$composeDisableFormLayer.show();
				return	this;
			},

			enableEdit: function()
			{
				var t = this;
				t.$composeDisableFormLayer.hide();
				return	this;
			},

			getContent: function()
			{
				var t = this;
				var editor = t.getEditor();
				var $editorElement = t.getEditorElement();
				return t.isHTMLMode() ? editor.getContent({'format': 'raw'}) : $editorElement.val();
			},

			setContent: function(str)
			{
				var t = this;
				var editor = t.getEditor();
				var $editorElement = t.getEditorElement();
				return t.isHTMLMode() ? editor.setContent(str, {'format': 'raw'}) : $editorElement.val(str);
			},

			isHTMLMode: function()
			{
				var t = this;
				return t.editorMode == mailru.Compose.Form.M_HTML;
			},

			enableTextEditor: function()
			{
				var t = this;

				if (!t.isHTMLMode())
					return;

				var editor = t.getEditor();
				var text = editor.getContent({'format': 'raw'});

				if (text != t.defaultBodyHTML && t._hasFormatted())
				{
					var layer = t.getEnableTextConfirmLayer();
					layer.one('callback', function(evt, status)
					{
						if (status)
						{
							t._enableTextEditorConfirmSuccess();
						}
						else
						{
							t._enableTextEditorConfirmError();
						}
					})[0].show();
				}
				else
				{
					t._enableTextEditorConfirmSuccess();
				}
			},

			enableHTMLEditor: function()
			{
				var t = this;

				if (t.isHTMLMode())
					return;

				t._convertTextToHTML();
			},

			keyboard: function()
			{
				var t = this;
				var savemode = t.isHTMLMode() ? 3 : 0;
				t._openPopup(
					'/kb2?form=Compose&text=Body&keymode=2&savemode=' + savemode,
					'keyb',
					'height=360,width=610,toolbar=no,menubar=no,location=no,scrollbars=no,focus=yes,top=50,left=50'
				);
			},

			transfer: function()
			{
				var t = this;
				var editor = t.getEditor();
				var $editorElement = t.getEditorElement();

				if (t.isHTMLMode())
					editor.save({'format': 'raw'});

				$('input[name="text"]:first', t.$form).val($editorElement.val());

				t._openPopup(
					'/cgi-bin/translate',
					'transfer',
					'menubar=no,resizable=yes,width=750,height=500,toolbar=no,focus=yes,scrollbars=yes,screenX=50,screenY=50,left=50,top=50'
				);
			},

			spelling: function()
			{
				var t = this;
				var editor = t.getEditor();
				var $editorElement = t.getEditorElement();

				if (t.isHTMLMode())
					editor.save({'format': 'raw'});

				$('input[name="text"]:first', t.$form).val($editorElement.val());

				t._openPopup(
					'/cgi-bin/spell',
					'spelling',
					'menubar=no,resizable=yes,width=750,height=500,toolbar=no,focus=yes,scrollbars=yes,screenX=50,screenY=50,left=50,top=50'
				);
			},

			translit: function()
			{
				var t = this;
				var editor = t.getEditor();
				var $editorElement = t.getEditorElement();

				if (t.isHTMLMode())
					editor.save({'format': 'raw'});

				if (t.xhrs['translit'])
					t.xhrs['translit'].abort();

				var text = $editorElement.val();
				if ($.trim(text))
				{
					var p = [text];
					if (window.IS_UTF) p.push('1');
					t.xhrs['translit'] = AjaxCall.send(
						'/cgi-bin/ajax_spell',
						'ajax_translit',
						p,
						$.proxy(t._applyTranslit, t)
					);
				}
			},

			focus: function(type) {
				var editor = this.getEditor();
				var $editorElement = this.getEditorElement();

				if (this.isNew() || this.isForward() || type == 'to') { //mail-10895
					this._formElm('To').focus();
				} else {
					if (this.isHTMLMode()) {
						editor.focus();
					} else {
						$editorElement.focus();
					}
				}

				return this;
			},

			setCaretPositionInStart: function()
			{
				var t = this;
				var editor = t.getEditor();
				var $editorElement = t.getEditorElement();

				if (t.isHTMLMode())
				{
					// problem with IE6
					try {
						var selection = editor.selection;
						var rng = selection.dom.createRng();
						rng.setStart(editor.getBody(), 0);
						rng.setEnd(editor.getBody(), 0);
						selection.setRng(rng);
						editor.getWin().scrollTo(0, 0);
						editor.focus();
					} catch (e){}
				}
				else
				{
					$.Autocompleter.Selection($editorElement[0], 0, 0);
				}
			},

			attachUpload: function(fid, data, cid)
			{
				var t = this;
				var editor = t.getEditor();
				var fileUploader = t.getFileUploader();

				if (cid)
				{
					var $preview = $(editor.dom.get(cid));
					var r = AjaxCall.parseArray(data);

					if ($.isArray(r))
					{
						var fileData = r[1];
						if (fileData)
						{
							if (!fileData.Error)
								t.inlineFiles.push(cid);
						}
					}

					$preview.css('opacity', '');
				}
				else
				{
					fileUploader.triggerHandler('attachUpload', [data, fid]);
				}
			},

			getEnableTextConfirmLayer: function()
			{
				var t = this;
				return t.enableTextConfirmLayer || (t.enableTextConfirmLayer = new Layer('is-enable_text_mode'));
			},

			getSubmitEmptyMessageConfirmLayer: function()
			{
				var t = this;
				return t.submitEmptyMessageConfirmLayer || (t.submitEmptyMessageConfirmLayer = new Layer('is-submit_empty_message'));
			},

			getAppearance: function()
			{
				var t = this;
				return t.appearance || (t.appearance = new mailru.Compose.Appearance(t.getMainFrame(), { domIDs: t.options.domIDs }));
			},

			getFileUploader: function()
			{
				var t = this;
				return t.fileUploader;
			},

			getEditorId: function()
			{
				var t = this, o = t.options;
				return o.editorId;
			},

			getMainFrame: function()
			{
				var t = this;
				return t.$composeEditorFrame;
			},

			getEditor: function()
			{
				var t = this;
				return t.editor || (t.editor = tinyMCE.get(t.getEditorId()));
			},

			getEditorElement: function()
			{
				var t = this;
				return t.$editorElement || (t.$editorElement = $('#' + t.getEditorId()));
			},

			getEditorContainer: function()
			{
				var t = this;
				var editor = t.getEditor();
				return t.$editorContainer || (t.$editorContainer = ((editor && $(editor.getContainer())) || $()));
			},

			getEditorFrame: function()
			{
				var t = this;
				return t.$editorFrame || (t.$editorFrame = $('#' + t.getEditor().id + '_ifr'));
			},

			getEditorToolbar: function()
			{
				var t = this;
				return t.$editorToolbar || (t.$editorToolbar = $(t.options.domIDs.toolbar_external));
			},

			getEditorFrameBody: function()
			{
				var t = this;
				return t.$editorFrameBody || (t.$editorFrameBody = $(t.getEditor().getBody()));
			},

			getSaveMailSuccessMessageContainer: function()
			{
				var t = this;
				return t.$saveMailSuccessMessage || (t.$saveMailSuccessMessage = mailru.v2 ? $('[data-name="saveStatus"]', '.b-toolbar,.b-compose') : $('.saveMailSuccessMessage:first', t.$form));
			},

			getSaveMailErrorMessageContainer: function()
			{
				var t = this;
				return t.$errorContainer || (t.$errorContainer = mailru.v2 ? $('[data-name="saveError"]', '.b-toolbar,.b-compose') : $(t.options.domIDs.composeError));
			},

			getLoadingContainer: function()
			{
				var t = this;
				return t.$loading || (t.$loading = mailru.v2 ? $('[data-name="loadProgress"]', '.b-toolbar,.b-compose') :$('.js-saveMailLoadProgress', t.$form));
			},

			getBottomControlsContainer: function()
			{
				var t = this;
				return t.$bottomControls || (t.$bottomControls = $(t.options.domIDs.bottomComposeControls));
			},

			getBottomControlsHeight: function()
			{
				var $bottomControls = this.getBottomControlsContainer();
				return $bottomControls[0] ? $bottomControls[0].offsetHeight : 0;
			},

			getCaptchaContainer: function()
			{
				var t = this;
				return t.$captchaContainer || (t.$captchaContainer = $(t.options.domIDs.composeCaptchaContainer));
			}
		});

	})(jQuery);

	jsLoader.loaded('{mailru.compose}mailru.Compose.Form', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.Form.js end

jsLoader.loaded('{mailru.compose}mailru.Compose.Modern', 1);

// data/ru/images/js/ru/jsCore/Projects/mail.ru/Compose/mailru.Compose.Modern.js end

// ./data/common/toolkit/b-toolkit/b-toolkit.js start

define(
  'toolkit.js/b-toolkit/b-toolkit'
, [
	  'jquery/jquery.fest'
	, 'jquery/jquery.classList'
	, 'jquery/jquery.event.fix'
	, 'jquery/jquery.event.scroll'
]
, function (){
	window.mailru = window.mailru || {};

	(function (toolkit){
		var gid = 0;
		var _rBEMName = /\b([a-z-]+(?:__[\da-z-]+)*)/ig;
		var _rBEMMods = /(?:\b|__)[a-z0-9\-]+[^_]_([a-z0-9\-]+)(?:_([a-z0-9\-]+))?/ig;

		/**
		 * @class	mailru.toolkit.b-toolkit
		 */
		var Block = function (opts){
			this.__lego.apply(this, arguments);
		};

		Block.fn =
		Block.prototype = {
			constructor: Block,

			eventEmitTo: null,
			eventEmitPrefix: '',

			template: null, // fest template name
			templateBlock: null, // block name

			__lego: function (opts){
				this.uniqId	= 'toolkit-' + gid++;

				$.extend(this, {
					data: {}  // template data
				}, opts);


				// Create event emitter
				var $emitter = $(this);
				$.each({ on: 'bind', off: 'unbind', fire: 'triggerHandler' }, function (myName, jName){
					this[myName] = function (){
						$emitter[jName].apply($emitter, arguments);
						return	this;
					};
				}.bind(this));


				if( this.boundAll ){
					$.each(this.boundAll, function (i, name){
						this[name] = this[name].bind(this);
					}.bind(this))
				}

				this.setElement(opts.el || opts.$el);
				this.init();
			},


			init: function (){
			},


			bound: function (fn){
				if( typeof fn === 'string' ){
					fn = this[fn];
				}
				return	fn.bind(this);
			},


			emit: function (name, args){
				var
					  prefix	= this.eventEmitPrefix
					, method	= $.camelCase('on-' + (prefix ? prefix + '-' : '') + name)
					, event		= $.Event( name.replace(/-/g, '') )
					, emmiter	= this.eventEmitTo || this
				;

				event.target = this;

				if( (emmiter[method] === void 0) || (emmiter[method].apply(emmiter, [event].concat(args)) !== false) ){
					if( !event.isImmediatePropagationStopped() ){
						return emmiter.fire(event, args);
					}
				}
			},


			$: function (selector){
				if( typeof selector === 'string' && /^__/.test(selector) ){
					selector = '.' + this.bemName + selector;
				}
				return	this.$el.find(selector);
			},


			toggleMod: function (mod, state){
				mailru.toolkit.toggleMod(this.$el, mod, state);
				return	this;
			},

			getMods: function (){
				return mailru.toolkit.getMods(this.$el);
			},

			hasMod: function (mod){
				return mailru.toolkit.hasMod(this.$el, mod);
			},

			setElement: function (el){
				if( this.$el ){
					this.$el.unbind('.'+this.uniqId);
				}

				this.$el = el = $(el);
				this.el  = el[0];

				return	this;
			},


			setData: function (data){
				this.data = data;
				return	this;
			},


			getData: function (){
				return	this.data;
			},


			getHtml: function (data){
				var ctx = this.getData();

				if( data ){
					ctx = $.extend({}, ctx, data);
				}

				if( this.templateBlock ){
					ctx = {
						  block:  this.templateBlock
						, params: ctx
					};
				}

				return $.fest(this.template, ctx);
			},


			set: function (opts){
				$.extend(this, opts);
				return	this;
			},


			render: function (data){
				var html = this.getHtml(data);

				var triggerParams = {
					  el: this.$el
					, block: this
					, name: this.bemName
					, template: this.template
					, data: data
				};

				this.emit('before_render', triggerParams);
				$(window).trigger('b-toolkit:before_render', triggerParams);

				this.$el
					.empty() // clear & clean
					.each(function (){
						this.innerHTML = html;
					})
				;

				this.emit('render', triggerParams);
				this.$el.trigger('b-toolkit:render', triggerParams);

				return	this;
			},


			destroy: function (){
				this.$el.unbind('.'+this.uniqId);
			}
		};


		// @static
		Block.extend = function (methods){
			var Ext		= function (){
				this.__lego.apply(this, arguments);
			};
			var Super	= this;

			Ext.prototype = (function (){
				var _toolkit = function (){};
				_toolkit.prototype = Super.prototype;
				return	new _toolkit;
			})();

			Ext.wrap	= Super.wrap;
			Ext.extend	= Super.extend;

			Ext.prototype.__self		=
			Ext.prototype.constructor	= Ext;

			$.extend(Ext.fn = Ext.prototype, methods);

			return	Ext;
		};


		Block.wrap = function (el){
			var $el = $(el), sel = '.'+this.prototype.bemName;
			if( $el.is(sel) ){
				return	new this({ el: el });
			}
			else if( ($el = $el.find(sel)).length ){
				return	new this({ el: $el.first() });
			}
		};


		/**
		 * Create BEM block class
		 *
		 * @param  {String}  name
		 * @param  {Object}  extend
		 * @param  {Object}  [methods]
		 * @returns {Block}
		 */
		toolkit.create = function (name, extend, methods){
			var NewBlock = (methods ? toolkit[extend] : Block).extend(methods || extend);
			toolkit[name] = NewBlock;
			NewBlock.prototype.bemName = name;
			return	NewBlock;
		};


		toolkit.toggleAria = function ($el, mod, state){
			switch(mod) {
				case 'checked':
				case 'disabled':
				case 'expanded':
				case 'hidden':
				case 'invalid':
					$el[state ? 'attr' : 'removeAttr']('aria-'+mod, mod);
					break;
			}
		};


		toolkit.toggleMod = function ($el, mod, state){
			if( $el ){
				if( !$el.jquery ) $el = $($el);

				var evt = jQuery.Event("toggleMod");
				evt.mod = mod;
				evt.modState = !!state;

				$el.trigger(evt);

				if(!evt.isDefaultPrevented()) {
					var name = ($el.attr('class')+'').match(_rBEMName);
					if( name ){
						if( ~name[0].indexOf('js') ) name.shift();
						$el.toggleClass(name[0] +'_'+ mod, !!state);

						toolkit.toggleAria($el, mod, state);
					}
				}
			}
		};


		$.fn.toggleMod = function (mod, state){
			return	this.each(function (){
				toolkit.toggleMod(this, mod, state);
			});
		};


		toolkit.getMods = function($el) {
			var mods = {};

			if( $el ){
				if( !$el.jquery ) {
					$el = $($el);
				}

				// Extract mods
				var className = $el.attr('class'), matches, mod;
				while( matches = _rBEMMods.exec(className) ){
					mod = matches[1];
					mods[mod] = matches[2] || true;
				}
			}

			return mods;
		};


		toolkit.hasMod = function(el, mod) {
			return toolkit.getMods(el)[mod] !== void 0;
		};


		toolkit.isDisabledElem = function (el){
			if( el && el.jquery ){
				el = el[0];
			}

			return	!el || !!($.attr(el, 'disabled') || $.attr(el, 'aria-disabled'))
		};


		$(document).bind('click', function (evt){
			var el = evt.target, meta = [], data, id, name;
			do {
				id = $.attr(el, 'data-id');

				if( id ){
					meta.id = id;
				}
				else {
					name = $.attr(el, 'data-mnemo') || $.attr(el, 'data-group') || $.attr(el, 'data-name');
					if( name ){
						meta.push( name );
					}
				}
			} while( (el = el.parentNode) && (el !== document) );

			if( meta.length ){
				meta.reverse();
				$.event.trigger('toolkitclick', {
					  id: meta.id
					, root: meta[0]
					, name: meta.join('.')
					, names: meta
				});
			}
		});


		// @BEM: label for cbx
		ajs.click('bem.cbx.label.click', function (evt){
			var $cbx = $(evt.currentTarget).find('.cbx');
			toolkit.toggleMod($cbx, 'checked');
		});


		// @lang
		toolkit.lang = {};


		// @export
		toolkit['b-toolkit'] = Block;
	})(mailru.toolkit || (mailru.toolkit = {}));
});

// ./data/common/toolkit/b-toolkit/b-toolkit.js end

// 40
	jsLoader.loaded('{mailru.build}Compose', 0);

})(jQuery, jQuery);

// data/ru/images/js/ru/build/ComposeModern.js end
